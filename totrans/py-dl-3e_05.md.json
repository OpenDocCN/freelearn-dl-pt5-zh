["```py\n    import torch\n    from torch.utils.data import DataLoader\n    from torchvision import datasets\n    from torchvision import transforms\n    batch_size = 50\n    # training data\n    train_data_transform = transforms.Compose([\n        transforms.Resize(224),\n        transforms.RandomHorizontalFlip(),\n        transforms.RandomVerticalFlip(),\n        transforms.ToTensor(),\n        transforms.Normalize(\n            [0.485, 0.456, 0.406],\n            [0.229, 0.224, 0.225])\n    ])\n    train_set = datasets.CIFAR10(\n        root='data',\n        train=True,\n        download=True,\n        transform=train_data_transform)\n    train_loader = DataLoader(\n        dataset=train_set,\n        batch_size=batch_size,\n        shuffle=True,\n        num_workers=2)\n    ```", "```py\n    val_data_transform = transforms.Compose([\n        transforms.Resize(224),\n        transforms.ToTensor(),\n        transforms.Normalize(\n            [0.485, 0.456, 0.406],\n            [0.229, 0.224, 0.225])\n    ])\n    val_set = datasets.CIFAR10(\n        root='data',\n        train=False,\n        download=True,\n        transform=val_data_transform)\n    val_order = DataLoader(\n        dataset=val_set,\n        batch_size=batch_size,\n        shuffle=False,\n        num_workers=2)\n    ```", "```py\n    device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n    ```", "```py\n    import torch.nn as nn\n    import torch.optim as optim\n    from torchvision.models import MobileNet_V3_Small_Weights, mobilenet_v3_small\n    def tl_feature_extractor(epochs=5):\n        # load the pre-trained model\n        model = mobilenet_v3_small(\n            weights=MobileNet_V3_Small_Weights.IMAGENET1K_V1)\n        # exclude existing parameters from backward pass\n        # for performance\n        for param in model.parameters():\n            param.requires_grad = False\n        # newly constructed layers have requires_grad=True by default\n        num_features = model.classifier[0].in_features\n        model.classifier = nn.Linear(num_features, 10)\n        # transfer to GPU (if available)\n        model = model.to(device)\n        loss_function = nn.CrossEntropyLoss()\n        # only parameters of the final layer are being optimized\n        optimizer = optim.Adam(model.classifier.parameters())\n        # train\n        test_acc = list()  # collect accuracy for plotting\n        for epoch in range(epochs):\n            print('Epoch {}/{}'.format(epoch + 1,\n                epochs))\n            train_model(model, loss_function,\n            optimizer, train_loader)\n            _, acc = test_model(model, loss_function,\n                val_order)\n            test_acc.append(acc.cpu())\n        plot_accuracy(test_acc)\n    ```", "```py\n    def tl_fine_tuning(epochs=5):\n        # load the pre-trained model\n        model = mobilenet_v3_small(\n            weights=MobileNet_V3_Small_Weights.IMAGENET1K_V1)\n        # replace the last layer\n        num_features = model.classifier[0].in_features\n        model.classifier = nn.Linear(num_features, 10)\n        # transfer the model to the GPU\n        model = model.to(device)\n        # loss function\n        loss_function = nn.CrossEntropyLoss()\n        # We'll optimize all parameters\n        optimizer = optim.Adam(model.parameters())\n        # train\n        test_acc = list()  # collect accuracy for plotting\n        for epoch in range(epochs):\n            print('Epoch {}/{}'.format(epoch + 1,\n                epochs))\n            train_model(model, loss_function,\n            optimizer, train_loader)\n            _, acc = test_model(model, loss_function,\n                val_order)\n            test_acc.append(acc.cpu())\n        plot_accuracy(test_acc)\n    ```", "```py\n    IMG_SIZE = 224\n    BATCH_SIZE = 50\n    ```", "```py\n    import tensorflow as tf\n    import tensorflow_datasets as tfds\n    data, metadata = tfds.load('cifar10', with_info=True,\n        as_supervised=True)\n    raw_train, raw_test = data['train'].repeat(),\n        data['test'].repeat()\n    ```", "```py\n    def train_format_sample(image, label):\n        \"\"\"Transform data for training\"\"\"\n        image = tf.cast(image, tf.float32)\n        image = tf.image.resize(image, (IMG_SIZE,\n            IMG_SIZE))\n        image = tf.image.random_flip_left_right(image)\n        image = tf.image.random_flip_up_down(image)\n        label = tf.one_hot(label,\n            metadata.features['label'].num_classes)\n        return image, label\n    def test_format_sample(image, label):\n        \"\"\"Transform data for testing\"\"\"\n        image = tf.cast(image, tf.float32)\n        image = tf.image.resize(image, (IMG_SIZE,\n            IMG_SIZE))\n        label = tf.one_hot(label,\n            metadata.features['label'].num_classes)\n        return image, label\n    ```", "```py\n    # assign transformers to raw data\n    train_data = raw_train.map(train_format_sample)\n    test_data = raw_test.map(test_format_sample)\n    # extract batches from the training set\n    train_batches = train_data.shuffle(1000).batch(BATCH_SIZE)\n    test_batches = test_data.batch(BATCH_SIZE)\n    ```", "```py\n    def build_fe_model():\n        \"\"\"\"Create feature extraction model from the pre-trained model ResNet50V2\"\"\"\n        # create the pre-trained part of the network, excluding FC layers\n        base_model = tf.keras.applications.MobileNetV3Small(\n            input_shape=(IMG_SIZE, IMG_SIZE, 3),\n            include_top=False,\n            classes=10,\n            weights='imagenet',\n            include_preprocessing=True)\n        # exclude all model layers from training\n        base_model.trainable = False\n        # create new model as a combination of the pre-trained net\n        # and one fully connected layer at the top\n        return tf.keras.Sequential([\n            base_model,\n            tf.keras.layers.GlobalAveragePooling2D(),\n            tf.keras.layers.Dense(\n                metadata.features['label'].num_classes,\n                activation='softmax')\n        ])\n    ```", "```py\n    def build_ft_model():\n        \"\"\"\"Create fine tuning model from the pre-trained model MobileNetV3Small\"\"\"\n        # create the pre-trained part of the network, excluding FC layers\n        base_model = tf.keras.applications.MobileNetV3Small(\n            input_shape=(IMG_SIZE, IMG_SIZE, 3),\n            include_top=False,\n            weights='imagenet',\n            include_preprocessing=True\n        )\n        # Fine tune from this layer onwards\n        fine_tune_at = 100\n        # Freeze all the layers before the `fine_tune_at` layer\n        for layer in base_model.layers[:fine_tune_at]:\n            layer.trainable = False\n        # create new model as a combination of the pre-trained net\n        # and one fully connected layer at the top\n        return tf.keras.Sequential([\n            base_model,\n            tf.keras.layers.GlobalAveragePooling2D(),\n            tf.keras.layers.Dense(\n               metadata.features['label'].num_classes,\n               activation='softmax')\n        ])\n    ```", "```py\n    def train_model(model, epochs=5):\n        \"\"\"Train the model. This function is shared for both FE and FT modes\"\"\"\n        # configure the model for training\n        model.compile(\n            optimizer=tf.keras.optimizers.Adam(\n                 learning_rate=0.0001),\n            loss='categorical_crossentropy',\n            metrics=['accuracy'])\n        # train the model\n        history = model.fit(\n            train_batches,\n            epochs=epochs,\n            steps_per_epoch=metadata.splits['train'].num_examples /\n                BATCH_SIZE,\n            validation_data=test_batches,\n            validation_steps=metadata.splits['test'].num_examples /\n                BATCH_SIZE,\n            workers=4)\n        # plot accuracy\n        plot_accuracy(history.history['val_accuracy'])\n    ```", "```py\n    from ultralytics import YOLO\n    model = YOLO(\"yolov8n.pt\")\n    ```", "```py\n    results = model.predict('https://raw.githubusercontent.com/ivan-vasilev/Python-Deep-Learning-3rd-Edition/main/Chapter05/wikipedia-2011_FIA_GT1_Silverstone_2.jpg')\n    ```", "```py\n    from PIL import Image\n    Image.fromarray(results[0].plot()).show()\n    ```", "```py\n    from torchvision.models.detection import \\\n    FasterRCNN_ResNet50_FPN_V2_Weights, \\\n    fasterrcnn_resnet50_fpn_v2\n    model = fasterrcnn_resnet50_fpn_v2(\n        weights=FasterRCNN_ResNet50_FPN_V2_Weights.DEFAULT)\n    ```", "```py\n    model.eval()\n    ```", "```py\n    import cv2\n    img = cv2.imread(image_file_path)\n    ```", "```py\n    import torchvision.transforms as transforms\n    transform = transforms.ToTensor()\n    ```", "```py\n    nn_input = transform(img)\n    detected_objects = model([nn_input])\n    ```", "```py\n    draw_bboxes(img, detected_objects)\n    ```", "```py\n    cv2.imshow(\"Object detection\", img)\n    cv2.waitKey()\n    ```", "```py\n    from torchvision.models.detection import \\\n    maskrcnn_resnet50_fpn_v2, \\\n    MaskRCNN_ResNet50_FPN_V2_Weights\n    model = maskrcnn_resnet50_fpn_v2(\n        weights=MaskRCNN_ResNet50_FPN_V2_Weights.DEFAULT)\n    ```", "```py\n    model.eval()\n    ```", "```py\n    import cv2\n    img = cv2.imread(image_file_path)\n    ```", "```py\n    import torchvision.transforms as transforms\n    transform = transforms.ToTensor()\n    ```", "```py\n    nn_input = transform(image)\n    segmented_objects = model([nn_input])\n    ```", "```py\n    draw_segmentation_masks(image, segmented_objects)\n    ```", "```py\n    cv2.imshow(\"Object detection\", img)\n    cv2.waitKey()\n    ```"]