- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combining Reinforcement Learning and Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon is one of the world's leading e-retailers, with sales over US$ 250 billion.
    Amazon's e-store sales exceed all of its other activities, such as AWS subscription
    services (premium, for example), retail third-party seller services, and physical
    stores.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on apparel production activity, one of Amazon's markets
    for which the company recently registered a patent. Prime Wardrobe even offers
    a try-and-easy-return service. This new activity requires planning and scheduling.
    Amazon took the matter seriously and registered a patent for an apparel manufacturing
    system to control the production process of its apparel products.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence already plays a role in automatic planning and scheduling
    in the apparel business, from customer orders through to delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Google has successfully combined deep learning and reinforcement learning (Q-learning)
    in a **deep Q-network** (**DQN**), a system that can beat humans at video games
    and other tasks. Google's AlphaGo DQN has obtained impressive results.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we go beyond merely describing Amazon's process or Google's
    process in particular. I added on my real-life implementations of what we will
    explore and build in Python from scratch. As such, we will combine the ideas of
    several systems (Amazon, Google, and my implementations).
  prefs: []
  type: TYPE_NORMAL
- en: We will add an innovation for the apparel manufacturing industry by adding a
    **conceptual representation learning metamodel** (**CRLMM**) to reinforcement
    learning.
  prefs: []
  type: TYPE_NORMAL
- en: We will go from scratch to a prototype that could be implemented on-site, the
    foundations are being established for further applications in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning and scheduling today and tomorrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further generalization of the CRLMM described in *Chapter 10*, *Conceptual Representation
    Learning*, applied to an apparel production process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeding the CRLMM **convolutional neural network (CNN)** with a simulation of
    frames coming from a webcam on a production line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing an optimizer that will use weights applied to production stations to
    input a reward matrix to a **Markov decision process (MDP)**, which will then
    update the weights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a program that will run continuously (no beginning, no end) on a production
    line using all the three components mentioned previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll begin by talking about planning and scheduling today and tomorrow. The
    market is slowing moving from preplanned processes to real-time processes. Let's
    see how.
  prefs: []
  type: TYPE_NORMAL
- en: Planning and scheduling today and tomorrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Amazon decided to launch Prime Wardrobe, it brought a new service to its
    customers, enabling them to order, try out, and purchase clothing, shoes, and
    other accessories. The customer can establish a purchase plan. A purchase plan
    is a list of tasks to be carried out in a given time. An example of a purchase
    plan could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Filling a box with clothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying on the clothing at home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning the clothing if it does not fit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purchasing the items that are kept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the customer agrees to follow this plan, the time sequence becomes crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a box must be chosen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, there is a delivery period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, there is a trial period (you cannot try the products forever). During
    this period, the customer can choose not to purchase anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the customer confirms the purchase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Irrespective of whether Amazon Prime Wardrobe will remain a service in years
    to come, the precedent is set; just as physical book stores disappear every year,
    shopping for clothing online will continue to expand and occupy more of the market.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that distribution, corporations will continue to expand their production
    sites to become manufacturing-distributing giants. Warehouses will progressively
    replace many stores as per the warehouse examples provided in some of the chapters in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supply chain management (SCM)**, combined with APS, has become a necessity.
    SCM-APS constraints vary constantly on a global market (depending on the manufacturer).
    APS stands for advanced planning and scheduling or automated planning and scheduling.
    We will explore the difference between these two concepts in a following section,
    *A real-time manufacturing revolution*. We will go beyond Amazon''s approach to
    the subject since delivering in real-time has become a constraint for all of the
    actors on the market.'
  prefs: []
  type: TYPE_NORMAL
- en: The pressure of the market has encouraged Amazon to produce its own clothing.
    Amazon has produced its in-house fashion labels with apparel and accessories sold
    worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: To prove that it means business, Amazon registered several patents, including
    one for a *blended reality mirror*, an apparel manufacturing system, and more.
    With a blended reality mirror, a person can visualize how the clothing will fit.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore the planning and scheduling side
    of Amazon's apparel in-house manufacturing plans, which will have the same effect
    on apparel factories as it did on physical book stores and all types of shops.
    Many new jobs will emerge, such as hundreds of thousands of jobs in the artificial
    intelligence business, on websites, and in marketing and SCM. Many jobs will disappear
    as well. The improvements made will boost medical progress and also the defense
    industry. The social and economic implications are beyond the scope of this book,
    and possibly beyond our comprehension, as in all disruptive eras in the past.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus in detail on the main aspects of Amazon's patented custom clothing
    process. As mentioned previously, irrespective of whether it proves successful,
    the precedent is set.
  prefs: []
  type: TYPE_NORMAL
- en: A real-time manufacturing process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today, a customer wants to obtain a purchased product as soon as possible. If
    the waiting time is too long, the customer will go somewhere else. Delivering
    in nearly real-time has become a key concept in marketing for any company. Amazon's
    approach has always been real-time. Pushing the physical limits of centuries of
    commerce, Amazon's brand takes the manufacturing process right beyond the cutting
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon must expand its services to face competition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon could have avoided a great deal of upheaval if it continued to purchase
    products from its suppliers rather than manufacture them. Instead of researchers
    spending a great deal of time developing artificial intelligence capable of solving
    the conveyor belt problem, several sensors could be installed with traditional
    software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Humanity could also have continued to use horses instead of cars and paper instead
    of computers. In the short term, we would have avoided a great deal of work and
    change associated with the requirements and impacts of these technologies. However,
    in the long term, it is progress and innovation that wins out.
  prefs: []
  type: TYPE_NORMAL
- en: Once a disruptive innovation has been successfully launched by a company, the
    competition must either follow suit or disappear. Amazon needs to continue to
    get involved in the process that comes before simply storing goods in its warehouses.
    By getting involved in manufacturing, for example, they can reduce the time it
    takes to deliver a product to a customer. Amazon thus came up with this apparel
    manufacturing patent along with 3D printers, and other innovations to increase
    its productivity.
  prefs: []
  type: TYPE_NORMAL
- en: In the same sense, the field of artificial intelligence needs to be pushed beyond
    its ever-expanding comfort zone constantly. Researchers must be confronted with
    difficult industrial problems to gain experience and produce new algorithms capable of
    achieving higher levels of machine learning and meeting greater challenges.
  prefs: []
  type: TYPE_NORMAL
- en: A real-time manufacturing revolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Artificial intelligence software, though spectacular, is not the only revolution
    that is changing our lives forever. In the 1950s and 1960s, the consumers were
    discovering the joy of purchasing new products such as dishwashers, color televisions,
    and cool radios. They were so happy to be able to obtain these products that they
    were willing to wait days if not weeks to obtain the exact model they dreamt of.
    The supplier could sit on an order for a few days and then get slowly to work.
  prefs: []
  type: TYPE_NORMAL
- en: Today the consumer has lost that patience. If somebody wants to buy a product
    online, it has to be delivered within days. If not, the consumer will turn to
    another supplier. This puts pressure on the supplier, who must immediately start
    the process of delivering. Real-time is that process of starting to get things
    done in the seconds you are notified of a request.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time is a strong force that is changing every process in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Today, apparel manufacturing, and manufacturing in general, follow an advanced
    planning and scheduling process. "Advanced" means both a sophisticated algorithm
    and also an anticipating (planning in advance) process. The planning in advance
    aspect of AI algorithms is going through a revolution.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon, as all manufacturing processes, requires automated planning and scheduling
    to meet shortening delivery times.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between the two systems is the time factor, as shown
    in the following comparison table. The difference between an advanced and an automated
    system seems small, but Amazon, like others, will change the course of history
    through those differences. Both systems, in theory, can do both types of tasks.
    In practice, these methods will specialize in their niches in the years to come.
    To manufacture an airplane, a sophisticated *advanced* algorithm still needs to
    plan in *advance* (days to weeks) with a lot of manual decision making. To manufacture
    basic T-shirts, *automated* planning can be done quickly and automatically in
    real-time (seconds to hours)
  prefs: []
  type: TYPE_NORMAL
- en: The trend of automated planning and scheduling is becoming a time-squashed version
    of advanced planning and scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The figures in the following table do not reflect the exact numbers but the
    trends:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Advanced planning and scheduling** | **Automated planning
    and scheduling** |'
  prefs: []
  type: TYPE_TB
- en: '| Long-term plan  | 1 month to 5 years | A few days to less than a month |'
  prefs: []
  type: TYPE_TB
- en: '| Short-term plan | 1 day | 1 minute |'
  prefs: []
  type: TYPE_TB
- en: '| Production or event measurement | Taken into account on a daily basis in
    general | Real-time |'
  prefs: []
  type: TYPE_TB
- en: '| Scheduling | 1 hour to 1 week | Real-time |'
  prefs: []
  type: TYPE_TB
- en: '| Re-planning when there is a problem | 1 hour to 1 month | Real-time |'
  prefs: []
  type: TYPE_TB
- en: '| Re-scheduling | 1 hour to 1 week | Real-time |'
  prefs: []
  type: TYPE_TB
- en: '| Resource adjustment | 1 day to 1 month | Real-time |'
  prefs: []
  type: TYPE_TB
- en: '| Load balancing | 1 hour to 1 week | Real-time |'
  prefs: []
  type: TYPE_TB
- en: '| Automatic functions of planning and scheduling | 80% | 99% |'
  prefs: []
  type: TYPE_TB
- en: 'Although this table contains approximate information, the underlying trend
    is extremely strong. We''ve seen the differences between the concepts of advanced
    and automated; let''s also clarify the differences between planning and scheduling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **plan** consists of processes preparing production for the future: purchasing
    material components and adapting human resources and physical resources. Amazon,
    for example, has a yearly business plan: putting together the necessary resources
    in advance to be ready for production. This implies purchasing or building warehouses,
    hiring employees, and purchasing basic material resources (boxes, labels, and
    other components).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling** confronts the plan with the time factor on a shorter horizon.
    Scheduling determines when each part of the plan will come first and be produced.
    For example, now that the warehouse is built or purchased (plan), at what time
    (schedule) should packaging start working next Monday and for the weeks to come?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A schedule can be regarded as a zoomed-in version of a plan.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If somebody walks into Jeff Bezos' office with a plan to build a warehouse at
    a given location with the cost and general timing of the implementation, that
    is fine. That person is presenting a two-year project. The project will start
    in 10 months and go on for two years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, that person might (I suggest not!) say: *The plan is great since it will
    be ready in 10 months. But I''m worried about the daily schedule in 1 year of
    shift #2 at 4 p.m. Should they start at 7:30 a.m. or 7:45?* Jeff Bezos will no
    longer be listening. That zoom level is not part of his job description. He has
    to focus on a higher level. It is useless for a top manager to know what''s going
    to happen a year from now at 4 p.m.!'
  prefs: []
  type: TYPE_NORMAL
- en: An advanced planning and scheduling system mostly imports data from ERPs to
    make plans in the future. An automated planning and scheduling program mostly
    detects data with sensors to react and optimize in real-time. The present chapter
    deals with automated planning programs, not advanced planning and scheduling systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the evolution between an advanced APS and an automated APS as a logistic sigmoid
    function applied to planning-scheduling time squashing. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The advanced plan to manufacture a car spans a month to a year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Google Maps itinerary automated plan for a self-driving car at its starting
    point: a few seconds to a minute, depending on the connection status of that location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The schedule to manufacture a car: 1 day to 1 month.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The schedule to pilot a self-driving car following the Google Maps itinerary
    = *real-time*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To sum it up, the present trend represents a revolution in the history of human
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon's manufacturing patent reflects the revolution of real-time applied to
    every field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Planning has moved up to planning in real-time, as shown in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15483_11_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In which:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* is a quantity to produce or any unit event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t*[x] is the time (*t*) it takes for *x* to start and end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A logistic function squashes *t*[x].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B15483_11_002.png) (lambda) is the learning factor; the more a task
    is carried out, the more it is optimized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*X*[t] is the total weight of a group of *n* tasks at a given time *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*X*[t] = {*x*[1], *x*[2], *x*[3] … *x*[n]}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between *X*[t] and *Z*(*X*[t]) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*X*[t] is the actual time it takes to manufacture products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Z*(*X*[t]) is not the actual time it takes. *Z*(*X*[t]) is the result of an
    activation function that squashes time as an output of *X*[t] in an RL-DL-CRLMM
    network. *Z*(*X*[t]) is a weighting factor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key to reducing the weighting factor further is a physical production process
    and other physical events (outputs, for example), that I call lambda: ![](img/B15483_11_003.png)
    signifies all the improvements in real-life production that can reduce the production
    cycle as well as the natural events, such as production output.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Conceptual Representation Learning*, ![](img/B15483_11_004.png)
    was introduced to reduce gaps. In this chapter, ![](img/B15438_10_003.png) will
    be generalized a step further to optimize ![](img/B15483_11_006.png).
  prefs: []
  type: TYPE_NORMAL
- en: This means that an RL-DL-CRLMM system will optimize the manufacturing process.
    We will now explore a game-changing automated apparel manufacturing process and
    build it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: CRLMM applied to an automated apparel manufacturing process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an automated planning and scheduling system, not an advanced planning and
    scheduling system, Amazon has brought apparel manufacturing closer to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence will boost existing processes. In this section, an RL-DL-CRLMM
    system will optimize an apparel manufacturing process.
  prefs: []
  type: TYPE_NORMAL
- en: An apparel manufacturing process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amazon''s apparel manufacturing patent can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P1**: Grouping apparel customer orders by products and sizes. This process
    has been around since the origins of industrial apparel manufacturing centuries
    ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P2**: Automatically cutting lays. A lay is a stack of pieces of cloth. It
    is like cutting a circle in a stack (lay) of several pieces of paper at the same
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P3**: Moving the packs of the parts of clothing to the assembly lines on
    conveyor belts (see *Chapter 10*, *Conceptual Representation Learning*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P4**: Other operations depending on the products (packaging or printing or
    other).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P5**: Storing and optimizing the distribution process through warehouses
    and deliveries and many more processes (tracking and data analysis, for example,
    finding late deliveries and optimizing their routes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents the production flow at an apparel manufacturing
    company. First, the fabric is cut, and then it is stacked in piles and sent by
    a conveyor belt to sewing stations to assemble the clothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Apparel production flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'A webcam is set up right over P3, the conveyor belt. The following image represents
    the webcam above the conveyor belt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Webcam freezing frames on a conveyor belt'
  prefs: []
  type: TYPE_NORMAL
- en: The webcam freezes a frame (within the red rectangle) every *n* seconds. The
    frame is the input of the CRL-CNN described later.
  prefs: []
  type: TYPE_NORMAL
- en: This image is a representation of the concepts. In reality, the webcam may be
    located at the beginning of the conveyor belt, or even over the output of the
    cutting process. For the prototype in this chapter, keep in mind that every *n*
    seconds, a frozen frame is sent to the trained CNN.
  prefs: []
  type: TYPE_NORMAL
- en: 'This P1 to P5 flowchart provides a general idea of an apparel manufacturing
    process. In an actual company, many more processes are required: market studies,
    designing products, testing prototypes, adding manufacturing processes for jeans
    (making holes with a laser, for example), and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: Every process described so far was invented individually 30+ years ago, including
    automatic cutting and conveyor belts applied to the apparel business. *What's
    new here?* springs to mind in the case of many apparel experts reading about Amazon.
    And that is the mind trap! Thinking that Amazon's apparel patent does not contain
    new components is a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time squashing** is the core of the Amazon innovation process. Bringing manufacturing
    closer to the consumer in near-real time is a revolution that will become disruptive.
    Add 3D printers to the time squashing equation, and you will easily picture the
    future of our consumer markets. However, artificial intelligence has the right
    to enter the optimizing competition as well.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let's build an AI model that optimizes P3, the conveyor
    belt. Many solutions already exist as well, but an RL+DL can most probably beat
    them just as it will in many fields.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to generalize the ![](img/B15483_11_007.png) model described
    in *Chapter 10*, *Conceptual Representation Learning*, a bit further through training.
    Then, the RL-DL-CRLMM can be built. We will first explore how the CRLMM is trained
    to analyze web frames in production.
  prefs: []
  type: TYPE_NORMAL
- en: Training the CRLMM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 10*, *Conceptual Representation Learning*, introduced CRLMMs using
    ![](img/B15438_10_010.png) (gap concepts) to illustrate one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapters, conceptual subsets around ![](img/B15438_10_022.png)
    (gap concepts) were designed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15483_11_010.png), which contains *pg*[i] (*p* = positive) and *ng*[i]
    (*n* = negative subsets)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '*ng*[1] is a subset of ![](img/B15483_11_011.png); *ng*[1] = {missing, not
    enough, slowing production down … bad},'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pg*[2] is a subset of ![](img/B15483_11_007.png); *pg*[2] = *pg*[2] = {good
    production flow, no gap}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*g*[2] = {loaded}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*g*[3] = {unloaded},'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pg*[4] = {traffic jam, heavy traffic … too much traffic}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ng*[5] = {open lane, light traffic … normal traffic}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CNN_STRATEGY_MODEL.py` needs to be trained to recognize ![](img/B15483_11_013.png)
    in an apparel production environment as well as remember how to recognize former
    ![](img/B15438_10_028.png) concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The cutting section P2 (A and B) output of apparel packs flowing on a conveyor
    belt (P3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember how to classify the cakes of the food processing company to teach the
    model to recognize more situations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember how to perform a traffic analysis (see *Chapter 10*, *Conceptual Representation
    Learning*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to be able to classify an abstract representation of a gap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing the unit training dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To generalize the unit training dataset, six types of images were created. Each
    image represents a webcam frame taken over a conveyor belt every *n* seconds.
    Four images are figurative in the sense of figurative painting. Two images bring
    the CRLMM program to a higher level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Food conveyor belt processing – positive p![](img/B15483_11_015.png) and negative
    n![](img/B15483_11_016.png) gaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the food processing industry example (see *Chapter 9*, *Abstract Image Classification
    with Convolutional Neural Networks (CNNs)*, a gap on the conveyor belt was most
    often negative, a *negative gamma* = *n![](img/B15483_11_017.png)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following frame shows that the first line of production is complete, but
    not lines two and three:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Food conveyor belt processing frame'
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, with approximately no gaps, the load on the conveyor belt was
    viewed as positive, a *positive gamma* = *p![](img/B15483_11_018.png)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following frame shows that there is an acceptable number of products per
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Food conveyor belt processing frame'
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding images show, whatever the product is on a conveyor belt, a
    gap remains a gap, an empty space. We will now apply our model to other gaps whatever
    the object may be. In this case, we will detect gaps on an apparel conveyor belt.
  prefs: []
  type: TYPE_NORMAL
- en: Apparel conveyor belt processing – undetermined gaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A gap in an apparel conveyor belt process is most often undetermined. This constitutes
    a major optimization problem in itself. Naturally, if the conveyor belt is empty
    or saturated, the variance will attract the attention of a human operator. However,
    most of the time, optimization solves the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following frame shows a relatively well-loaded production flow of apparel
    packs of pieces of clothing to be assembled (by sewing them together) further
    down the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Well-loaded production flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following frame clearly shows a gap, meaning that the quantity that will
    be sent to a sewing station will not be high:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Production flow (gap)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several observations are necessary to optimize this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: The conveyor belt real-time problem excludes running advanced planning and scheduling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This problem requires real-time automated planning and scheduling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The automated planning and scheduling solution will have to both plan and schedule
    in real-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will take planning constraints into account (as explained in the following
    sections) to predict outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will take scheduling constraints into account to optimize the sewing sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon and others have slowly, but surely, brought many planning horizon problems
    (longer) down to shorter scheduling horizons, pushing the limits of SCM further
    and further.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of an abstract notion of gaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The gaps shown have negative or positive properties depending on the context.
    The CRLMM model now has to learn a meta conceptual abstract representation of
    all the gaps mentioned hitherto. These gaps are all flow gaps of one sort or another.
    Something is moving from one point to another in small packs. The packs, therefore,
    are often not the same size, and this causes gaps to form.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts can be applied to cattle herds, horse races, team sport attacks
    (football, soccer, rugby, basketball, handball, and other fields), Olympic races,
    marathons, conveyor belts, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the packs in the flow are close to each other, an individual mental image
    crops up. Each person has a customized version. The following image is a generalized
    representation of a no-gap concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: A generalized representation of a no-gap concept'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the packs have leaders and followers. Then, an abstract representation
    comes up as well. The following image shows a generalized representation of a
    gap concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: A generalized representation of a gap concept'
  prefs: []
  type: TYPE_NORMAL
- en: Humans do not have a flow detection gap function for each thing they are observing. Humans
    have one brain that contains physical memories or other datasets, but, more importantly,
    they have abstract datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Every single one of us billions of thinking bipeds has extremely efficient abstract
    datasets. The meta-concept shown previously means that through inferences, a human
    has a central meta-concept with a dataset of memories that fit with it through experience.
  prefs: []
  type: TYPE_NORMAL
- en: A meta-model uses these datasets. The dataset in the `dataset` directory contains
    the beginning of a CRLMM system. The program will learn what a *flow gap* is and
    then apply it to what it sees by analyzing the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'This goal of this dataset leads to a CRLMM, as explained in the following sections
    in which:'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract learned meta-concept is applied to a situation; in this case, a
    frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CRLMM then determines whether it is a gap or no-gap situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CRLMM then makes a decision, using a thinking optimizer based on a decision
    weight-orientated activation function. This means that it is more than a mathematical
    *squash*. It's *weighing* the pros and cons of a decision-making process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, our CRLMM has learned to identify gaps on an apparel conveyor
    belt. If we were to implement this, we would add many web frames of a conveyor
    belt of our project to our datasets to do the training. For now, let us continue
    with this example and run a prediction program to classify the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: Running a prediction program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The training was done with the same `CNN_STRATEGY_MODEL.py` program described
    in *Chapter 9*, *Abstract Image Classification with Convolutional Neural Networks
    (CNNs)*, which was designed to be generalized for subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Once the dataset of the previous section has been installed, the model can make
    predictions with no further training in various domains.
  prefs: []
  type: TYPE_NORMAL
- en: The same `CNN_CONCEPT_STRATEGY.py` functions described in *Chapter 10*, *Conceptual
    Representation Learning*, were implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the path to the dataset was changed, along with the prediction messages
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The CRLMM has now learned to represent real-life memories and inference of the
    associated memories in a meta-concept. Our CRLMM is ready to be assembled as one
    of the three components of RL-DL-CRLMM as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building the RL-DL-CRLMM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full code of the RL-DL-CRLMM program is `RL_DL.py`. It is built on the knowledge
    and programs of the previous chapters and previous sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RL-DL-CRLMM contains three components:'
  prefs: []
  type: TYPE_NORMAL
- en: A CRLMM convolutional network that will analyze each frame it receives from
    the webcam that is located right over the pieces of garment packs on the conveyor
    belt coming from the cutting section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optimizer using a modified version of the *Z*(*X*) described previously that
    plans how the assembly stations will be loaded in real-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An MDP that will receive the input of the optimizer function and schedule the
    work of the assembly stations. It also produces the modified *Z*(*X*) updated
    value of the weights of each assembly station for the next frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the physical world, the conveyor belt transports the garment packs, a picture
    (frame) is taken every *n* seconds, and the RL-DL-CRLMM runs. The output of the
    RL-DL-CRLMM sends instructions to the conveyor belt and directs the garment packs
    to the optimized load of the assembly stations, as explained before.
  prefs: []
  type: TYPE_NORMAL
- en: Since `RL_DL.py` describes a continuous RL-DL-CRLMM process, there is no beginning
    or end to the program. The components are independent and are triggered by the
    input sent to them, and they trigger others with their output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, components will be described in the processing order but not in the code-in-line
    order. This is because the functions defined by `def` + `function()` precede the
    function calls to them. Code line numbers will thus be inserted in the comments
    following the code line like this: `# [Line 38]`.'
  prefs: []
  type: TYPE_NORMAL
- en: A circular process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the three main components of the system are in place (CNN, MDP, optimizer),
    the circular property of this RL-DL-CRLMM is a stream-like system that never starts
    nor ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a circular process, let''s take an everyday example. Customer C goes
    to the supermarket to purchase a product. The product was previously stored in
    a warehouse that we will name B. A factory named A manufactures this product.
    If you look at the whole supply chain at a given time, you will see there is no
    starting or ending point:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are A, you are both monitoring the needs of C to send products to B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are B, you are both monitoring what is coming from A to satisfy C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are C, you are creating a demand for A to deliver B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a real-life supply chain, there is no beginning and no end. The same applies
    to an automated production site to the flow of functions in this virtually memoryless
    system. The conveyor belt's webcam provides a stream of frames, forcing the system into
    circular stream-like behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CNN-CRLMM to detect gaps and optimize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CNN-CRLMM function was described in the *Running a prediction program*
    section and in *Chapter 10*, *Conceptual Representation Learning*. The prediction
    function is part of the MDP output analysis described later. The `CRLMM` function
    is called as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first part of this function squashes the *W* vector described in the following
    section. The second part of this function analyzes the input frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since no webcam is connected to the system at this point (that must be done
    during project implementation), a random image (frame) choice is made. The following
    random code simulates the random occurrences of real-life production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In a real-life situation, random quantities will be going through the conveyor
    belt. With the status having being determined, the CNN simulates the addition
    of a frozen frame from the video stream coming from the webcam located directly
    on the conveyor belt. It runs the identity (image) function described before and
    returns a `gap` or `no gap` scenario for the optimizer (refer to the optimizer
    section). The following code describes a gap identification process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once `status` has been detected, irrespective of whether the load output of
    the cutting system is high or low, a decision must be made. This will be done
    with the MDP.
  prefs: []
  type: TYPE_NORMAL
- en: Q-learning – MDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding an MDP Q-learning decision function (see *Chapter 1*, *Getting Started
    with Next-Generation Artifcial Intelligence through Reinforcement Learning*) in
    this CNN-CRLMM program, we are now entering the world of cognitive RL-DL programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this real-time system, there is no beginning, no end, and no real memory
    beyond a few frames.
  prefs: []
  type: TYPE_NORMAL
- en: The `mdp01.py` MDP program has been incorporated into `RL_DL.py`. Thus, only
    the changes made are described in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'MDP parameters come right after the import packages. Each vertex of the graph
    has its letter and location, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program runs, the following graph will be displayed with red (target
    vertices) for this frame. It is then up to the MDP to choose, described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Output (target vertices)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this is an undirected graph with vertices (the colored dots) and
    no edge (lines) directions. The MDP will provide directions for each frame in
    this model.
  prefs: []
  type: TYPE_NORMAL
- en: Each vertex represents an assembly station in this model. Each assembly station
    has a high workload or a low workload. The workload is rarely stabilized because
    products keep flowing in and out as they are produced.
  prefs: []
  type: TYPE_NORMAL
- en: MDP inputs and outputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MDP process in this model uses a reward matrix as an input and produces
    a weight vector.
  prefs: []
  type: TYPE_NORMAL
- en: The input is a neutral reward matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The MDP reward matrix is set to `0`, except for the values representing the
    edges of the graph that can be physically accessed; these are set to `1`, a small
    neutral value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is, the MDP cannot provide a satisfactory result beyond reproducing the
    structure of this undirected graph. The reward matrix is now initialized and duplicated
    as shown in the following code, starting from line 41; at line 43, `R`, the reward
    matrix is built, and at `Ri`, a duplicate of `R` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Ri` is a copy of the initial-state zero-reward matrix. `R` is reset to `Ri`
    at every new frame. MDP trains the assembly location plan for each new frame in
    a memoryless, undirected graph and unsupervised approach.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Q` is the learning matrix in which rewards will be learned/stored, as shown
    in the code on line 58:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The standard output of the MDP function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The load of the assembly stations is not the exact quantity produced. They are
    weights that are updated continuously during this continuous process, as explained further
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At an initial state of the program, the initial weight of the vertices is set
    to `0` in the following line of code (line 40):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The weight vector (represented as an array) contains one value per assembly
    station location or vertex.
  prefs: []
  type: TYPE_NORMAL
- en: An initial state is not a real beginning. It is like a pause button on a video.
    The initial state can come from a holiday (no production), a maintenance day (no
    production), or a lack of input orders (no production). The initial state is just
    a case when the weights are equal to `0` because there is nothing on the conveyor
    or assembly stations.
  prefs: []
  type: TYPE_NORMAL
- en: The weight vector is part 1 of the optimizer (see the following section). The
    MDP produces an output matrix after having optimized the undirected graph. The
    optimizer will have provided a target.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program contains the same source code as in *Chapter 1*, *Getting Started
    with Next-Generation Artifcial Intelligence through Reinforcement Learning*, with
    Bellman''s equation starting from line 1166\. The MDP produces its result, as
    shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that this entire DQN-CRLMM is not only based on the undirected
    memoryless MDP function but also has no real beginning nor end since it's a continuous
    and virtually memoryless process.
  prefs: []
  type: TYPE_NORMAL
- en: A graph interpretation of the MDP output matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After each run, the MDP matrix also produces a graph interpretation of the
    values of paths between the vertices from point to point (letter to letter), and
    displays it in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This way, if the values are taken from the highest to the lowest edges (lines
    and, hence, values between two letters), it gives a visual idea of how the MDP
    function calculated its way through the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '`RL` is the letter vector. It is empty after each frame. It will be filled
    by finding the values of each edge. It will contain the letters of the vertices
    (nodes and dots) connected by the edges (lines represented by the values).'
  prefs: []
  type: TYPE_NORMAL
- en: '`RN` is the value of the edges. The following code shows how to implement `RL`
    and `RN` and update the weights of the locations in the weight vector (`W`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The logistic function in the preceding code is being updated while `RL` and
    `RN` are being updated.
  prefs: []
  type: TYPE_NORMAL
- en: The optimizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have written several optimizers for fabric optimization in the apparel industry.
    In this case, the optimizer will be used to regulate the flow of production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term "optimizer" is not the CNN `rmsprop` optimizer used in the previous
    chapters represented with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The term "optimizer" refers to a function that optimizes the production of this
    manufacturing site. It is not an optimizer used to train a CNN, for example. This optimizer
    is both an activation function and a regulator that was built from scratch to
    optimize production. This shows that you must sometimes invent the optimizer you
    need to generate a profitable solution for your customer or company.
  prefs: []
  type: TYPE_NORMAL
- en: The optimizer as a regulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The whole concept of this RL-DL-CRLMM of real-time production, applied to P3,
    is to optimize *Z* over the load distribution of the assembly stations, as explained
    before. This means reducing *Z* as much as possible through the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15483_11_019.png)'
  prefs: []
  type: TYPE_IMG
- en: To achieve this optimization goal, *Z* needs to be taken apart and applied to
    strategic parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Z – squashing the MDP result matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The output of the MDP functions provides the following `Q` matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line represents a vertex in the graph: A, B, C, D, E, and F. Each value
    obtained needs to be squashed in the following *z*(*x*) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15483_11_020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step in the code that follows is to squash the weights provided by
    the MDP process for each line (vertex) *x* with a `logistic_sigmoid` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is called by the transformation of the MDP `Q` output matrix into
    the weight vector for each column of each line, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, each value of the MDP has lost any real-life value. It is a weight,
    just as in any other network. The difference is that the whole system is controlled.
    In a real-life project, keeping an eye on the calculations through reports is
    necessary for maintenance purposes. Even an automatic system requires quality
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MDP matrix has now been flattened into a weight matrix, as shown in the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each vertex (letter in the graph) now has a weight.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Z – squashing the vertex weights vector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Squashed `W` (vertex weights) grows after each frame analysis, and each MDP
    run since `W[j]+` is applied continuously, and `W` is never set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Once launched, the RL-DL-CRLMM is a continuous process, with no beginning and
    no end as long as the conveyor belt is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conveyor belt is sending assembly (mostly sewing) work to the assembly stations
    that take some time (*t*) to get the job (*x*) represented by *t*[x] in the *Z*
    equation and the *W* vector in the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, work is piling up on each vertex (A to F), which represents an assembly
    station.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is why the ![](img/B15483_11_021.png) variable in the *Z* equation is
    implemented, as shown in the initial equation early in the chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15483_11_022.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B15483_11_006.png) is implemented for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The sewing or assembly stations send their finished work to the next operation
    on the production line, packaging, for example. So every *m* minutes, their workload
    goes down, and so does the load feature weight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production managers are constantly working on learning curves on assembly lines.
    When a new product arrives, it takes some time for the teams to adapt. Their output
    is a bit slower than usual. However, well-trained teams bring the learning period
    down regularly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B15483_11_024.png) combines both concepts in a single variable. This
    might be enough for some projects. If not, more work and variables need to be
    added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this model, ![](img/B15483_11_025.png) is activated by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`oif` represents the frequency of a `W` vector ![](img/B15483_11_026.png) update.
    In this example, `oif` is set to `10`. This means that every 10 frames, `oir`
    will be applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oir` represents the output rate for the two reasons described before. This
    variable will squash the `W` vector by the % given. In this example, `oir=0.2`.
    That means that only 20% of the weights will be retained. The rest has been finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to implement `oif` and `oir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `W` vector has been squashed again, as shown in this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The optimizer has provided updated information on the status of each sewing
    station. Each sewing station is a location for the MDP function. We will now see
    how the MDP function uses the information provided by the optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the main target for the MDP function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*W*, the weight vector, is updated after each frame with a short-term memory
    of *n* frames. This means that in every *n* frames, its memory is emptied of useless
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the optimizer is to provide a target for the MDP function. On the
    first episode, since it does not have any information, the optimizer selects a
    random state, as shown in the following code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that a random assembly station will be chosen on the MDP graph, which represents
    the six assembly sewing stations. Once this episode has been completed, the system
    enters a circular real-time cycle (refer to the next section).
  prefs: []
  type: TYPE_NORMAL
- en: The second episode has the `W` vector to rely upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'This runs the `crlmm` (described before) CNN-CRLMM network to determine whether the
    frame has a gap or no-gap feature, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The optimizer will use `W` to:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the vertex (sewing station) with *somewhat* the smallest weight if the CNN
    on the frame produces a result with `no gap` (probability is zero). Since there
    is no gap, this means that there are many pieces to sew. Thus, it is much better
    to give the work to an assembly station that has a lower load than others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the vertex (sewing station) with *somewhat* the highest weight if the
    CNN on the frame produces a result with a `gap` (probability is one). Since there
    is a gap, it means there are not that many pieces to sew. Thus, it is much better
    to give the work to an assembly station that already has a higher workload. It
    will balance the loads and optimize the load distribution over all the stations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce a choice to find one target assembly station for the MDP function
    in each of these cases. It will look for stations (vertices, letters, dots in
    the graph) with the highest weight in one case and the lowest in another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the *somewhat* concept referred to before. The system must remain relatively
    free, or it will keep choosing the same best sewing stations, depriving others
    of work. Thus, each possibility (`gap` or `no gap`) is limited to a random choice
    of only three among the six locations for each weight class (higher or lower).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The optimizing function, shown in the following snippet, can prove extremely
    profitable on real-life industrial production lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`lr` is the main location chosen for the MDP reinforcement learning function,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Reinforcement learning has to run every time since it faces new frames in the
    continuous process of the conveyor belt in the automated apparel system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the MDP reward matrix is reset to its initial state, as implemented in
    these lines of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The target location is initialized with a value that fits the gap or no-gap
    philosophy of the program. If there is no gap, the value is higher, and so will
    be the weight (represented load of the station) in the end. If there is a gap,
    the value is lower, and so will be the weight for that station, as shown in the
    following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We just explored the MDP process. However, the overall program we are looking
    at is a circular process that runs 24/7\. At a given time, all of the components
    of our AI program are running at the same time. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: A circular model – a stream-like system that never starts nor ends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully converted the linear stream of production (conveyor belt,
    optimizer, and sewing stations) into a circular process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the RL-DL-CRLMM model runs nonstop, it can run at all of the following
    points at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: A = Captures a frame of the output of the cutting section with a webcam and a
    CNN-CRLMM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B = Analyzes the load (histograms of each sewing section) with the CRLMM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C = Optimizes the sewing stations with an MDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ABC is one flow. But since each process is running nonstop, we can see all
    of the following flows at the same time: A, B, C or B, C, A or C, A, B.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph represents the circular process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Circular RL-DL-CRLMM'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram describes an automatic process. However, let's go back a step and
    imagine we are in a factory in which humans still make the decisions. The process
    is circular, which means it never stops or starts. It runs 24/7\. We will suppose
    a floor manager is an optimizer represented by the blue bar charts. The floor
    manager will look at the sewing stations to see who has a lot of work to do and
    who has little work to do. Then the floor manager will observe the conveyor belt
    (the web frame with the image of the packs) that is bringing packs of cut cloth
    to sew into garments. The floor manager will select several packs where there
    is a gap on the conveyor belt for the least loaded sewing stations, for example.
    Once the choice has been made, the floor manager will direct the packs to the
    right sewing station following calculating the graph (MDP) manually.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore these steps in further detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step X**: When the following frame arrives, the CRL-CNN is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: The CRL-CNN gets activated'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution calls the `CRLMM` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output displays the status of the image: `gap`, `no gap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following weights of each sewing station (vertices A to F) are taken into
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The program displays them in text form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The program also displays the following bar chart of the weights of each sewing
    station:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Bar chart of the weighs of each sewing station'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **STEP X+1** optimizer analyzes the weights to make a decision: send small
    quantities to the sewing stations that have a lot of work and large quantities
    to sewing stations that have less work to do.'
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, the optimizer makes sure that each sewing station has an optimal
    workload. If a sewing station has a lot of work piling up, it makes sense to give
    a large amount of incoming work to a sewing station with little work to do. That
    way, all of the sewing stations will be working at full capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_10_023.png) (gamma) has now reached a point at which it understands
    that a gap is a comparison between two states and inference of a conceptual distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overloading**: Too much'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Underloading**: Not enough'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B15483_11_028.png) now contains two abstract concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Enough to too much
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not enough to lacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of the circular process is to keep the bars at an approximately similar
    height—not an exact height, but also not a situation in which A would have no
    work to do, and E would be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP X+2**: The MDP, as described in this chapter, receives instructions
    to optimize a given sewing station and spreads work out to its neighbors. This
    is often a production constraint: one station sews the sleeves of a T-shirt. For
    example, the station nearby sews a pocket on the T-shirt. The MDP spreads out
    the work, starting with the target location. In this case, the target location
    is one of the sewing stations in the A-E-D area (the area is displayed in color
    when you run the Python program) as shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_11_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: MDP spreads out'
  prefs: []
  type: TYPE_NORMAL
- en: The MDP sends its results directly to the conveyor belt, which automatically
    follows the path instructions sent to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the MDP updates the weights, empties its reward matrix, and waits for
    a new one. The system goes back to step X.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed, no human operator is involved in this entire process
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying artificial intelligence to Amazon's real-time sales, production, and
    delivery forces projects into reality.
  prefs: []
  type: TYPE_NORMAL
- en: Learning machine learning and deep learning with MNIST, CIFAR, and other ready-to-use
    datasets with ready-to-use programs is a prerequisite to mastering artificial
    intelligence. Learning mathematics is a must.
  prefs: []
  type: TYPE_NORMAL
- en: Building a few programs that can do various theoretical things cannot be avoided.
    However, managing a real project under corporate pressure will bring an AI specialist
    up to another level. The AI specialist will have to put AI theory into practice.
    The constraints of corporate specifications make machine learning projects exciting.
    During those projects, experts learn valuable information on how AI solutions
    work and can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter described an RL-DL-CRLMM model with an optimizer. We learned how
    the market is evolving from planning manufacturing in advance to real-time planning
    challenging classical processes. We saw that a consumer wants to receive a purchased
    product as soon as possible. If that product is not available to demand, it must
    be produced in nearly real-time and delivered to the customer. To automate this
    process, we built a Python program that can scan an apparel conveyor built to
    detect gaps in a cutting process with a CNN, use an optimizing function to choose
    the best sewing workstation and then build a graph with MDP to represent the optimized
    path taken.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explores an application of this solution with an SVM applied
    to a self-driving car situation in an IoT context, Swarm AI, and elementary AGI.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CNN can be trained to understand an abstract concept? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it better to avoid concepts and only use real-life images? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do planning and scheduling mean the same thing? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is Amazon's manufacturing patent a revolution? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learning how warehouses function is not useful. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Online marketing does not require artificial intelligence. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More information on Amazon''s apparel manufacturing innovation and apparel
    market can be found here: [https://www.nytimes.com/2017/04/30/technology/detailing-amazons-custom-clothing-patent.html](https://www.nytimes.com/2017/04/30/technology/detailing-amazons-custom-clothing-patent.html),
    [https://www.amazon.com/learn-more-prime-wardrobe/b?ie=UTF8&node=16122413011](https://www.amazon.com/learn-more-prime-wardrobe/b?ie=UTF8&node=16122413011)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
