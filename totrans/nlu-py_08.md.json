["```py\nimport re\n# process US street address\n# the address to match\ntext = \"223 5th Street NW, Plymouth, PA 19001\"\nprint(text)\n# first define components of an address\n# at the beginning of a string, match at least one digit\nstreet_number_re = \"^\\d{1,}\"\n# match street names containing upper and lower case letters and digits, including spaces,\n# followed by an optional comma\nstreet_name_re = \"[a-zA-Z0-9\\s]+,?\"\n# match city names containing letters, but not spaces, followed by a comma\n# note that two word city names (like \"New York\") won't get matched\n# try to modify the regular expression to include two word city names\ncity_name_re = \" [a-zA-Z]+(\\,)?\"\n# to match US state abbreviations, match any two upper case alphabetic characters\n# notice that this overgenerates and accepts state names that don't exist because it doesn't check for a valid state name\nstate_abbrev_re = \" [A-Z]{2}\"\n# match US postal codes consisting of exactly 5 digits. 9 digit codes exist, but this expression doesn't match them\npostal_code_re = \" [0-9]{5}$\"\n# put the components together -- define the overall pattern\naddress_pattern_re = street_number_re + street_name_re + city_name_re + state_abbrev_re + postal_code_re\n# is this an address?\nis_match = re.match(address_pattern_re,text)\nif is_match is not None:\n    print(\"matches address_pattern\")\nelse:\n    print(\"doesn't match\")\n```", "```py\n# the address to match\ntext = \"223 5th Street NW, Plymouth, PA 19001\"\n# replace the whole expression with a class tag -- \"ADDRESS\"\naddress_class = re.sub(address_pattern_re,\"ADDRESS\",text)\nprint(address_class)\nADDRESS\n```", "```py\n# suppose we need to label a matched portion of the string\n# this function will label the matched string as an address\ndef add_address_label(address_obj):\n    labeled_address = add_label(\"address\",address_obj)\n    return(labeled_address)\n# this creates the desired format for the labeled output\ndef add_label(label, match_obj):\n    labeled_result = \"{\" + label + \":\" + \"'\" + match_obj.group() + \"'\" + \"}\"\n    return(labeled_result)\n# add labels to the string\naddress_label_result = re.sub(address_pattern_re,add_address_label,text)\nprint(address_label_result)\n```", "```py\n{address:'223 5th Street NW, Plymouth, PA 19001'}\n```", "```py\nimport nltk\nfrom nltk.corpus import wordnet as wn\nwn.synsets('vegetable')\n```", "```py\n[Synset('vegetable.n.01'), Synset('vegetable.n.02')]\nprint(wn.synset('vegetable.n.01').definition())\nprint(wn.synset('vegetable.n.02').definition())\n```", "```py\nedible seeds or roots or stems or leaves or bulbs or tubers or nonsweet fruits of any of numerous herbaceous plant\nany of various herbaceous plants cultivated for an edible part such as the fruit or the root of the beet or the leaf of spinach or the seeds of bean plants or the flower buds of broccoli or cauliflower\n```", "```py\nword_list = wn.synset('vegetable.n.01').hyponyms()\nsimple_names = []\nfor word in range (len(word_list)):\n    simple_name = word_list[word].lemma_names()[0]\n    simple_names.append(simple_name)\nprint(simple_names)\n['artichoke', 'artichoke_heart', 'asparagus', 'bamboo_shoot', 'cardoon', 'celery', 'cruciferous_vegetable', 'cucumber', 'fennel', 'greens', 'gumbo', 'julienne', 'leek', 'legume', 'mushroom', 'onion', 'pieplant', 'plantain', 'potherb', 'pumpkin', 'raw_vegetable', 'root_vegetable', 'solanaceous_vegetable', 'squash', 'truffle']\n```", "```py\ntext_frame = \"can you give me some good recipes for \"\nfor vegetable in range(len(simple_names)):\n    print(text_frame + simple_names[vegetable])\ncan you give me some good recipes for artichoke\ncan you give me some good recipes for artichoke_heart\ncan you give me some good recipes for asparagus\ncan you give me some good recipes for bamboo_shoot\n```", "```py\ngrammar = nltk.CFG.fromstring(\"\"\"\nS -> NP VP\nPP -> P NP\nNP -> Det N | Det N N |Det N PP | Pro\nPro -> 'I' |'you'|'we'\nVP -> V NP | VP PP\nDet -> 'an' | 'my' | 'the'\nN -> 'elephant' | 'pajamas' | 'movie' |'family' | 'room' |'children'\nV -> 'saw'|'watched'\nP -> 'in'\n\"\"\")\n```", "```py\n# we will need this to tokenize the input\nfrom nltk import word_tokenize\n# a package for visualizing parse trees\nimport svgling\n# to use svgling we need to disable NLTK's normal visualization functions\nsvgling.disable_nltk_png()\n# example sentence that can be parsed with the grammar we've defined\nsent = nltk.word_tokenize(\"the children watched the movie in the family room\")\n# create a chart parser based on the grammar above\nparser = nltk.ChartParser(grammar)\n# parse the sentence\ntrees = list(parser.parse(sent))\n# print a text-formatted parse tree\nprint(trees[0])\n# print an SVG formatted parse tree\ntrees[0]\n```", "```py\n(S\n  (NP (Det the) (N children))\n  (VP\n    (VP (V watched) (NP (Det the) (N movie)))\n    (PP (P in) (NP (Det the) (N family) (N room)))))\n```", "```py\nimport spacy\nfrom spacy.lang.en import English\nnlp = English()\nruler = nlp.add_pipe(\"entity_ruler\")\ncuisine_patterns = [\n    {\"label\": \"CUISINE\", \"pattern\": \"italian\"},\n    {\"label\": \"CUISINE\", \"pattern\": \"german\"},\n    {\"label\": \"CUISINE\", \"pattern\": \"chinese\"}]\nprice_range_patterns = [\n    {\"label\": \"PRICE_RANGE\", \"pattern\": \"inexpensive\"},\n    {\"label\": \"PRICE_RANGE\", \"pattern\": \"reasonably priced\"},\n    {\"label\": \"PRICE_RANGE\", \"pattern\": \"good value\"}]\natmosphere_patterns = [\n    {\"label\": \"ATMOSPHERE\", \"pattern\": \"casual\"},\n    {\"label\": \"ATMOSPHERE\", \"pattern\": \"nice\"},\n    {\"label\": \"ATMOSPHERE\", \"pattern\": \"cozy\"}]\nlocation_patterns = [\n    {\"label\": \"LOCATION\", \"pattern\": \"near here\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"walking distance\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"close by\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"a short drive\"}]\nruler.add_patterns(cuisine_patterns)\nruler.add_patterns(price_range_patterns)\nruler.add_patterns(atmosphere_patterns)\nruler.add_patterns(location_patterns)\ndoc = nlp(\"can you recommend a casual italian restaurant within walking distance\")\nprint([(ent.text, ent.label_) for ent in doc.ents])\n[('casual', 'ATMOSPHERE'), ('italian', 'CUISINE'), ('walking distance', 'LOCATION')]\n```", "```py\nfrom spacy import displacy\ncolors = {\"CUISINE\": \"#ea7e7e\",\n          \"PRICE_RANGE\": \"#baffc9\",\n          \"ATMOSPHERE\": \"#abcdef\",\n          \"LOCATION\": \"#ffffba\"}\noptions = {\"ents\": [\"CUISINE\",\"PRICE_RANGE\",\"ATMOSPHERE\",\"LOCATION\"], \"colors\": colors}\ndisplacy.render(doc, style=\"ent\", options=options,jupyter = True)\n```", "```py\nlocation_patterns = [\n    {\"label\": \"LOCATION\", \"pattern\": \"near here\", \"id\":\"nearby\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"close by\",\"id\":\"nearby\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"near me\",\"id\":\"nearby\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"walking distance\", \"id\":\"short_walk\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"short walk\", \"id\":\"short_walk\"},\n    {\"label\": \"LOCATION\", \"pattern\": \"a short drive\", \"id\":\"short_drive\"}]\n```", "```py\n[('casual', 'ATMOSPHERE', ''), ('italian', 'CUISINE', ''), ('close by', 'LOCATION', 'nearby')]\n```"]