- en: Making Magenta Interact with Music Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll see how Magenta fits into a broader picture by showing
    how to make it interact with other music applications such as **Digital Audio
    Workstations** (**DAWs**) and synthesizers. We'll explain how to send MIDI sequences
    from Magenta to FluidSynth and DAWs using the MIDI interface. By doing so, we'll
    learn how to handle MIDI ports on all platforms and how to loop MIDI sequences
    in Magenta. We'll show how to synchronize multiple applications using MIDI clocks
    and transport information. Finally, we'll cover Magenta Studio, a standalone packaging
    of Magenta based on Magenta.js that can also integrate into Ableton Live as a
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending MIDI to a DAW or synthesizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping the generated MIDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Magenta as a standalone application with Magenta Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll use the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: The **command line** or **Bash** to launch Magenta from the Terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python** and its libraries to write music generation code using Magenta'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magenta** to generate music in MIDI and synchronize with other applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mido** and other MIDI tools to send MIDI notes and clock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FluidSynth** to receive MIDI from Magenta'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **DAW** of your choice (Ableton Live, Bitwig, and so on) to receive MIDI from
    Magenta
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magenta Studio** as a standalone application or Ableton Live plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Magenta, we'll make the use of the **MIDI interface** to send MIDI sequences
    and MIDI clock to other music applications. We'll cover its usage in depth, but
    if you feel like you need more information, the Magenta MIDI interface, `README.md`,
    in the Magenta source code ([github.com/tensorflow/magenta/tree/master/magenta/interfaces/midi](https://github.com/tensorflow/magenta/tree/master/magenta/interfaces/midi))
    is a good place to start. You can also take a look at Magenta's code, which is
    well documented. We also provide additional content in the *Further reading* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also make the use of the **Magenta Studio** project on which you can find
    more information on its GitHub page at [github.com/tensorflow/magenta-studio](https://github.com/tensorflow/magenta-studio).
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is in this book's GitHub repository in `Chapter09` folder,
    located at [github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter09](https://github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter09).
    The examples and code snippets will assume you are located in this chapter's folder.
    For this chapter, you should go to `cd Chapter09` before you start. Check out
    the following video to see the Code in Action: [http://bit.ly/2RGkEaG](http://bit.ly/2RGkEaG).
  prefs: []
  type: TYPE_NORMAL
- en: Sending MIDI to a DAW or synthesizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the start of this book, we've been generating MIDI as physical files and
    then listening to them using either MuseScore or FluidSynth. This is a good way
    of composing music, generating new sequences, keeping the ones we like, and generating
    more based on them. But what if we'd like the MIDI notes to play continuously
    as the model generates them? This is a good way of making an autonomous music
    generation system, where Magenta is the composer, and an external program is a
    player, as it plays the notes it receives using instruments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll be looking at how to send MIDI from Magenta to synthesizers
    or DAWs. We'll also show how to loop the sequences that are generated in Magenta
    and how to synchronize our Magenta program with the application it is sending
    the sequences to.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing some DAWs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Producing music using a DAW has many advantages over simple synthesizers such
    as FluidSynth:'
  prefs: []
  type: TYPE_NORMAL
- en: Recording and **editing MIDI** sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and **editing audio**, either for the master track or single (instrument)
    track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our own **synthesizers** using oscillators, envelopes, filters, and
    so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **effects** such as reverb, delay, saturation, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying **EQ** and **mastering** to the audio tracks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutting, merging, and mixing **audio clips** to produce a whole track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many DAWs on the market, but unfortunately, not many of them are
    open source or free to use. We''ll give a small tour (which is not extensive by
    any means) of some DAWs that we think are interesting to use with Magenta:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ableton Live** ([www.ableton.com](https://www.ableton.com) – *not free*)
    is a well known product in the music industry and has been around for a long time.
    Ableton Live is one of the most complete DAWs on the market but is sold at a hefty
    price for all of the features. It works only on Windows and macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwig** ([www.bitwig.com](https://www.bitwig.com) – *not free*) is also
    a very complete product, similar to Ableton Live, and is a bit less pricey than
    its counterpart. It is a good DAW with many features and is available on all platforms,
    Windows, macOS, and Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason** ([www.reasonstudios.com/](https://www.reasonstudios.com/) – *not
    free*) is a DAW that focuses on instruments and effects rather than composition.
    It works really well when integrated with another software for the MIDI sequencing,
    such as Ableton Live or Magenta. It works only on Windows and macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cubase** ([new.steinberg.net/cubase/](https://new.steinberg.net/cubase/) –
    *not free*), from Steinberg, a renowned company making all sorts of audio software
    and hardware, is one of the oldest DAWs out there. It works only on Windows and
    macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cakewalk** ([www.bandlab.com/products/cakewalk](https://www.bandlab.com/products/cakewalk) –
    *free*) by Bandlab is a complete and easy-to-use DAW. This is the only non-open
    source DAW that is free to use. It works only on Windows, unfortunately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SuperCollider** ([supercollider.github.io/](https://supercollider.github.io/) –
    *free and open source*) is a platform for audio synthesis and algorithmic composition,
    enabling the development of synthesizers and effects using code, with a language
    called `sclang`. It works on all platforms and is open source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCV Rack** ([vcvrack.com/](https://vcvrack.com/) – *free and open source*)
    is a DAW that reproduces the joys of modular synthesis in software form. It works
    on all platforms and is open source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be giving our examples using Ableton Live, but all DAWs have similar features
    when it comes to receiving MIDI, so the examples should work well for all software.
    We'll highlight caveats when possible, such as handling MIDI routing on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at MIDI ports using Mido
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First things first, we need to find what MIDI ports are available on the machine,
    if any, to send MIDI messages between applications, such as Magenta to FluidSynth
    or a DAW. There is a great library called Mido, MIDI Objects for Python ([mido.readthedocs.io](https://mido.readthedocs.io)),
    that is really useful in finding MIDI ports, creating new ones, and sending data
    over.
  prefs: []
  type: TYPE_NORMAL
- en: Since Magenta has a dependency on Mido, it is already installed in our Magenta
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow this example in the `chapter_09_example_01.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the MIDI ports that are available on our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On Linux and macOS, one input port and one output port should already be present,
    as in the preceding output. On Windows, the list is either empty, because the
    OS doesn't create any virtual MIDI ports automatically, or contains only `Microsoft
    GS Wavetable Synth`, a MIDI synthesizer like FluidSynth.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how to create new ports for our applications to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual MIDI port on macOS and Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is nice about FluidSynth is that it opens a Virtual MIDI port automatically
    at launch. Unfortunately, it doesn't work on Windows, so we'll be looking at how
    to create Virtual MIDI ports works first.
  prefs: []
  type: TYPE_NORMAL
- en: A Virtual MIDI port is a MIDI port that can be created for **applications to
    send MIDI messages between them**. This is essential for all music production
    applications. For Magenta to send MIDI data to another program such as a DAW,
    we'll need to open a virtual port for them to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Like we saw in the previous example, Virtual MIDI ports are either **input**
    ports or **output** ports. That means we can create an input port named `magenta` and
    an output port named `magenta`. More often then not, it is clearer to use two
    different names when doing this, for example, `magenta_out` for the output port,
    and `magenta_in` for the input port. It is also simpler when mapping the ports
    in a DAW.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be choosing the port names from Magenta's perspective, meaning `magenta_out`
    is named as such because Magenta is sending information.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS and Linux, creating new virtual ports is easy, since Mido supports
    the RtMidi backend that can create them. Using `MidiHub` in Magenta, we can provide
    a string for each of the input and output, for the virtual port names we want
    to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create two virtual ports, `magenta_in` and `magenta_out`, if they
    don''t exist, or use the existing ones if they do. Using only Mido, we can use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that an input port has a `receive` method and an output port has a `send`
    method. When printing the ports, we should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The named virtual ports are now available, until restart, for applications to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: However, depending on the DAW, this might or might not work. For example, Bitwig
    in Linux doesn't work well with ALSA virtual ports, so opening one with RtMidi
    is not sufficient; you'll have to look at the documentation for a workaround using
    **JACK Audio Connection Kit** (**JACK**). Other DAWs on Linux, such as VCV Rack,
    will work properly and show the virtual ports.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual MIDI port on Windows using loopMIDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Windows, we can't create virtual ports using the code provided earlier. Fortunately,
    we have the **loopMIDI** software ([www.tobias-erichsen.de/software/loopmidi.html](https://www.tobias-erichsen.de/software/loopmidi.html)),
    a small and rather old program that is a godsend when using MIDI on Windows. The
    only thing it does is that it creates named virtual MIDI ports on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, launch the software and create two new ports named `magenta_in` and
    `magenta_out` using the name field at the bottom and the plus button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7c81c12-7fb1-405f-8035-9690b479f7d4.png)'
  prefs: []
  type: TYPE_IMG
- en: The virtual ports named `magenta_in` and `magenta_out` should now be available
    both for Ableton Live and Magenta to communicate. When creating a new port, **loopMIDI**
    always creates both the input port and the output port, meaning we can both send
    and receive MIDI from the `magenta_in` port. We'll be keeping both ports separate
    for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, if you have to the following error when launching the Magenta `MidiHub`,
    this is because you haven''t properly created or named your virtual ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the port name, `magenta_out 2`, also contains the port index, `2`. This
    is important when referring to ports in Windows, as they are named using the format:
    name index. This is kind of a pain because the port index might change if you
    create new ports (or plugin new MIDI devices) that shift the indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: To fix that issue, we make sure we filter the ports using string contains and
    not exact matching (all of our provided examples work properly in this matter).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a virtual MIDI port on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On macOS, we can either use the previous method described in the *Looking at
    virtual MIDI ports* section or use the built-in macOS interface to create a new
    virtual port. Using the built-in interface is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the **Audio MIDI Setup**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Window** menu and click on **Show MIDI Studio**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **IAC Driver** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the **Device is online** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then create named virtual ports using the **+** button.
  prefs: []
  type: TYPE_NORMAL
- en: Sending generated MIDI to FluidSynth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To send generated MIDI from Magenta to FluidSynth, we'll take one of the first
    examples we wrote in [Chapter 2](b60deee5-c58f-45eb-88a2-23718802e580.xhtml),
    *Generating Drum Sequences with the DrumsRNN*, and add some code to send the MIDI
    messages directly to the software synthesizer.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow this example in the `chapter_09_example_02.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to what we did in the previous chapter when we used the Web
    MIDI API to send MIDI notes to FluidSynth from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll start FluidSynth using one of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Linux: `fluidsynth -a pulseaudio -g 1 PATH_TO_SF2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS: `fluidsynth -a coreaudio -g 1 PATH_TO_SF2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: `fluidsynth -g 1 -o midi.winmidi.device=magenta_out PATH_TO_SF2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the `-o` flag in the Windows command, which tells FluidSynth to listen
    to this MIDI port because, on Windows, it doesn't open up a port automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice how we aren't using the `-n` and `-i` flags this time since we
    want to keep incoming MIDI messages and use the synth command line. The program
    should stop in the command-line interface and should have created a new input
    MIDI port automatically (or will use the provided one).
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, if you see the following error message upon starting FluidSynth:
    **fluidsynth: error: no MIDI in devices found** or **Failed to create the MIDI
    thread**, this means you either misspelled the MIDI port or didn''t open **loopMIDI**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS and Linux, you can run the previous example code again, you should
    see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `FLUID Synth (7171): Synth input port (7171:0) 129:0` port is the
    FluidSynth port. We also have the `magenta_out` and `magenta_in` ports from the
    previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, running the previous example code again should give you this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The FluidSynth input port that we'll use is the `magenta_out 3` port, which
    should match the `-o midi.winmidi.device=magenta_out` flag provided to FluidSynth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll copy the `chapter_02_example_01.py` example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We add a `--midi_port` flag to change the MIDI output port (remember the input
    and output terminology is from Magenta's perspective) easily for our examples.
    We'll be writing the code to send the MIDI content (which is in the `sequence`
    variable) at the end of the `generate` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We find the provided output port and initialize `MidiHub` using the port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We then start a new MIDI hub on that port; it will serve as a communication
    interface between our app and the synth. It is useful because it enables us to
    use `NoteSequence` objects directly without the need of converting them by hand.
  prefs: []
  type: TYPE_NORMAL
- en: The `midi_hub` module is located in Magenta in the `magenta.interfaces.midi`
    module and contains useful utilities for handling MIDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll get a player instance from the hub and set the playback channel
    to `9`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Remember that GM 1 compatible synthesizers will play the drums sound bank if
    the MIDI channel is `10` (but the channel is zero-indexed in Magenta MIDI hub
    so we have to use `9`). We'll be starting the playback on an empty sequence, allowing the
    update of the sequence later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can play our `sequence`, but we need to adjust it first so that the
    player knows when it starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The MIDI player will play `sequence` according to wall time, but our sequence
    starts at `0` (the wall time is the time since epoch). For example, if the wall
    time (which is given by `time.time()`) is `1564950205`, then we need to update
    the start of the sequence forward by that amount. We do that by keeping our current
    sequence intact and making a copy that will be given to the player. We use the
    `adjust_sequence_times` function from Magenta to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Notice here the usage of the `CopyFrom` method, which is present on Protobuf
    message objects. You can always go check the methods on the `google.protobuf.message.Message`
    class to find useful methods for `NoteSequence`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we adjusted our sequence to the proper time, let''s play it! We use
    the `update_sequence` method on the player to do this, which is the equivalent
    of `play`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We also give the `start_time` argument to the player `instance`, which is equal
    to the start of our adjusted (shifted forward) sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Since `player` is a thread, we need to wait for it to finish before exiting
    or the program will exit before the sequence has played. We do that by using the
    `join` method on the player instance, which is present on any thread class. That
    method will block until the thread finishes, but because the player thread never
    stops, this call will block indefinitely. By adding a timeout of `generation_end_time`,
    which is the length of the generated sequence, the call will return after the
    end of the sequence being played. A blocked join call can always be interrupted
    by pressing *Ctrl *+ *C*, which can be caught using the `KeyboardInterrupt` exception
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now launch the program by using the following on Linux and macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By keeping the default `--midi_port` flag, it will use the port started by FluidSynth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can use the `magenta_out` MIDI port on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now hear your music play from FluidSynth! When executing the code,
    you might see the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is because the MIDI hub can also receive a MIDI message, but we haven't
    provided any MIDI port to do so. This is only a warning and shouldn't be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Sending generated MIDI to a DAW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending MIDI to FluidSynth is nice, but you probably want to use another software
    for producing music. We won't be looking at every DAW, but we'll show examples
    that can be applied for most music production software.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Virtual MIDI ports opened for transferring MIDI from our Magenta
    application, let's try it out in Ableton Live. You can also try this in any other
    DAW that has MIDI functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Ableton Live set (with the `.als` file extension) in the `chapter_09_example_02.als` file
    in the source code of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this Ableton set along with the Python code we've shown in the previous
    example, `chapter_09_example_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure the `magenta_out` port in Ableton Live that will be also used
    by the Magenta app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in Ableton, go to **File** > **Options** > **Preferences...** > **Link**
    **MIDI** and find the `magenta_out` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ae7cc95-2305-4537-b10f-8c7b4f93b034.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to activate both **Track** and **Remote** to **On** to receive the MIDI
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the MIDI input is activated, we can create a new MIDI track by right-clicking
    in the **Drop Files and Devices Here** section and choosing **Insert MIDI track**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new track, we see the following **MIDI from** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d15f36d7-c478-42ea-8091-00dc5864132e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the screenshot, we highlighted three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The **MIDI From** section, which is available for a MIDI track, where we can
    now select the `magenta_out` MIDI port. We also selected **Ch. 10** for the drum
    channel 10 and **Monitor** to **In**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **third octave** on the 8-octave strip that represents all of the 127 possible
    MIDI values, where the **808 Core Kit** is defined. This corresponds to MIDI notes
    36 to 52 and you can see note 38 is currently playing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The currently playing note, the **Snare 808**, in the **808 Core Kit** instrument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the top-right corner, a yellow indicator shows whether there is incoming
    MIDI or not, which is useful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Ableton Live setup, we can launch our application by using
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You should receive MIDI in Ableton Live and hear the **808 Core Kit** play the
    percussion.
  prefs: []
  type: TYPE_NORMAL
- en: Using NSynth generated samples as instruments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous [Chapter 5](feb070b7-92ac-4762-a4ac-7c1a797a47ef.xhtml), *Audio
    Generation with NSynth and GANSynth*, we talked about using our generated samples
    by sequencing them using the generated MIDI from Magenta. Since we can now dynamically
    send the generated MIDI to a DAW, now is a good time to test this out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ableton Live, in the **808 Core Kit** section, we can drag and drop a generated
    sample to replace an existing drum kit sample. For example, we could change the
    **Cowbell 808** instrument with one of our samples, for example, `160045_412017`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fffb1961-7ba1-4d2e-8d16-7cfb417bc7f0.png)'
  prefs: []
  type: TYPE_IMG
- en: When double-clicking on the new sound, the sampler interface will open, which
    lets you modify the start and the end of the loop, as well as the volume. We choose
    that sample because it has a strong attack (the sound envelope goes up fast),
    which is perfect for a percussive sample. Go ahead and experiment with your own
    samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'When mapping drum sounds on channel 10, remember the percussion instrument
    is chosen according to the MIDI pitch note. In the previous figure, the 16 instruments
    in the grid are mapped to the MIDI pitches as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **48** | **49** | **50** | **51** |'
  prefs: []
  type: TYPE_TB
- en: '| **44** | **45** | **46** | **47** |'
  prefs: []
  type: TYPE_TB
- en: '| **40** | **41** | **42** | **43** |'
  prefs: []
  type: TYPE_TB
- en: '| **36** | **37** | **38** | **39** |'
  prefs: []
  type: TYPE_TB
- en: Here, pitch 36 corresponds to **Kick 808**, pitch 37 to **Rim 808**, pitch 51
    to our `160045_412017` sample, and so on. You can compare that grid with the MIDI
    plot that is outputted by our program (in `output/out.html`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well for drum elements. But if you are sending a melody to your
    DAW, you will want to use a sampler, which will change the pitch of the sound,
    depending on the incoming note. To do that, in Ableton Live, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new MIDI track by right-clicking in the **Drop Files and Devices Here** section
    and choosing **Insert MIDI track**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Sampler** instrument by choosing **Instruments** > **Sampler**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the **Sampler** in the **Drop Audio Effects Here** at the bottom
    (in the new MIDI track).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `412017_83249` generated sample (or another of your choice)
    in the **Drop Sample Here** at the bottom (in the **Sampler**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ve chosen the `412017_83249` generated sample since the cat sound makes
    a good (and funny) note when played as a melody. You should have the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96079478-eace-493b-8250-ca73b5c224e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now when you send a melody from your Magenta program, you will hear the sample,
    `412017_83249`, getting played and pitched up and down, following the melody notes
    pitch.
  prefs: []
  type: TYPE_NORMAL
- en: Looping the generated MIDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can send generated MIDI to a DAW, let's have a look at how to loop
    the generated MIDI. This opens up many different use cases, such as building a
    system that **generates music continuously**. We'll first have a look at how to
    loop `NoteSequence`. We'll also cover how to synchronize Magenta with a DAW using
    a MIDI clock, which is important in long-running live music systems.
  prefs: []
  type: TYPE_NORMAL
- en: Using the MIDI player to loop a sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be using the `player` instance from Magenta to loop a
    generated `NoteSequence`, by copying the sequence and playing it at a later time,
    before the player ends its playback.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow this example in the `chapter_09_example_03.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our previous example and make the sequence loop indefinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s find the period, which is equivalent to the loop time in seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we want a period (in seconds) of 4 bars, which is the loop length. Using
    240/QPM, we get the period for 1 bar (for example, 2 seconds at 120 QPM). We then
    multiply that by 4 bars (`num_bars + 1`), which is our loop length. Also, we are
    using the `Decimal` class, which doesn't have rounding errors like the built-in
    `float`, for increased accuracy for the timing.
  prefs: []
  type: TYPE_NORMAL
- en: We make use of the `Sleeper` class from Magenta, which implements a more precise
    version of `sleep` than the one present in the `time` module, so it should wake
    up more consistently with proper timing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now define the main loop, which will copy the current sequence, adjust
    it in time, and play it using the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break the code down a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: On each loop start, we get the current time since epoch (in `now`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get the current tick number, by dividing the current time by the period (in
    `tick_number`). The tick number corresponds to the current index in a separation
    of the time from epoch to now in intervals of `period`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get the current tick time by multiplying the period with the tick number
    (in `tick_time`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if the start time is `1577021349`, we have a ticking time of `1577021344`
    and a next tick time of `1577021352` (for a period of 8 seconds). In this case,
    we are on the first iteration of the loop, which is why there is such a big difference
    between the start time and the ticking time. On the second loop, the start time
    will be `1577021352` (approximately) because the thread will wake up with proper
    timing.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the start time difference on the first loop, this means that when
    the player starts, it might start in the middle of the generated sequence. If
    we want to make it start at the beginning of the sequence, we need to subtract
    the start time when calculating the tick number. See the `Metronome` class in
    the `magenta.interfaces.midi.midi_hub` module for a more complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the sequence and the player using `tick_time` and we sleep
    until `tick_time_next`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now launch the program by using this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You should now hear a 4-bar loop of 8 seconds at 120 QPM playing in the DAW
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing Magenta with a DAW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronizing devices when playing instruments is important. Two instruments
    that are in sync will have the **same QPM** (**tempo**) and start on the **same
    beat** (**phase**). Addressing those problems is simple on the surface, but good
    sync is hard to achieve because precise timing is difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing our Magenta application with a DAW has many usages, such as recording
    the MIDI sequences in a DAW with proper timing (tempo and phase), or playing multiple
    sequences at the same time, some coming from Magenta and the others coming from
    the DAW.
  prefs: []
  type: TYPE_NORMAL
- en: Sending MIDI clock and transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll synchronize Magenta with a DAW using a MIDI clock and
    transport (start, stop, and reset) information. The MIDI clock is one of the oldest
    and more popular ways of synchronizing devices, which is available for pretty
    much every instrument and music software.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be giving the example in Ableton Live, but you can also try this in any
    DAW that has MIDI clock functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow this example in the `chapter_09_example_04.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sync our Magenta program to Ableton Live, we''ll launch a metronome thread
    that wakes up on every beat and sends a clock message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s declare the `Metronome` class that extends the `Thread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At instantiation, we use Mido to define the following messages (see the last
    section, *Further reading*, for more documentation on the messages supported by
    Mido and to what they correspond in the MIDI specification):'
  prefs: []
  type: TYPE_NORMAL
- en: The `clock` message, which is sent every beat
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `start` message, which is sent when the sequence starts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stop` message, which is sent when the sequence ends, or when the program
    exits
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reset` message, which is sent before the start message, making sure that
    the synced device restarts from the beginning in terms of beat count
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `continue` message, which we won't use, but can be used to restart the playback
    without resetting the beat count
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also define the period, which is the exact time between each thread wake
    up. The thread needs to wake up at each beat, so in 4/4 time at 120 QPM, it needs
    to wake up every 0.5 seconds, which is the period.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we choose to synchronize both applications using one message (or pulse)
    per beat, which is our period, since it is easy to do. In the MIDI specification
    ([www.midi.org/specifications/item/table-1-summary-of-midi-message](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)),
    another synchronization period is described, which is called **24** **Pulses Per
    Quarter Note** (**24** **PPQN**), which is more precise than what we are implementing
    here.
  prefs: []
  type: TYPE_NORMAL
- en: One pulse per beat and 24 PPQN are both used in many DAWs and instruments. There
    are other synchronization pulses, however, such as 48 PPQN for Korg instruments.
    There are also other ways of synchronizing instruments, such as the **MIDI Time
    Code** (**MTC**), which we won't see here.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the software or hardware you are trying to sync, make sure to check
    what type of synchronization pulse they are configured to handle. If this doesn't
    work, it is probably because you are sending an unexpected pulse rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement the `run` method in the `# Run code` comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list further explains the code:'
  prefs: []
  type: TYPE_NORMAL
- en: When the thread first starts, it sends a `reset` message followed by a `start` message,
    meaning Ableton Live will reset its beat count to 0, and then start the playback.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we calculate the next tick time and make the thread sleep to that time
    (see the previous section explanation on the ticking time). At wake up, we send
    the `clock` message, which will happen at every beat.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the `stop` method is called, `self._stop_signal` is set to `True`,
    which will exit the loop, sending the `stop` message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s initialize the thread and launch it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list explains it further:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is similar to our previous example. The first thing we change is that
    we keep a reference to the `midi_hub._outport` port so that we can send the MIDI
    clock to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we initialize the `Metronome` class using `outport` and start it using
    `start`. This will execute the `run` method in the thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then `join` on the thread with a timeout of 16 (seconds), meaning we'll play
    8 bars before exiting and calling the `stop` method. We do this solely to show
    the stop usage and its impact on Ableton Live.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Ableton Live, we need to make sure that the **Sync** button is **On** for
    the `magenta_out` port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d0955ca-b0c0-416c-9548-9204dc051d27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve done that, we need to make sure that the **Ext** button on the
    top-left of the screen is activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8de26762-ee96-4ef3-b1d7-f2c8aaf269ae.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Ext** button, short for **External**, means that Ableton won't use its
    internal clock, but rather rely on an external source for the clock.
  prefs: []
  type: TYPE_NORMAL
- en: Most DAWs and hardware synths have a similar **External** option but this is
    often deactivated by default. Make sure to check how to activate that for the
    software or hardware you are trying to sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right of the **Ext** button, two indicators show incoming and outgoing
    MIDI clock messages, which is useful for debugging. We''ve also highlighted the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **QPM indicator**, which will get updated to 120 during playback (currently
    at 110 QPM for testing purpose)
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Arrangement position** section, that shows **9.1.1**, which is the value
    the beat count will be at when our Python program exists and sends the `stop` message
    (because we stop after 8 bars)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transport section** with the start, stop and record buttons, which will
    update when we start and stop the program
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now send the MIDI clock to Ableton Live.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s launch our Magenta application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In Ableton Live, you should see the BPM change to 120 QPM. It might take time
    to get there, and it might oscillate up and down while it stabilizes, but it should
    converge to 120 QPM. After 16 seconds, Ableton Live should stop, with a final
    beat count of 8 full beats (shown as **9.1.1**).
  prefs: []
  type: TYPE_NORMAL
- en: Using MIDI control message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending the MIDI clock is the most common way of synchronizing devices because
    all devices support the MIDI clock. Another way of synchronizing Magenta with
    a DAW would be to use **MIDI control messages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A MIDI control message is a message that sends `control` and `value`. For example,
    we could be using the following Mido message to send MIDI control: `mido.Message(type="control_change",
    control="...", value"...")`. Let''s define some control message for the actions
    we want to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start/stop**: This is to start and stop the transport, which will be used
    to synchronize the phase (using `control="1"` and `control="2"`, respectively).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QPM**: This is to set the tempo before the transport starts (using `control="3"`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just an example of control values; you can use whatever value you want,
    as long as it is properly mapped on the DAW side. In most DAWs, mapping a control
    message to input is easy. Often, a `learn` function is provided, which, once activated,
    will map the selected input in the DAW to whatever MIDI message comes next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this in Ableton Live:'
  prefs: []
  type: TYPE_NORMAL
- en: Activate the MIDI mapping mode using the **MIDI** button in the upper-right
    corner (all of the mappable inputs in Ableton will turn to purple).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the input you want to map (**QPM**, for example) and then send the corresponding
    MIDI control message (see the previous code snippet), which will map the input
    to the control message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the MIDI control message is received, the input in Ableton will be mapped
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the MIDI mapping mode, then send the same MIDI control message. The mapped
    input should activate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all of our inputs are mapped, we can send the corresponding messages from
    our Magenta application, to start, stop, and change the QPM when needed. For example,
    the Magenta application can send the QPM before starting, and then when sending
    the first MIDI note, send the MIDI control message **start** at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that if any of the two applications become
    desynced, there isn't any way of syncing the applications back together without
    stopping and restarting the playback. MIDI clock, on the other hand, is constantly
    syncing the devices together.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ableton Link to sync devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ableton Link ([github.com/Ableton/link](https://github.com/Ableton/link)) is
    an open source standard aimed at synchronizing software devices. It enables auto-discovery
    across a local network and is easy to use. A lot of DAWs now support Ableton Link,
    which is yet another way of syncing our Magenta application to a DAW but necessitates
    implementing the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Sending MIDI to a hardware synthesizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending MIDI to a hardware synthesizer is very similar to what we've been doing
    in the previous sections, with the exception that the hardware synthesizer should
    open a new MIDI port by itself (just like FluidSynth) so we don't need to create
    a virtual port for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using an Arturia BeatStep Pro for our example, but this should work
    with any MIDI-enabled device:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to install the drivers for the synthesizer, which might or might
    not be necessary, depending on the synth and the platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we connect the synthesizer using USB to the computer and run the first
    example to find what are the declared MIDI ports. For the Arturia BeatStep Pro
    on Windows, we have the output port, `MIDIIN2 (Arturia BeatStep Pro) 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can run our previous example, by changing the Magenta output port with
    the synthesizer input port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This should send the MIDI directly to the hardware synthesizer.
  prefs: []
  type: TYPE_NORMAL
- en: This example sends MIDI using USB MIDI, which is not available on all synthesizers.
    Some synthesizers only support MIDI using a MIDI cable, not a USB cable, which
    means you'll need a sound card or a USB to MIDI converter. The procedure is still
    the same, but you'll have to go through the sound card or the converter.
  prefs: []
  type: TYPE_NORMAL
- en: Using Magenta as a standalone application with Magenta Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magenta Studio is the closest you can get to a Magenta standalone application,
    in the sense that it doesn't require any installation and any knowledge of technologies
    to make it work. This is especially important, because Magenta and the technology
    that powers it is complex, but in the end, it is **important that everybody can
    use it**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be looking at how Magenta Studio works and find many elements we''ve
    already covered in the previous chapters. Magenta Studio comes in two packagings:'
  prefs: []
  type: TYPE_NORMAL
- en: As **Ableton Live Plugins** ([magenta.tensorflow.org/studio/ableton-live](https://magenta.tensorflow.org/studio/ableton-live)),
    which integrates Magenta into Ableton Live using the Max for Live integration
    and Magenta.js applications (supported on Windows and macOS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As **Standalone Applications** ([magenta.tensorflow.org/studio/standalone](https://magenta.tensorflow.org/studio/standalone)),
    which are Electron applications (supported on all platforms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't be talking about the standalone applications too much because we've
    already covered everything we need to know about them. Indeed, an Electron application
    is a Node.js application packaged with its runtime and a Chromium browser, so
    we've already covered that content in the previous [Chapter 8](cafc52b5-bd8c-41ba-a6f0-eb002405ffca.xhtml),
    *Magenta in the Browser with Magenta.js*.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Magenta Studio's content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since both packagings are based on Magenta.js, they both contain the same features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTINUE** makes use of MusicRNN (LSTM based), either the DrumsRNN model
    or the MelodyRNN model depending on the usage, to continue a sequence from a primer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GENERATE** makes use of the MusicVAE model, using a 4 bar model for the drums
    or the melody generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INTERPOLATE** also makes use of the MusicVAE model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GROOVE** makes the use of the GrooVAE model to add groove to a quantized
    sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DRUMIFY** uses the GrooVAE tap model to convert a **tap sequence** into a
    **drum sequence**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When downloading the standalone version, you''ll be able to install (using
    `.exe` or `.dmg` depending on the platform) any of the five applications. When
    installed and launched, the applications are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf8f39f5-7eb5-489b-9845-343216c956b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find many parameters we already talked about: temperature, length,
    variations (number of generated sequences), steps (number of interpolations),
    and so on. The difference between the standalone and the Ableton packaging is
    how they integrate with our music tool: the standalone application can work with
    files on disk (as shown in the previous screenshot, with the **Choose file...** button)
    and the Ableton Live plugin can directly read and write clips in the **Session
    View**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the Ableton Live Plugins integration.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Magenta Studio in Ableton Live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Magenta Studio plugin integration in Ableton Live is nice because it corresponds
    to the idea of a **machine learning augmented** music production environment.
    In general, the integration of Magenta in existing tools is important, and Magenta
    Studio is a good example of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to understand how the Ableton Live plugins are designed since
    it is quite clever. In Ableton Live, you can integrate a Max MSP application as
    a plugin or device. Max MSP ([cycling74.com/products/max-features/](https://cycling74.com/products/max-features/))
    is a powerful visual programming language for music. The Ableton Live Plugins
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ableton Live launches the `magenta.amxd` patch, which is a Max MSP program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Max MSP program shows a UI in Ableton Live, in which we can choose any of
    the **Continue**, **Generate**, and other programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When chosen, the Max MSP program will launch a Node.js process, containing the
    Magenta.js application (which is the same as the standalone application).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Max MSP API, the Magenta.js application can see the Ableton Live **Session
    View** content, including clips and tracks, and write content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, Magenta Studio integrates only in Ableton Live. Other DAWs might be
    integrated in the future, as Magenta Studio's implementation has nothing specific
    to Ableton Live.
  prefs: []
  type: TYPE_NORMAL
- en: For this example to work, we need Ableton Live 10.1 Suite since the integration
    of Max For Live (only in the **Suite** version) is necessary for Magenta Studio
    to work. You can try the demo at [www.ableton.com/en/trial/](https://www.ableton.com/en/trial/)
    if you don't have the program handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a complete example using the **Continue** application:'
  prefs: []
  type: TYPE_NORMAL
- en: From [magenta.tensorflow.org/studio/ableton-live](https://magenta.tensorflow.org/studio/ableton-live),
    download the Max MSP patch using the **Download** button for your platform, which
    should download the `magenta_studio-VERSION-windows.amxd` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Ableton Live, create a new MIDI track, and drag and drop the file in the
    MIDI track devices (it might take a while to load):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee302ade-3546-490e-a3c2-65c6c8223659.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, we see that we recorded two MIDI clips from our
    previous example, **MIDI from Magenta 1** and **MIDI from Magenta 2**, which we'll
    use to generate new content using the **Continue** plugin. We can see the Magenta
    Studio patch in the **Magenta Studio Plugin** track, which shows at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s click on **CONTINUE** in the Magenta Studio Plugin. You should
    see the **Continue** Node.js application start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dbd326a8-92fc-48b8-a9eb-bdb0f6310ccd.png)'
  prefs: []
  type: TYPE_IMG
- en: In the **Input Clip** section, we've added from the **MIDI from Magenta** track
    the **MIDI from Magenta 2** MIDI clip, which will be used by the DrumsRNN model
    for its primer. The four variations will be added automatically to Ableton Live
    after the primer clip, with the name `x/4 [MIDI from Magenta 2]`, with *x* being
    the index of the generated clip.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered the interaction of Magenta with established music
    production software.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have shown how to send MIDI from Magenta to DAWs or synthesizers.
    We started by looking at MIDI ports using Mido, a powerful Python library to handle
    MIDI operations. We've shown examples of how to loop MIDI in Magenta, which requires
    proper timing and threading tools. We also looked at synchronization between Magenta
    and a DAW using various methods, most notably using the MIDI clock messages and
    transport messages. We finished the MIDI section by showing how Magenta could
    send MIDI directly to hardware synthesizers, such as keyboards.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced Magenta Studio, both as a standalone application and
    as an Ableton Live plugin. We looked at its integration in Ableton Live and the
    importance of integrating Magenta in existing music tools.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Magenta's integration in a music production ecosystem is the perfect
    closing chapter. It reminds us that Magenta is not an end by itself, but rather
    a tool that needs to be used in conjunction with other music production tools
    to be truly useful. Magenta is becoming more usable by a broader, non-technical
    audience, by developing projects such as Magenta.js and Magenta Studio.
  prefs: []
  type: TYPE_NORMAL
- en: There is still a lot that can be done for Magenta to grow in terms of usability
    for everybody. This is, however, the start of a great music production tool.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a software synthesizer, such as FluidSynth, and
    a DAW, such as Ableton Live?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is opening MIDI virtual ports required to make music software interact with
    each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code based on `chapter_09_example_03.py` that, instead of looping
    the four bars sequence, generates a new sequence every four bars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is syncing based on the MIDI control message not robust?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is Magenta Studio such an important project in the music composition ecosystem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the technologies behind Magenta Studio Plugins and Magenta Studio Standalone?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Learn Live** (**Ableton Live**): Amazing tutorials on Ableton Live, which
    are far the best tutorials available on music production in general, with advanced
    content on many topics that can be used in many DAWs ([www.ableton.com/en/live/learn-live/](https://www.ableton.com/en/live/learn-live/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session View** (**Ableton Live**): More information on Ableton Live''s **Session
    View** which is a useful view for using Magenta Studio ([www.ableton.com/en/manual/session-view/](https://www.ableton.com/en/manual/session-view/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community Learning** (**Bitwig**): Good tutorials for Bitwig ([www.bitwig.com/en/community/learning.html](https://www.bitwig.com/en/community/learning.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tutorials** (**Reason**): Tutorials for Reason in the form of blog posts
    ([www.reasonstudios.com/blog/category/tutorials](https://www.reasonstudios.com/blog/category/tutorials))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getting Started With SC** (**SuperCollider**): The best way to get into SuperCollider
    and its programming language, `sclang`—the examples are also bundled with the
    software when downloaded ([doc.sccode.org/Tutorials/Getting-Started/00-Getting-Started-With-SC.html](http://doc.sccode.org/Tutorials/Getting-Started/00-Getting-Started-With-SC.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCV Rack Manual** (**VCV Rack**): VCV documentation along with the developer
    API if you want to write code for the software ([vcvrack.com/manual/](https://vcvrack.com/manual/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ports**: Mido documentation on Virtual MIDI ports differences between platforms
    ([mido.readthedocs.io/en/latest/ports.html](https://mido.readthedocs.io/en/latest/ports.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary of MIDI Messages**: List of MIDI messages, including the MIDI clock
    and transport message we''re using ([www.midi.org/specifications/item/table-1-summary-of-midi-message](https://www.midi.org/specifications/item/table-1-summary-of-midi-message))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Types**: Supported message types in Mido from the MIDI spec ([mido.readthedocs.io/en/latest/message_types.html](https://mido.readthedocs.io/en/latest/message_types.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magenta Studio**: Blog post from the Magenta team on Magenta Studio ([magenta.tensorflow.org/studio-announce](https://magenta.tensorflow.org/studio-announce))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
