<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-50"><span class="superscript"><a id="_idTextAnchor054"/></span>4</h1>
<h1 id="_idParaDest-51"><a id="_idTextAnchor055"/>Learning Jina’s Basics</h1>
<p>In the previous chapter, we learned about neural search, and now we can start thinking about how to work with it and the steps we’ll need to take to implement our own search engine. However, as we saw in previous chapters, in order to implement an end-to-end search solution, time and effort will be needed to gather all of the resources required. This is where Jina can help as it will take care of many of the necessary tasks, letting you focus on the design of your implementation. </p>
<p>In this chapter, you will understand the core concepts of Jina:<span class="superscript"> </span><strong class="bold">Documents</strong>, <strong class="bold">DocumentArrays</strong>, <strong class="bold">Executors</strong>, and <strong class="bold">Flow</strong>. You will see each of them in detail and understand their overall design and how they connect.</p>
<p>We’re going to cover the following main topics:</p>
<ul>
<li>Exploring Jina </li>
<li>Documents</li>
<li>DocumentArrays</li>
<li>Executors</li>
<li>Flow </li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of idioms in Jina, what they are, and how to use them. You will use this knowledge later to build your own search engine for any type of modality.</p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor056"/>Technical requirements</h1>
<p>This chapter has the following technical requirements:</p>
<ul>
<li>A laptop with a minimum of 4 GB of RAM, ideally 8 GB</li>
<li>Python 3.7, 3.8, or 3.9 installed on a Unix-like operating system, such as macOS or Ubuntu</li>
</ul>
<h1 id="_idParaDest-53"><a id="_idTextAnchor057"/>Exploring Jina</h1>
<p><strong class="bold">Jina</strong> is a<a id="_idIndexMarker271"/> framework that helps you build deep learning search systems on the cloud using state-of-the-art models. Jina is an infrastructure that allows you to focus only on the areas that you are interested in. In this way, you don’t need to be involved in every aspect of building a search engine. This involves everything from pre-processing your data to spinning up microservices if needed. Another good thing about neural search<a id="_idIndexMarker272"/> is that you can search for any kind of data regardless of type. Here are some examples of how you can<a id="_idIndexMarker273"/> search using different data types:</p>
<ul>
<li>Image-to-image search</li>
<li>Text-to-image search</li>
<li>Question answering search</li>
<li>Audio search</li>
</ul>
<p>Building your own search engine can be very time-consuming, so one of the core goals of Jina is reducing the time you would need if you were going to build one from scratch. Jina is designed in a layered way that lets you focus only on the specific parts that you need, letting the rest of the infrastructure be handled in the background. So, for example, you could use pre-trained <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) models directly instead of building them yourself. </p>
<p>Since we live in the era of cloud computing, it makes sense to leverage the power that decentralized work can offer, so it is useful to design your solution to be distributed on the cloud, and features such as <strong class="bold">sharding</strong>, <strong class="bold">asynchronizing</strong>, and <strong class="bold">REST</strong> are fully integrated and work out of the box.</p>
<p>As we have already said, another way that Jina helps you reduce the time and effort needed while building a search engine is by using the latest state-of-the-art ML models. You take advantage of this in one of two ways:</p>
<ul>
<li>Using one of Jina’s plug-and-play models </li>
<li>Developing your own model from scratch for when you have a specialized use case or if there is still no model available on Jina Hub</li>
</ul>
<p>With these options, you can choose between having a pre-defined model or implementing your own if your needs are not covered.</p>
<p>As you can imagine, all of this means that there are a lot of components working in the background. The more you learn, the more power you will have over your application, but to start, you will need to understand the basic components of Jina, which we will discuss in the following sections: </p>
<ul>
<li>Documents</li>
<li>DocumentArrays</li>
<li>Executors</li>
<li>Flows</li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor058"/>Documents</h1>
<p>In Jina, <strong class="bold">Documents</strong> are the <a id="_idIndexMarker274"/>most basic data type you can work with. They are the data you want to use and can be used for indexing and/or querying. They can be made with whatever data type you require, such as text, gifs, PDF files, 3D meshes, and so on. </p>
<p>We will use Documents to index and query, but since Documents can be of any type and size, it’s likely that we will need to divide them before use. </p>
<p>As an analogy, think of a Document as a chocolate bar. There are several types of chocolate: white, dark, milk, and so on. Likewise, a Document can be of several types, such as audio, text, video, a 3D mesh, and so on. Also, if we have a big chocolate bar, we will probably divide it into smaller pieces before eating it. Accordingly, if we have a big Document, we should divide it into smaller pieces before indexing.</p>
<p>This is how a Document looks in Python code: </p>
<pre class="source-code">from jina import Document
document = Document()</pre>
<p>As you can see, all you need to <a id="_idIndexMarker275"/>create a Document is to import it from Jina and create it as you would any other object in Python. This is a very basic example, but in real life, you will have more complex cases, so we will need to add some attributes, which we will see next.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor059"/>Document attributes</h2>
<p>Each Document can have different attributes that belong to four main categories:</p>
<ul>
<li><strong class="bold">Content</strong>: This<a id="_idIndexMarker276"/> refers to the actual content of your Document. For example, the text or its embedded vector.</li>
<li><strong class="bold">Meta</strong>: This is <a id="_idIndexMarker277"/>information about the Document itself. For example, its ID and whether it has any tags.</li>
<li><strong class="bold">Recursive</strong>: This<a id="_idIndexMarker278"/> tells us how the Document is divided. For example, its matches or if it was divided into any chunks.</li>
<li><strong class="bold">Relevance</strong>: This refers to the relevance<a id="_idIndexMarker279"/> of the Document, such as its score.</li>
</ul>
<p>These categories consist of various attributes, which are listed in the following table:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Category</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Attributes</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Content attributes</p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline" lang="en-US" xml:lang="en-US">.buffer</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.blob</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.text</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.uri</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.content</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.embedding</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Meta attributes</p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline" lang="en-US" xml:lang="en-US">.id</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.parent_id</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.weight</strong>, .<strong class="source-inline" lang="en-US" xml:lang="en-US">mime_type</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.content_type</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.tags</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.modality</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Recursive attributes</p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline" lang="en-US" xml:lang="en-US">.chunks</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.matches</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.granularity</strong>, <strong class="source-inline" lang="en-US" xml:lang="en-US">.adjacency</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Relevance attributes</p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">.score</strong>, <strong class="source-inline">.evaluations</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – Document categories and their attributes </p>
<p>We will see later in more detail what each of those attributes are, but first, let’s see how to set them. </p>
<h3>Setting and unsetting attributes </h3>
<p>The attributes in <em class="italic">Table 4.1</em> are the <a id="_idIndexMarker280"/>possible attributes we can use with our Document. Let’s say we want our Document to have the text <strong class="source-inline">hello world</strong>. We can do this by<a id="_idIndexMarker281"/> setting its <strong class="source-inline">text</strong> attribute like so:</p>
<pre class="source-code">from jina import Document
document = Document()
document.text = 'hello world'</pre>
<p>And if we want to unset it, we can do so as follows:</p>
<pre class="source-code">document.pop('text')</pre>
<p>In plenty of real-world cases, we will need to work with multiple attributes, and it is also possible to unset several of these at once:</p>
<pre class="source-code">document.pop('text', 'id', 'mime_type')</pre>
<h3>Accessing nested attributes from tags</h3>
<p>In Jina, each Document <a id="_idIndexMarker282"/>contains tags that hold a map-like structure that can map arbitrary values:</p>
<pre class="source-code">from jina import Document
document = Document(tags={'dimensions': {'height': 5.0, 'weight': 10.0}})
document.tags['dimensions'] # {'weight': 10.0, 'height': 5.0}</pre>
<p>If you want to access the nested fields, you can do so by using the attribute name with the symbol <strong class="source-inline">__</strong> interlaced. For example, if you would like to access the <strong class="source-inline">weight</strong> tag, you should do the following:</p>
<pre class="source-code">from jina import Document
document = Document(tags={'dimensions': {'height': 5.0, 'weight': 10.0}})
Document.tags__dimensions__weight #10</pre>
<h3>Constructing a Document </h3>
<p>To construct a Document, you need to fill it with attributes, so let’s take a look at them.</p>
<h3>Content attributes</h3>
<p>Each Document needs to<a id="_idIndexMarker283"/> contain some information about itself, ranging from raw binary content to text info. We can see the details that a Document can have in the following table:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Attribute</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.buffer</strong></p>
</td>
<td class="No-Table-Style">
<p>The raw binary content of the Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.blob</strong></p>
</td>
<td class="No-Table-Style">
<p>The ndarray of the image/audio/video Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.text</strong></p>
</td>
<td class="No-Table-Style">
<p>The text info of the Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.uri</strong></p>
</td>
<td class="No-Table-Style">
<p>A Document URI could be a local file path, a remote URL that starts with http or https, or a data URI scheme</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.content</strong></p>
</td>
<td class="No-Table-Style">
<p>This can be any of the previous attributes (buffer, blob, text, uri)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.embedding</strong></p>
</td>
<td class="No-Table-Style">
<p>The embedding ndarray of the Document</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2 - Content attributes</p>
<p>There are two ways you can assign a <em class="italic">content</em> type to your Document. If you know exactly what type it is, you can assign it explicitly with the <strong class="source-inline">text</strong>, <strong class="source-inline">blob</strong>, <strong class="source-inline">buffer</strong>, or <strong class="source-inline">uri</strong> attributes. If you don’t know the type, you can use <strong class="source-inline">.content</strong>, which will automatically assign a type to your Document based on what it’s most likely to be. See this, for example:</p>
<pre class="source-code">from jina import Document
import numpy as np
document1 = Document(content='hello world')
document2 = Document(content=b'\f1')
document3 = Document(content=np.array([1, 2, 3]))
document4 = Document(content=
'https://static.jina.ai/logo/core/notext/light/logo.png')</pre>
<p>In this example, the following applies:</p>
<ul>
<li><strong class="source-inline">document1</strong> will have a field of <strong class="source-inline">text</strong>.</li>
<li><strong class="source-inline">document2</strong> will have a field of <strong class="source-inline">buffer</strong>.</li>
<li><strong class="source-inline">document3</strong> will have a field of <strong class="source-inline">blob</strong>.</li>
<li><strong class="source-inline">document4</strong> will have a field of <strong class="source-inline">uri</strong>.</li>
</ul>
<p>The content <a id="_idIndexMarker284"/>will be automatically assigned to any one of the <strong class="source-inline">text</strong>, <strong class="source-inline">buffer</strong>, <strong class="source-inline">blob</strong>, or <strong class="source-inline">uri</strong> fields. The <strong class="source-inline">id</strong> and <strong class="source-inline">mime_type</strong> attributes are auto-generated when not set explicitly. This means that you can specify explicitly the ID and type (<strong class="source-inline">mime_type</strong>) of your document, otherwise it will be autogenerated. </p>
<h3>Exclusivity of doc.content</h3>
<p>In Jina, each Document <a id="_idIndexMarker285"/>can only contain one type of content: <strong class="source-inline">text</strong>, <strong class="source-inline">buffer</strong>, <strong class="source-inline">blob</strong>, or <strong class="source-inline">uri</strong>. Setting <strong class="source-inline">text</strong> first and then setting <strong class="source-inline">uri</strong> will clear the <strong class="source-inline">text</strong> field.</p>
<p>In the following figure, you can see the different types that content can have, as well as the fact that each Document can only have one type.</p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 4.1 – Possible content types in a Document " height="316" src="image/Figure_4.1_B17488.jpg" width="1246"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Possible content types in a Document</p>
<p>Let’s see<a id="_idIndexMarker286"/> how we would set the <strong class="source-inline">content</strong> attribute of a Document in code:</p>
<pre class="source-code">doc = Document(text='hello world')
doc.uri = 'https://jina.ai/' #text field is cleared, doc 
#has uri field now
assert not doc.text  # True
doc = Document(content='https://jina.ai')
assert doc.uri == 'https://jina.ai'  # True
assert not doc.text  # True
doc.text = 'hello world' #uri field is cleared, doc has 
#text field now
assert doc.content == 'hello world'  # True
assert not doc.uri  # True</pre>
<p>You can see how you can set every type of attribute in a Document, but if you assign different values to a single Document, only the last attribute will be valid. </p>
<h3>Conversion of doc.content</h3>
<p>Now that <a id="_idIndexMarker287"/>you’ve seen the different possible attributes in Jina, you might be thinking that sometimes it’d be useful to convert one type of <strong class="source-inline">doc.content</strong> to another. For example, if you had a Document and its path (<strong class="source-inline">uri</strong>), but you needed it in a text format, you could use one of these pre-made conversion functions to easily switch the content type:</p>
<pre class="source-code">doc.convert_buffer_to_blob()
doc.convert_blob_to_buffer()
doc.convert_uri_to_buffer()
doc.convert_buffer_to_uri()
doc.convert_text_to_uri()
doc.convert_uri_to_text()
doc.convert_image_buffer_to_blob()
doc.convert_image_blob_to_uri()
doc.convert_image_uri_to_blob()
doc.convert_image_datauri_to_blob()</pre>
<p>As you can see, all of these methods will help you transform your data from one type to another, but all of these types will need to be transformed into vector embeddings . Let’s see what exactly an embedding is and why we use them in neural search. </p>
<h3>Setting an embedding attribute</h3>
<p>An <a id="_idIndexMarker288"/>embedding is a high-dimensional representation of a Document, and it’s a key element in neural search. Embeddings are representations of your data in a vector format. This is why neural search can be used for any kind of data regardless of its type (image, audio, text, and so on). The data will be transformed into vectors (embeddings), and those vectors are the ones that will be used in neural search. Therefore, the type doesn’t matter as neural search ends up working only with vectors.</p>
<p>Since we are working with vectors, it is useful to work with already-established libraries that have extensive support for embeddings, such as NumPy, so you can, for example, assign any NumPy <strong class="source-inline">ndarray</strong> as a Document’s<a id="_idIndexMarker289"/> embedding and then use the flexibility that those libraries provide:</p>
<pre class="source-code">import numpy as np
from jina import Document
d1 = Document(embedding=np.array([1, 2, 3]))
d2 = Document(embedding=np.array([[1, 2, 3], [4, 5, 6]]))</pre>
<h3>Meta attributes</h3>
<p>Apart from <a id="_idIndexMarker290"/>content attributes, you can also have meta attributes:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Attribute</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.tags</strong></p>
</td>
<td class="No-Table-Style">
<p>Used to store the meta-information of the Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.id</strong></p>
</td>
<td class="No-Table-Style">
<p>A hexdigest that represents a unique Document ID</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.parent_id</strong></p>
</td>
<td class="No-Table-Style">
<p>A hexdigest that represents the Document’s parent ID</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.weight</strong></p>
</td>
<td class="No-Table-Style">
<p>The weight of the Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.mime_type</strong></p>
</td>
<td class="No-Table-Style">
<p>The mime type of the Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.content_type</strong></p>
</td>
<td class="No-Table-Style">
<p>The content type of the Document</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">doc.modality</strong></p>
</td>
<td class="No-Table-Style">
<p>An identifier of the modality of the Document such as an image, text, and so on</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3 – Meta attributes </p>
<p>To create your <a id="_idIndexMarker291"/>Document, you can assign multiple attributes in its constructor as shown here:</p>
<pre class="source-code">from jina import Document
document = Document(uri='https://jina.ai',
             mime_type='text/plain',
             granularity=1,
             adjacency=3,
             tags={'foo': 'bar'})</pre>
<h3>Constructing a Document from dictionary or a JSON string</h3>
<p>There’s also<a id="_idIndexMarker292"/> the option to construct your Document directly <a id="_idIndexMarker293"/>from a Python dictionary or JSON string. If you have the information of your Document already stored in those formats, you can conveniently create the Document using the following example:</p>
<pre class="source-code">from jina import Document
import json
doc = {'id': 'hello123', 'content': 'world'}
doc1 = Document(d)
doc = json.dumps({'id': 'hello123', 'content': 'world'})
doc2 = Document(d)</pre>
<h4>Parsing unrecognized fields</h4>
<p>If the fields in <a id="_idIndexMarker294"/>dictionary/a JSON string are not recognized, they are automatically put into the <strong class="source-inline">document.tags</strong> field. As shown in the following example, <strong class="source-inline">foo</strong> is not a defined attribute (<em class="italic">Table 4.3</em>), so it will be automatically parsed into the <strong class="source-inline">tags</strong> field:</p>
<pre class="source-code">from jina import Document
doc1 = Document({'id': 'hello123', 'foo': 'bar'})</pre>
<p>You can use <strong class="source-inline">field_resolver</strong> to map external field names to Document attributes:</p>
<pre class="source-code">from jina import Document
doc1 = Document({'id': 'hello123', 'foo': 'bar'}, 
field_resolver={'foo': 'content'})</pre>
<h4>Constructing a Document from other Documents</h4>
<p>In case you want<a id="_idIndexMarker295"/> to duplicate a Document, the following are ways to do so:</p>
<ul>
<li><strong class="bold">Shallow copy</strong>: Assigning a<a id="_idIndexMarker296"/> Document object to another Document object will make a shallow copy:<p class="source-code">from jina import Document</p><p class="source-code">doc = Document(content='hello, world!')</p><p class="source-code">doc1 = doc</p><p class="source-code">assert id(doc) == id(doc1)  # True</p></li>
<li><strong class="bold">Deep copy</strong>: To <a id="_idIndexMarker297"/>make a <a id="_idIndexMarker298"/>deep copy, use <strong class="source-inline">copy=True</strong>:<p class="source-code">doc1 = Document(doc, copy=True)</p><p class="source-code">assert id(doc) == id(doc1)  # False</p></li>
<li><strong class="bold">Partial copy</strong>: You can partially <a id="_idIndexMarker299"/>update a Document according to another source Document:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="" height="603" src="image/Figure_4.2_B17488.jpg" width="692"/>
</div>
</div>
<p>You can use any of the <a id="_idIndexMarker300"/>three preceding methods to copy a Document.</p>
<p>Constructing a Document from file types such as JSON, CSV, ndarray, and others</p>
<p>The <strong class="source-inline">jina.types.document.generators</strong> module lets you construct Documents from common file types such as <strong class="source-inline">JSON</strong>, <strong class="source-inline">CSV</strong>, <strong class="source-inline">ndarray</strong>, and text files. </p>
<p>The following functions will create a generator of Documents, where each <strong class="source-inline">Document</strong> object corresponds to a line/row in the original format:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Import Method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">from_ndjson()</strong></p>
</td>
<td class="No-Table-Style">
<p>This function yields a Document from a line-based JSON file. Each line is a Document object.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">from_csv()</strong></p>
</td>
<td class="No-Table-Style">
<p>This function yields a Document from a .csv file. Each line is a Document object.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">from_files()</strong></p>
</td>
<td class="No-Table-Style">
<p>This function yields a Document from a glob file. Each file is a Document object.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">from_ndarray()</strong></p>
</td>
<td class="No-Table-Style">
<p>This function yields a Document from an ndarray. Each row (depending on the axis) is a Document object.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">from_lines()</strong></p>
</td>
<td class="No-Table-Style">
<p>This function yields a Document from lines, of JSON, and CSV.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.4 – Python methods for constructing Documents</p>
<p>Using a generator is<a id="_idIndexMarker301"/> sometimes less memory-intensive, as it does not load/build all Document objects in one go.</p>
<p>Now you have learned what a Document is and how to create one. You can create it either by filling it with individual bits of content, or by copying from a JSON file if you already have one.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor060"/>DocumentArray</h1>
<p>Another powerful concept in Jina<a id="_idIndexMarker302"/> is the <strong class="bold">DocumentArray</strong>, which is a list of Document objects. If you need multiple Documents, you can group them all together in a list using DocumentArray. You can use a DocumentArray as a regular list in Python with all of the usual methods, such as <strong class="source-inline">insert</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">construct</strong>, <strong class="source-inline">traverse</strong>, and <strong class="source-inline">sort</strong>. The DocumentArray is a first-class citizen to an Executor, serving as its input and output. We will talk about Executors in the next section, but for now, think of them as the way Jina processes Documents.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor061"/>Constructing a DocumentArray</h2>
<p>You can <a id="_idIndexMarker303"/>construct, delete, insert, sort, and traverse a <strong class="source-inline">DocumentArray</strong> like a Python list. You can create these in different ways:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray([Document(), Document()])
from jina import DocumentArray, Document
documentarray = DocumentArray((Document() for _ in range(10))
from jina import DocumentArray, Document
documentarray1 = DocumentArray((Document() for _ in range(10)))
documentarray2 = DocumentArray(da)</pre>
<p>Just like a normal Document, the DocumentArray also supports different methods as follows:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table005">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Category</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Attributes</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Python list-like interface</p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">__getitem__</strong>, <strong class="source-inline">__setitem__</strong>,<strong class="source-inline"> __delitem__</strong>, <strong class="source-inline">__len__</strong>, <strong class="source-inline">insert</strong>, <strong class="source-inline">append</strong>, <strong class="source-inline">reverse</strong>, <strong class="source-inline">extend</strong>, <strong class="source-inline">__iadd__</strong>,<strong class="source-inline"> __add__</strong>, <strong class="source-inline">__iter__</strong>, <strong class="source-inline">clear</strong>, <strong class="source-inline">sort, shuffle</strong>, <strong class="source-inline">sample</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Persistence  </p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">save</strong>, <strong class="source-inline">load</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Neural search operations</p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">match</strong>, <strong class="source-inline">visualize</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Advanced getters  </p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">get_attributes</strong>,<strong class="source-inline"> get_attributes_with_docs</strong>,<strong class="source-inline"> traverse_flat</strong>, <strong class="source-inline">traverse</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.5 – DocumentArray attributes</p>
<h3>Persistence via save()/load()</h3>
<p>Of course, there <a id="_idIndexMarker304"/>will be cases where you want to save the elements of your DocumentArray for further processing, and you can save all elements in a DocumentArray in two ways:</p>
<ul>
<li>In JSON line format</li>
<li>In binary format</li>
</ul>
<p>To save it in JSON line format, you can do the following:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray([Document(), Document()])
documentarray.save('data.json')
documentarray1 = DocumentArray.load('data.json')</pre>
<p>And to store it in binary format, which is much faster and yields smaller files, you can do the following:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray([Document(), Document()])
documentarray.save('data.bin', file_format='binary')
documentarray1 = DocumentArray.load('data.bin', file_format='binary')</pre>
<h3>Basic operations</h3>
<p>Like with any <a id="_idIndexMarker305"/>other object, you can perform basic operations on a DocumentArray. This includes the following:</p>
<ul>
<li>Accessing elements</li>
<li>Sorting elements</li>
<li>Filtering elements</li>
</ul>
<p>Let’s learn about these in detail.</p>
<h4>Accessing elements</h4>
<p>You can access a <a id="_idIndexMarker306"/>Document in the DocumentArray via an index, ID, or slice indices, as shown here:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray([Document(id='hello'), 
Document(id='world'), Document(id='goodbye')])
documentarray[0]
# &lt;jina.types.document.Document id=hello at 5699749904&gt;
documentarray['world']
# &lt;jina.types.document.Document id=world at 5736614992&gt;
documentarray[1:2]
# &lt;jina.types.arrays.document.DocumentArray length=1 at 
# 5705863632&gt;</pre>
<p>Feel free to use to any variation of these options depending on your use case scenario. </p>
<h4>Sorting elements</h4>
<p>Because <strong class="source-inline">DocumentArray</strong> is a subclass of <strong class="source-inline">MutableSequence</strong>, you can use the built-in <a id="_idIndexMarker307"/>Python function <strong class="source-inline">sort</strong> to sort elements in a DocumentArray. For example, if you want to sort elements in-place (without making copies), and use the <strong class="source-inline">tags[id]</strong> value in a descending manner, you can do the following:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray(
    [
        Document(tags={'id': 1}),
        Document(tags={'id': 2}),
        Document(tags={'id': 3})
    ]
)
documentarray.sort(key=lambda d: d.tags['id'], 
reverse=True)
print(documentarray)</pre>
<p>The preceding code would print the following:</p>
<p class="source-code">&lt;jina.types.arrays.document.DocumentArray length=3 at 5701440528&gt;</p>
<p class="source-code"> </p>
<p class="source-code">{'id': '6a79982a-b6b0-11eb-8a66-1e008a366d49', 'tags': {'id': 3.0}},</p>
<p class="source-code">{'id': '6a799744-b6b0-11eb-8a66-1e008a366d49', 'tags': {'id': 2.0}},</p>
<p class="source-code">{'id': '6a799190-b6b0-11eb-8a66-1e008a366d49', 'tags': {'id': 1.0}}</p>
<h4>Filtering elements</h4>
<p>You can use<a id="_idIndexMarker308"/> Python’s built-in <strong class="source-inline">filter</strong> function to filter elements in a <strong class="source-inline">DocumentArray</strong> object:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray([Document() for _ in range(6)])
for j in range(6):
    documentarray[j].scores['metric'] = j
for d in filter(lambda d: d.scores['metric'].value &gt; 2, documentarray):
    print(d)</pre>
<p>This would print the following:</p>
<p class="source-code">{'id': 'b5fa4871-cdf1-11eb-be5d-e86a64801cb1', 'scores': {'values': {'metric': {'value': 3.0}}}}</p>
<p class="source-code">{'id': 'b5fa4872-cdf1-11eb-be5d-e86a64801cb1', 'scores': {'values': {'metric': {'value': 4.0}}}}</p>
<p class="source-code">{'id': 'b5fa4873-cdf1-11eb-be5d-e86a64801cb1', 'scores': {'values': {'metric': {'value': 5.0}}}}</p>
<p>You can also build a <strong class="source-inline">DocumentArray</strong> object from the filtered results as follows:</p>
<pre class="source-code">from jina import DocumentArray, Document
documentarray = DocumentArray([Document(weight=j) for j in range(6)])
documentarray2 = DocumentArray(d for d in documentarray if d.weight &gt; 2)
print(documentarray2)</pre>
<p>This would<a id="_idIndexMarker309"/> print the following result:</p>
<p class="source-code">DocumentArray has 3 items:</p>
<p class="source-code">{'id': '3bd0d298-b6da-11eb-b431-1e008a366d49', 'weight': 3.0},</p>
<p class="source-code">{'id': '3bd0d324-b6da-11eb-b431-1e008a366d49', 'weight': 4.0},</p>
<p class="source-code">{'id': '3bd0d392-b6da-11eb-b431-1e008a366d49', 'weight': 5.0}</p>
<p>At this point, you have learned how to create Documents and DocumentArrays that store multiple Documents as a list. But what can you actually do with these? How can you process them for use in neural search? This is where Executors come into the picture. Let’s talk about them in the following section. </p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor062"/>Executors</h1>
<p>The <strong class="bold">Executor</strong> represents <a id="_idIndexMarker310"/>the processing component in a Jina Flow. It performs a single task on a Document or DocumentArray. You can think of an Executor as the logical part of Jina. Executors are the ones that will perform tasks of all kinds on a Document. For example, you could have an Executor for extracting text from a PDF file, or for encoding audio for your Document. They handle all of the algorithmic tasks in Jina.</p>
<p>Since Executors are one of the main parts of Jina, and they are the ones that perform all the algorithmic tasks, it would be very useful for you to make them in a way that means they could be easily shared with other people, so that others can re-use your work. Similarly, you could use prebuilt Executors made by someone else in your own code. This is in fact possible because Executors are easily available in a marketplace, which in Jina is called<a id="_idIndexMarker311"/> Jina Hub (<a href="https://hub.jina.ai/">https://hub.jina.ai/</a>). There you can browse between various Executors that solve different tasks, and you can just select the one that is useful to you and use it in your code. Of course, it’s possible that the Executor for the task you need to do has not already been built in Jina Hub, in which case you’ll need to create your own Executor. You can do this easily in Jina Hub. Let’s take a deep dive into how to do that. </p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor063"/>Creating an Executor</h2>
<p>To create an<a id="_idIndexMarker312"/> Executor, it’s best to use Jina Hub, which will generate a wizard to guide you through the process. To start this process, open a console and write the following command:</p>
<p class="source-code">jina hub new</p>
<p>This will trigger a wizard that will guide you through the creation of the Executor and ask you for some details about it:</p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 4.3 – Creating an Executor via the CLI " height="765" src="image/Figure_4.3_B17488.jpg" width="1219"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Creating an Executor via the CLI</p>
<p>After going through<a id="_idIndexMarker313"/> the wizard, your Executor will be ready. Now, let’s learn about Executors in more detail.</p>
<p>Executors process DocumentArrays in-place via functions decorated with <strong class="source-inline">@requests</strong>. We add this decorator to whatever functions we want in our Executors. When creating an Executor, three principles should be kept in mind:</p>
<ul>
<li>It should be a subclass of the <strong class="source-inline">jina.Executor</strong> class.</li>
<li>It must be a bag-of-functions with the state <strong class="source-inline">shared</strong>. It can contain an arbitrary number of functions with arbitrary names.</li>
<li>Functions decorated by <strong class="source-inline">@requests</strong> will be invoked according to their <strong class="source-inline">on= endpoint</strong>. We will see different cases of what those endpoints could be in the following example.</li>
</ul>
<p>Here is a very basic Executor in Python to help you understand this last concept better:</p>
<pre class="source-code">from jina import Executor, requests
class MyExecutor(Executor):
    @requests
    def foo(self, **kwargs):
        print(kwargs)</pre>
<p>The name of your<a id="_idIndexMarker314"/> Executor can be whatever you wish, but the important thing to remember is that every new Executor should be a subclass of <strong class="source-inline">jina.Executor</strong>. </p>
<h4>Constructor</h4>
<p>You don’t need to<a id="_idIndexMarker315"/> implement the constructor (<strong class="source-inline">__init__</strong>) if your Executor does not contain initial states, but if your Executor has <strong class="source-inline">__init__</strong>, it needs to carry <strong class="source-inline">**kwargs</strong> in the signature and call <strong class="source-inline">super().__init__(**kwargs)</strong> into the body:</p>
<pre class="source-code">from jina import Executor
class MyExecutor(Executor):
    def __init__(self, foo: str, bar: int, **kwargs):
        super().__init__(**kwargs)
        self.bar = bar
        self.foo = foo</pre>
<h4>Method decorator</h4>
<p>The <strong class="source-inline">@requests</strong> decorator defines <a id="_idIndexMarker316"/>when a function will be invoked. It has the <strong class="source-inline">on=</strong> keyword, which defines the endpoint. We haven’t talked about Flow yet. We will do so in the next section, but for now, think of Flow as a manager. The <strong class="source-inline">@requests</strong> decorator sends information to Flow whenever our Executor needs to be called. This is to communicate to Flow when the function will be called and at which endpoint.</p>
<p>You can use the <a id="_idIndexMarker317"/>decorator like this:</p>
<pre class="source-code">from jina import Executor, Flow, Document, requests
class MyExecutor(Executor):
    @requests(on='/index')
    def foo(self, **kwargs):
        print(f'foo is called: {kwargs}')
    @requests(on='/random_work')
    def bar(self, **kwargs):
        print(f'bar is called: {kwargs}')
f = Flow().add(uses=MyExecutor)
with f:
    f.post(on='/index', inputs=Document(text='index'))
    f.post(on='/random_work', 
    inputs=Document(text='random_work'))
    f.post(on='/blah', inputs=Document(text='blah')) </pre>
<p>In this example, we have three endpoints:</p>
<ul>
<li><strong class="source-inline">on='/index'</strong>: This endpoint will trigger the <strong class="source-inline">MyExecutor.foo</strong> method.<strong class="source-inline"> </strong></li>
<li><strong class="source-inline">on='/random_work'</strong>: This endpoint will trigger the <strong class="source-inline">MyExecutor.bar</strong> method.</li>
<li><strong class="source-inline">on='/blah':</strong> This endpoint will not trigger any methods, as no function is bound to <strong class="source-inline">MyExecutor.blah</strong>.</li>
</ul>
<h4>Executor binding</h4>
<p>Now that we have seen<a id="_idIndexMarker318"/> how to create Executors and learned about the <strong class="source-inline">@requests</strong> decorator, you might be wondering what types of binding you can use with <strong class="source-inline">@requests</strong>.</p>
<h4>Default binding</h4>
<p>A class method <a id="_idIndexMarker319"/>decorated with plain <strong class="source-inline">@requests</strong> is the default handler for all endpoints. This means that it is the fallback handler for endpoints that are not found. Let’s see one example: </p>
<pre class="source-code">from jina import Executor, requests
class MyExecutor(Executor):
    @requests
    def foo(self, **kwargs):
        print(kwargs)
 
    @requests(on='/index')
    def bar(self, **kwargs):
        print(kwargs)</pre>
<p>In this example, two functions were defined:</p>
<ul>
<li><strong class="source-inline">foo</strong></li>
<li><strong class="source-inline">bar</strong></li>
</ul>
<p>Here the <strong class="source-inline">foo</strong> function becomes the default method since it has no <strong class="source-inline">on=</strong> keyword. If we were now to use an unknown endpoint, such as <strong class="source-inline">f.post(on='/blah', ...)</strong>, it would invoke <strong class="source-inline">MyExecutor.foo</strong> since there is no <strong class="source-inline">on='/blah'</strong> endpoint. </p>
<h4>Multiple bindings</h4>
<p>To bind a method with <a id="_idIndexMarker320"/>multiple endpoints, you can use <strong class="source-inline">@requests(on=['/foo', '/bar'])</strong>. This allows either<strong class="source-inline"> f.post(on='/foo', ...)</strong> or <strong class="source-inline">f.post(on='/bar', ...)</strong> to invoke the function.</p>
<h4>No binding</h4>
<p>A class <a id="_idIndexMarker321"/>with no <strong class="source-inline">@requests</strong> binding plays no part in the a Flow. The request will simply pass through without any processing.</p>
<p>Now you know what an Executor is and why it is useful to share them with other developers. You have also learned where to find already-published Executors and how to publish your own. Let’s see now how to put together the concepts you’ve learned so far.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor064"/>Flow</h1>
<p>Now that you <a id="_idIndexMarker322"/>know what Documents and Executors are and how to work with them, we can start to talk about <strong class="bold">Flow</strong>, one of the most important concepts in Jina. </p>
<p>Think of Flow as a manager in Jina; it takes care of all the tasks that will run on your application and will use Documents as its input and output.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor065"/>Creating a Flow</h2>
<p>The creation of a<a id="_idIndexMarker323"/> Flow in Jina is very easy and works just like any other object in Python. For example, this is how you would create an empty Flow:</p>
<pre class="source-code">from jina import Flow
f = Flow()</pre>
<p>In order to use a Flow, it’s best to always open it as a context manager, just like you would open a file in Python, by using the <strong class="source-inline">with</strong> function:</p>
<pre class="source-code">from jina import Flow
f = Flow()
with f:     
f.block()</pre>
<p class="callout-heading">Note</p>
<p class="callout">Flow follows a lazy construction pattern: it won’t actually run unless you use the <strong class="source-inline">with</strong> function to open it.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor066"/>Adding Executors to a Flow</h2>
<p>To add<a id="_idIndexMarker324"/> elements to your Flow, all you need to do is use the <strong class="source-inline">.add()</strong> method. You<a id="_idIndexMarker325"/> can add as many elements as you wish.</p>
<p>The <strong class="source-inline">.add()</strong> method is used to add an Executor to a Flow object. Each <strong class="source-inline">.add()</strong> instance adds a new Executor, and these Executors can be run as a local thread, local process, remote process, inside a Docker container, or even inside a remote Docker container. You can add as many as you need like this:</p>
<pre class="source-code">from jina import Flow
flow = Flow().add().add()</pre>
<h3>Defining an Executor via uses</h3>
<p>You<a id="_idIndexMarker326"/> can use the <strong class="source-inline">uses</strong> parameter to specify the<a id="_idIndexMarker327"/> Executor that you are using. The <strong class="source-inline">uses</strong> parameter accepts multiple value types including class names, Docker images, and (inline) YAML. Therefore, you can add an Executor via this:</p>
<pre class="source-code">from jina import Flow, Executor
class MyExecutor(Executor):
    ...
f = Flow().add(uses=MyExecutor)</pre>
<h3>Visualizing a Flow</h3>
<p>If you want to <a id="_idIndexMarker328"/>visualize your Flow, you can do so with the<strong class="source-inline">.plot()</strong> function. This will create a <strong class="source-inline">.svg</strong> file with the visualized Flow. To do this, add the <strong class="source-inline">.plot()</strong> function at the end of your Flow and use the intended title of your <strong class="source-inline">.svg</strong> file:</p>
<pre class="source-code">from jina import Flow
f = Flow().add().plot('f.svg')</pre>
<p>The preceding snippet will produce the following figure with the corresponding Flow:</p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 4.4 – Example of a Flow " height="159" src="image/Figure_4.4_B17488.jpg" width="1040"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Example of a Flow</p>
<p class="callout-heading">Note</p>
<p class="callout">In Jupyter Lab/Notebook, the Flow object is rendered automatically without needing to call <strong class="source-inline">.plot()</strong>.</p>
<p>You can also use CRUD methods (index, search, update, delete), which are just sugary syntax forms of post with <strong class="source-inline">on='/index', on='/search'</strong>. These are laid out in the following list:</p>
<ul>
<li><strong class="source-inline">index = partialmethod(post, '/index')</strong></li>
<li><strong class="source-inline">search = partialmethod(post, '/search')</strong></li>
<li><strong class="source-inline">update = partialmethod(post, '/update')</strong></li>
<li><strong class="source-inline">delete = partialmethod(post, '/delete')</strong></li>
</ul>
<p>So, taking the<a id="_idIndexMarker329"/> previous concepts together, a minimal working example requires the creation of an Executor that extends from the base Executor class and can be used together with your Flow:</p>
<pre class="source-code">from jina import Flow, Document, Executor, requests  
class MyExecutor(Executor):      
@requests(on='/bar')
 def foo(self, docs, **kwargs):
    print(docs) 
f = Flow().add(name='myexec1', uses=MyExecutor) 
with f:     
f.post(on='/bar', inputs=Document(), on_done=print)</pre>
<p>That’s it! You now have a <a id="_idIndexMarker330"/>minimal working example and have covered the basics of Jina. We’ll see more advanced uses in the next chapters, but if you’ve learned the Document, DocumentArray, Executor, and Flow concepts, you are good to go.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor067"/>Summary</h1>
<p>This chapter introduced the main concepts in Jina: Document, DocumentArray, Flow, and Executor. You should now have an overview of what each of those concepts are, why they are important, and how they relate to each other.</p>
<p>Besides understanding the theory of why Document, DocumentArray, Flow, and Executor are important while building your search engine, you should also be able to create a simple Document and assign its corresponding attributes.  As you are done with this chapter, you should also be able to create your own Executor and spin up a basic Flow. </p>
<p>You will use all of this knowledge in the next chapter, where you will learn how to integrate these concepts together.</p>
</div>
<div>
<div id="_idContainer052">
</div>
</div>
</div>
</body></html>