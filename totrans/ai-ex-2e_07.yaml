- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Blockchains with Naive Bayes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this three-part chapter, we will use blockchains to optimize a supply chain
    using naive Bayes. To achieve this goal, we will first start by understanding
    how a blockchain is generated using cryptocurrency as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains have entered corporations and are here to stay. Hundreds of major
    corporations have implemented IBM Hyperledger. Suppliers of these corporations
    will gradually join the network. Corporate blockchains will provide work for many
    years to come thanks to the millions of lines of code to update with new features
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Mining cryptocurrency represents the most known use of blockchains. Cryptocurrencies
    are growing around the world. This chapter starts by explaining how the mining
    aspect of blockchains works, using bitcoins as an example.
  prefs: []
  type: TYPE_NORMAL
- en: We will then move on and analyze how to use blockchains for a different purpose
    than generating cryptocurrency. Corporations use blockchains to record transactions
    between companies, for example.
  prefs: []
  type: TYPE_NORMAL
- en: IBM was founded in 1911, making it the most experienced company in its field
    today. Google, Amazon, and Microsoft also offer history-making machine learning
    platforms. However, IBM offers machine learning platforms that are supported by
    the 100+ years of experience that the company can bring to bear.
  prefs: []
  type: TYPE_NORMAL
- en: Some of IBM's many years in the computer and software market were bumpy. Some
    terrible decisions caused the company a lot of problems across the world. IBM
    learned from those mistakes and now offers robust solutions, including IBM Hyperledger
    for blockchain solutions. IBM advocates using blockchains for corporate transactions.
  prefs: []
  type: TYPE_NORMAL
- en: We will finally move to the third part of this chapter, which explains what
    blockchains mean for companies around the world and how to use the information
    blockchains to provide optimizing algorithms with artificial intelligence. Naive
    Bayes will be applied to a blockchain sample to optimize stock levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The background of blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blockchains to mine bitcoins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blockchains for business transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the blocks of a blockchain provide a unique way to share information between
    companies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying artificial intelligence to the blocks of a blockchain to predict and
    suggest transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naive Bayes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use naive Bayes on blocks of a blockchain to predict further transactions
    and blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with a short introduction to blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Part I – the background to blockchain technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through cryptocurrency mining with blockchains.
    Producing bitcoins with blockchains made the technology disruptive. The purpose
    of this section is to understand how the blockchain adventure started before moving
    on to subsequent uses of blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology will transform transactions in every field. Blockchains
    appeared in 2008\. Nobody knows for sure who invented them. Each block contains
    an encrypted hash of its predecessor (previous block), the DateTime (timestamp)
    data, and the information regarding the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: For more than 1,000 years, transactions have been mostly local book-keeping
    systems. For the past 100 years, even though the computer age changed the way
    information was managed, things did not change that much. Each company continued
    to keep its transactions to itself, only sharing some information through tedious
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain** makes a transaction **block** visible to the global network
    it has been generated in.'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental concepts to keep in mind are **sharing** and **privacy control**.
    The two ideas seem to create a cognitive dissonance, something impossible to solve.
    Yet it has been solved, and it will change the world.
  prefs: []
  type: TYPE_NORMAL
- en: When a block (a transaction of any kind) is generated, it is shared with the
    entire network. Permissions to read the information within that block remain manageable
    and thus private if the regulator of that block wants the information to stay
    private.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the goal is to mine bitcoins through blocks or use blocks for transactions,
    artificial intelligence will enhance this innovation shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we'll talk about blockchain and its applications in
    some further detail. Understanding how to produce blocks for cryptocurrency will
    enable us to grasp blockchain technology. Once we understand blockchain technology,
    it is easier to see how this secure encrypted method can be applied to any type
    of business transaction beyond cryptocurrencies. Let's go mining first!
  prefs: []
  type: TYPE_NORMAL
- en: Mining bitcoins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a block in a blockchain does not necessarily have to generate a bitcoin,
    which is a form of transaction like any other. But understanding how to mine cryptocurrency
    provides a good way to understand blockchains and how to apply them to many other
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mining a bitcoin means creating a mathematical block for a valid transaction
    and adding this block to the chain; the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Blockchain* = {*block*[1], *block*[2], *the block just added* … *block*[n]}'
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain cannot go back in time. It is like a time-dating feature in life.
    At minute *m*, you do something, at minute *m* + 1 something else, at minute *m*
    + *n* something else, and so on. You cannot travel back in time. *What is done
    is done*.
  prefs: []
  type: TYPE_NORMAL
- en: When a block is added to the bitcoin chain, there is no way of undoing the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The global network of bitcoin mining consists of **nodes**. With the appropriate
    software, you leave a port open, allocate around 150+ GB of disk space, and generate
    new blocks. The nodes communicate with each other, and the information is relayed
    to the other nodes around the whole network.
  prefs: []
  type: TYPE_NORMAL
- en: For a node to be a miner, it must solve complex mathematical puzzles that are
    part of the bitcoin program.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the puzzle, the software must find a number that fits in a specific
    range when combined with the data in the block being generated. The number is
    passed through a hash function.
  prefs: []
  type: TYPE_NORMAL
- en: You can call the number a **nonce**, and it is used only once. For example,
    an integer between 0 and 4,294,967,296 for a bitcoin must be generated.
  prefs: []
  type: TYPE_NORMAL
- en: The process is random. The software generates a number, passes it through the
    hash function, and sends it out to the network. The first **miner** who produces
    a number in the expected range informs the whole network that that particular
    block has been generated. The rest of the network stops working on that block
    and moves on to another one.
  prefs: []
  type: TYPE_NORMAL
- en: The reward for the miner is naturally paid out in bitcoins. It represents a
    lot of money, but it's hard to get, considering the competition in the network
    and the cost required (CPU, electricity, disk space, and time) to produce correct
    results.
  prefs: []
  type: TYPE_NORMAL
- en: A constant balance must be maintained between the cost of mining a bitcoin,
    or any other cryptocurrency, and the amount received for mining it.
  prefs: []
  type: TYPE_NORMAL
- en: Having talked about mining bitcoin, we'll briefly discuss actually using cryptocurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Using cryptocurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be very careful with cryptocurrency. There are now 1,500+ cryptocurrencies.
    The concept sounds fascinating, but the result remains currency. Currency can
    be volatile, and you can lose your life's savings in less than an hour if a crash
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Golden rule**: If you cannot resist investing in cryptocurrencies, do not
    invest more than you can afford to lose.'
  prefs: []
  type: TYPE_NORMAL
- en: That being said, to use cryptocurrency, first set up a wallet to store your
    bitcoins, for example. The wallet can be online, through a provider, or even offline.
  prefs: []
  type: TYPE_NORMAL
- en: Once that is done, you will be able to purchase bitcoins as you wish in hard
    cash or using credit cards, debit cards, and transfers.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you are buying these currencies like any other currency with all the
    potential, but also all the risks involved.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how the blockchain era began with bitcoin production
    to understand how to mine cryptocurrencies through bitcoins using a blockchain.
    With the original way blockchains are created in mind, we can apply blockchains
    to many other fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of our three-part chapter, we will see how to use blockchains
    beyond cryptocurrencies. We will apply them to supply chains.
  prefs: []
  type: TYPE_NORMAL
- en: PART II – using blockchains to share information in a supply chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part I – the background to blockchain technology*, we saw how to use blockchains
    to mine cryptocurrencies. That prerequisite to entering the world of blockchains
    having been achieved, this section will show how to use blockchains in a supply
    chain. This will not involve cryptocurrencies. It opens the path to innovating
    blockchains with AI.
  prefs: []
  type: TYPE_NORMAL
- en: 'A supply chain is a chain of production and service that gets a product from
    a starting point to the consumer. For example, take a roll of fabric (cloth) that
    is shipped from India to Tunisia. In Tunisia, the fabric is cut into patterns
    and assembled as clothing. Then the clothing is shipped to France where it is
    packaged in a box with a brand printed on it. It then goes on to be stored in
    a warehouse to be shipped to a physical shop or directly to an online customer.
    We can sum this supply chain up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cloth from India* -> *cut and assembled in Tunisia* -> *shipped to France*
    -> *packaged* -> *stored* -> *shipped to a shop or directly to a consumer*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A supply chain process such as an apparel production and delivery system involves
    thousands of people along the way: production sites, transport personnel, warehouse
    employees, and management teams for each step of the chain.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where a modern blockchain technology comes in handy to track all of
    the transactions down in one system.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will take six companies named A, B, C, D, E, and
    F. In *Chapter 1*, *Getting Started with Next-Generation Artificial Intelligence
    through Reinforcement Learning*, we used a size six reward matrix. In that chapter,
    we used A, B, C, D, E, and F to represent locations in a Markov decision process
    for reinforcement learning. At the end of the chapter, we saw that the reward
    matrix could be applied to many different domains. In our case, we will refer
    to the six items (A, B, C, D, E, and F) as companies and their locations (one
    per company in this example) in a supply chain process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each company, A to F, that is a member of the supply chain using blockchains
    can optimize its activity. Instead of each company having separate transaction
    ledgers, one central blockchain will contain all of the transactions (blocks):'
  prefs: []
  type: TYPE_NORMAL
- en: How much and when the cloth left India
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it got on a ship and how long it took
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ship got to Tunisia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: … all of the intermediate activities right down to the consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With such data, the blocks (records of the transactions) of a blockchain have
    become machine learning goldmines to detect information and make predictions.
    One profitable reason for using this system is to reduce stock levels. Piling
    up unsold goods to anticipate sales is costly and can ruin a company's profit.
    On the contrary, if each company in the supply chain can see the stock levels
    and real needs of the other partners through the blocks of the blockchain, they
    can fit their stock levels to the exact need and save huge amounts of money!
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works using IBM software as an example.
  prefs: []
  type: TYPE_NORMAL
- en: IBM Blockchain, based on Hyperledger Fabric, provides a way for companies around
    the world to share a blockchain transaction network without worrying about mining
    or using cryptocurrencies.
  prefs: []
  type: TYPE_NORMAL
- en: The system is based on the Linux Foundation project. Hyperledger is an open
    source collaborative project hosted by the Linux Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: At this level, Hyperledger uses blockchains to guarantee secure transactions
    without trying to optimize the cryptocurrency aspect. The software generates blocks
    in a blockchain network shared by all the parties involved, but they do not have
    to purchase cryptocurrencies in the currency sense—only in the technological sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following graph, we will use the six nodes (companies A to F) to illustrate
    how the Markov decision process we studied in *Chapter 1*, *Getting Started with
    Next-Generation Artificial Intelligence through Reinforcement Learning*, can be
    applied to a blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_07-1.jpg](img/B15438_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Markov decision process graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each node represents a company that takes part in an IBM Hyperledger network
    set up for those six companies, as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Company** | **Activity** | **ML weight** |'
  prefs: []
  type: TYPE_TB
- en: '| **A** buys and sells clothing and also other products in this network. |
    Provide goods to the network but keep stock levels down | Stock levels |'
  prefs: []
  type: TYPE_TB
- en: '| **B** buys and sells fabric and also other products in this network. | Provide
    goods to the network but keep stock levels down | Stock levels |'
  prefs: []
  type: TYPE_TB
- en: '| **C** buys and sells buttons and also other products in this network. | Provide
    goods to the network but keep stock levels down | Stock levels |'
  prefs: []
  type: TYPE_TB
- en: '| **D** buys and sells printed fabric and also other products in this network.
    | Provide goods to the network but keep stock levels down | Stock levels |'
  prefs: []
  type: TYPE_TB
- en: '| **E** buys and sells accessories (belts, bracelets) and also other products
    in this network. | Provide goods to the network but keep stock levels down | Stock
    levels |'
  prefs: []
  type: TYPE_TB
- en: '| **F** buys and sells packaging boxes and also other products in this network.
    | Provide goods to the network but keep stock levels down | Stock levels |'
  prefs: []
  type: TYPE_TB
- en: 'The structure of the table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Company** contains six companies, {A, B, C, D, E, F}, that have different
    activities. Each company, in this example, only has one location, so A to F are
    company locations as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activity**: Part of this group of companies to supply their members, but making
    sure the costly stock levels are kept down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ML weight** represents a classification by ML of the stock levels to make
    predictions. The key to profit generation, in our example, is to track the stock
    levels of each member (A to F) of the supply chain. If the stock levels of company
    F go down, for example, the other members of the network (A to E) can anticipate
    and deliver only the limited necessary amount for F''s stock levels to reach an
    acceptable level again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With millions of commercial transactions per year with a huge amount of transportation
    (truck, train, boat, air), it is increasingly complicated to manage this type
    of network effectively in the 21st century without a solution like IBM Hyperledger.
  prefs: []
  type: TYPE_NORMAL
- en: With IBM Hyperledger, the companies have **one** online transaction ledger with
    smart contracts (online) and real-time tracking.
  prefs: []
  type: TYPE_NORMAL
- en: The transactions are secure; they can be private or public among the members
    of the network, and they provide real-time optimization information for an artificial
    intelligence solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using blockchains in the supply chain network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*IBM Hyperledger provides artificial intelligence developers with a unique
    advantage over any other dataset—a 100% reliable dataset updated in real time.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each company member (A to F) of the network will create a block for each transaction
    so that an AI analyst can have access to the data to make forecasts. To make the
    system work, each member of the network (A to F) will create blocks in the blockchain
    so that others can view the information recorded and use the information to make
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A block is formed using the method described for mining a bitcoin, except that
    this time, currency is not a goal. The goal is a secure transaction with a smart
    contract when necessary. The following screenshot is a standard IBM interface
    that can be customized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C:\Users\gauravg\Desktop\9946\Chapter 14\B09940_14_02.png](img/B15438_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Standard IBM interface'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the individual and unique blocks that make up a blockchain. Each
    block in IBM Hyperledger has a unique number. In this example, it is **111** with
    a zoom on block **103**.
  prefs: []
  type: TYPE_NORMAL
- en: A block in the supply chain network in our graph (A to F) can be the purchase
    of a product X with a contract. The transaction can be between companies A and
    B, for example. The next block can be the transportation of that product to another
    location from A to B, for example, within the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information attached to that block is in the Hyperledger repository: company
    name (A to F), address, phone number, transaction description, and any other type
    of data required by the network of companies. Each block can be viewed by all
    or some depending on the permission properties attached to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exploring the blocks provides an artificial intelligence program with a gold
    mine: a real-life, and 100% reliable, dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part for AI optimization is the block information, as described
    in the following screenshot. The present block was added to the chain along with
    the previous block and the transaction code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_01-1.png](img/B15438_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Exploring the blockchain'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the block hash (see the preceding mining section) of a given block
    is linked to the previous block hash and possesses a unique transaction code.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our set of blocks as data (the type of transaction, date, amount),
    we can start to build an AI prediction algorithm. IBM provides extraction possibilities
    through scripts and other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a dataset containing blocks of the blockchain, the goal of the
    prediction will be to determine the stock level category to see whether a fellow
    member of the supply chain network (A to F) needs to be replenished.
  prefs: []
  type: TYPE_NORMAL
- en: The blocks of the blockchain provide data that can be used to predict the type
    of stock levels that the network will be facing after each transaction. Each company
    will be able to run a prediction algorithm that uses the existing data to predict
    the potential replenishing required. For example, company A might detect that
    company B needs more of its cloth.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the amount of data, a prediction algorithm such as naive Bayes can
    do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Part III – optimizing a supply chain with naive Bayes in a blockchain process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Naive Bayes will use some of the critical information as **features** to optimize
    warehouse storage and product availability in a real-time process.
  prefs: []
  type: TYPE_NORMAL
- en: The Naive Bayes learning function will learn from the previous blocks on how
    to predict the next blocks (supplying another company that needs more stock) that
    should be inserted in the blockchain. The blocks will be inserted in a dataset
    just like any other form of timestamped data to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naive Bayes is based on Bayes'' theorem. Bayes'' theorem applies conditional
    probability, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_07_001.png)'
  prefs: []
  type: TYPE_IMG
- en: '*P*(*A*|*B*) is a **posterior probability**, the probability of *A* after having
    observed some events (*B*). It is also a **conditional probability**: the likelihood
    of *A* happening given *B* has already happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*B*|*A*) is the probability of *B* given the prior observations *A*. It
    is also a conditional probability: the likelihood of *B* happening given *A* has
    already happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*A*) is the probability of *A* prior to the observations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*B*) is the probability of the predictions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naive Bayes, although based on Bayes' theorem, assumes that the features in
    a class are **independent** of each other. In many cases, this makes predictions
    more practical to implement. The statistical presence of features, related or
    not, will produce a prediction. As long as the prediction remains sufficiently
    efficient, naive Bayes provides a good solution.
  prefs: []
  type: TYPE_NORMAL
- en: A naive Bayes example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will first illustrate naive Bayes with a mathematical example
    before writing the Python program. The goal of this section is just to understand
    the concepts involved in naive Bayes.
  prefs: []
  type: TYPE_NORMAL
- en: This section is not a development chapter but a chapter to understand the underlying
    concepts of the real-life example and the mathematics used to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchains in this chapter represent information on the stock levels based
    on manufactured goods in the apparel industry. For more, read *Chapter 12*, *AI
    and the Internet of Things (IoT)*, which describes an AI-optimized apparel manufacturing
    process in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will focus on storage. The load of a sewing station in
    the apparel industry is expressed in quantities in **stock keep units** (**SKUs**).
    An SKU, for example, can be product P: a pair of jeans of a given size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the garment has been produced, it goes into storage. At that point, a
    block in a blockchain can represent that transaction with two useful features
    for a machine learning algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: The day the garment was stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total quantity of that SKU garment now in storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A block in a blockchain contains both the day (timestamp) and quantity stored
    in the transaction information.
  prefs: []
  type: TYPE_NORMAL
- en: Since the blockchain contains the storage blocks of all A, B, C, D, E, and F
    corporate locations that are part of the network, a machine learning program can
    access the data and make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to spread the stored quantities of the given product evenly over
    the six locations, as represented in the following histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_04-1.jpg](img/B15438_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Histogram of the storage level of the product distributed over
    six locations'
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the storage level of product P distributed over six locations.
    Each location in this blockchain network is a **hub**. A hub in **supply chain
    management** (**SCM**) is often an intermediate storage warehouse. For example,
    to cover the area of these six locations, the same product will be stored at each
    location. This way, local trucks can come and pick the goods for delivery.
  prefs: []
  type: TYPE_NORMAL
- en: '*The goal is to have an available product P at point location L (A to F) when
    needed.*'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the delivery time from a location *L* to a location point *a*[1]
    (a store or home) will only take a few hours. If A did not store P, then the finer
    consumer would have to wait for the product to travel from C to A, for example.
  prefs: []
  type: TYPE_NORMAL
- en: If the blockchain network is well organized, one location can specialize in
    producing product P (best production costs) and evenly distribute the quantity
    stored in the six locations, including itself.
  prefs: []
  type: TYPE_NORMAL
- en: By having evenly balanced storage quantities at all locations, the system will
    flow in a continuous delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, a company = its location (A to F). Using the blocks of the blockchain
    of these six members, we can predict when a given storage point (A to F) requires
    replenishing to reduce waiting times, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Using blockchains to optimize the storage levels is an efficient new approach
    to reducing costs while delivering to customers faster.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain anticipation novelty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In former days, all the warehouses at those six locations (A to F) had to ensure
    the minimum storage level for each location. Since they did not know what was
    happening in their supply chain network in real time, they often stored more products
    than required, which increased their costs, or did not store enough, leading to
    delivery problems.
  prefs: []
  type: TYPE_NORMAL
- en: In a world of real-time production and selling, distributors need to predict
    **demand**. The system needs to be **demand-driven**. Naive Bayes can solve that
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will take the first two features into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DAY**: The day the garment was stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STOCK**: The total quantity of that SKU garment now in storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then it will add a novelty—*the number of blocks related to product P*.
  prefs: []
  type: TYPE_NORMAL
- en: A high number of blocks at a given date means that this product was in demand
    in general (production, distribution). The more blocks there are, the more transactions
    there are. Also, if the storage levels (the STOCK feature) are diminishing, this
    is an indicator; it means storage levels must be replenished. The DAY feature
    timestamps the history of the product.
  prefs: []
  type: TYPE_NORMAL
- en: The block feature is named **BLOCKS**. Since all share the blockchain, a machine
    learning program can access reliable global data in seconds. The dataset reliability
    provided by blockchains constitutes a motivation in itself to optimize storage
    levels using the blocks of the blockchains as datasets.
  prefs: []
  type: TYPE_NORMAL
- en: The goal – optimizing storage levels using blockchain data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal is to *maintain stock at low levels* by providing fast delivery when
    product requests are made. To make a decision, the ML solution will analyze the
    blocks of a blockchain in real time.
  prefs: []
  type: TYPE_NORMAL
- en: The program will take the DAY, STOCK, and BLOCKS (number of) features for a given
    product P and produce a result. The result predicts whether this product P will
    be in demand. If the answer is yes (or 1), the demand for this product requires
    anticipation.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – defining the dataset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The dataset contains raw data from prior events in a sequence, which makes
    it perfect for prediction algorithms. Blocks can be extracted using scripts from
    IBM Hyperledger, for example. This constitutes a unique opportunity to see the
    data of all companies without having to build a database. The raw dataset will
    look like the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_02.jpg](img/B15438_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Raw dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'This dataset contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Blocks` of product P present in the blockchain on day `x` having scanned the
    blockchain back by 30 days. `No` means no significant amounts of blocks have been
    found. `Yes` means a significant number of blocks have been found. If blocks have
    been found, this means that there is a demand for this product somewhere along
    the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Some_blocks` means that blocks have been found, but they are too sparse to be
    taken into account without overfitting the prediction. However, `Yes` will contribute
    to the prediction as well as `No`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`No_blocks` means there is no demand at all, sparse or otherwise (`Some_blocks`),
    numerous (`Blocks`) or not. This means trouble for this product, P.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to avoid predicting demand on sparse (`Some_blocks`) or absent (`No_blocks`)
    products. This example is trying to predict a potential `Yes` for numerous blocks
    for this product P. Only if `Yes` is predicted can the system trigger the automatic
    demand process (see the *Implementation of naive Bayes in Python* section later
    in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – calculating the frequency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Looking at the following frequency table provides additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_03-1.jpg](img/B15438_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Frequency table'
  prefs: []
  type: TYPE_NORMAL
- en: The `Yes` and `No` statuses of each feature (`Blocks`, `Some_blocks`, or `No_blocks`)
    for a given product P for a given period (past 30 days) have been grouped by frequency.
  prefs: []
  type: TYPE_NORMAL
- en: The sum is on the bottom line for each `No` feature and `Yes` feature. For example,
    `Yes` and `No_blocks` add up to 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional information will prove useful for the final calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of samples = 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of `Yes` samples = 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of `No` samples = 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – calculating the likelihood
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that the **frequency** table has been calculated, the following **likelihood**
    table is produced using that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_05-300x97.jpg](img/B15438_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Likelihood table'
  prefs: []
  type: TYPE_NORMAL
- en: 'The table contains the following statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`No` = 2 = 20% = 0.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Yes` = 8 = 80%=0.8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Some_blocks` = 2 = 20%=0.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`No_blocks` = 3 = 30%=0.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blocks` = 5 = 50%=0.5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blocks` represent an important proportion of the samples, which means that
    along with `Some_blocks`, the demand looks good.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – applying the naive Bayes equation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The goal now is to represent each variable of the Bayes'' theorem in a naive
    Bayes equation to obtain the probability of having **demand** for product P and
    trigger a purchase scenario for the blockchain network. Bayes'' theorem can be
    expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_07_001.png)'
  prefs: []
  type: TYPE_IMG
- en: '*P*(*Yes*|*Blocks*) = *P*(*Blocks*|*Yes*) * *P*(*Yes*)/*P*(*Blocks*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*Yes*) = 8/10 = 0.8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*Blocks*) = 5/10 = 0.5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*Blocks*|*Yes*) = 4/8 = 0.5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P*(*Yes*|*Blocks*) = (0.5*0.8)/0.5 = 0.8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The demand looks acceptable. However, penalties are necessary, and other factors
    must be considered as well (transportation availability through other block exploration
    processes).
  prefs: []
  type: TYPE_NORMAL
- en: This example and method show the concept of the naive Bayes approach. This example
    is meant to be nothing other than a simplified mathematical explanation of the
    philosophy of Bayes' theorem.
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this calculation from scratch, we now know the basic concepts of Bayes''
    theorem: using prior values to predict future events taking several features into
    account.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now move from this theoretical approach to the implementation phase.
    We will build a program using naive Bayes in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of naive Bayes in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section shows how to use a stock level optimizer version of naive Bayes.
    Blockchains provide exceptionally reliable datasets for ML miners looking for
    areas to optimize and generate profit. Choosing the right model remains the key
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Gaussian naive Bayes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be implementing Gaussian naive Bayes because it fits the apparel industry.
    For example, if you sell dresses, there will be a target middle size *S*. The
    marketing department knows that this size *S* will represent most of the sales.
    The larger *S* + *n* sizes and small *S* – *n* will generate fewer sales, creating
    a Gaussian curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In implementation mode, a dataset with raw data from the blockchain will be
    used without the feature interpretation function of naive Bayes in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **DAY** | **STOCK** | **BLOCKS** | **DEMAND** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1455 | 78 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1666 | 67 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 1254 | 57 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 1563 | 45 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 1674 | 89 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1465 | 89 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 1646 | 76 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 1746 | 87 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 1435 | 78 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Each line represents a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DAY`: The day of the period analyzed in the dataset. In this case, we are
    analyzing the days of a given month, which represents a financial period. No other
    information is required to run a calculation. In other cases, a dd/mm/yyyy format
    can be used. You can also just use a counter (1 to *n*) from day 1 of the start
    of a period and run it over several weeks, months, or years.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOCK`: The total inputs in a given location (A, B, or … F) found in the blocks
    and totaled on that day. Since this represents the inputs of one location and
    only one, no location information is required. In other cases, the location can
    be added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLOCKS`: The number of blocks containing product P for location A, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high number of blocks in the `BLOCK` column and a low number of quantities
    in the `STOCK` column mean that demand is high.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DEMAND = 1`. The proof of demand is a transaction block that contains a purchase
    in the past. These transaction blocks provide vital information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A low number of blocks in the `BLOCK` column, and a high number of quantities
    in the `STOCK` column, mean that the demand is low.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DEMAND = 2`. Proof that no transaction was found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The limit of naive Bayes**'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, `DEMAND = 1` when the stock is high and the blocks are low. That's
    why strict correlation is not so useful. This would be the limit of naive Bayes,
    which just analyzes the statistics and learns how to predict, ignoring the actual
    conditional probabilities, the interactions between features.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we described the dataset and features that will be taken into
    account to write a naive Bayes program with ready-to-use algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now know what a blockchain is and how to use the blocks of a blockchain to
    optimize the stock levels of the locations of a network of companies (A to F).
    We also know the basic concepts of Bayes' theorem and naive Bayes.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we can build a Python program to predict the stock level
    categories of incoming blocks of a blockchain. These predictions will help local
    managers increase their stock levels to meet the demand of their partners (companies A
    to F) in the supply chain they are part of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `naive_bayes_blockchains.py` program uses a `sklearn` class. Consider
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It reads the dataset into the data structure. The following code reads `data_BC.csv`
    into `df`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the top of the file in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It prepares the training set, using `X` to find and predict `Y` in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It chooses the class and trains the following `clfG` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The program then takes some blocks of the blockchain, makes predictions, and
    prints them using the following `clfG.predict` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The blocks are displayed, and the following predictions are produced. `2` means
    no demand for the moment; `1` will trigger a purchase block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a replenishment program. It will mimic the demand. When no demand is
    found, nothing happens; when demand is found, it triggers a purchase block. Some
    chain stores know the number of garments purchased on a given day (or week or
    another unit) and automatically purchase that amount. Others have other purchasing
    rules. Finding business rules is part of the consulting aspect of a project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we implemented naive Bayes to predict the categories of the
    incoming blocks. If the demand is high, then a supply chain manager will know
    that more products need to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: If the demand is low, the manager will avoid storing more products. Blocks in
    a blockchain provide reliable datasets for a program that scans the blocks 24/7
    and generates recommendations in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reliable sequence of blocks in a blockchain has opened the door to endless
    machine learning algorithms. Naive Bayes appears to be a practical way to start
    optimizing the blocks of a blockchain. It calculates correlations and makes predictions
    by learning the independent features of a dataset, irrespective of whether the
    relationship is conditional or not.
  prefs: []
  type: TYPE_NORMAL
- en: This freestyle prediction approach fits the open-minded spirit of blockchains
    that are being propagated by the millions today with limitless resources.
  prefs: []
  type: TYPE_NORMAL
- en: IBM Hyperledger takes blockchain's "Frontierland" development to another level
    with the Linux Foundation project. IBM also offers a cloud platform and services.
  prefs: []
  type: TYPE_NORMAL
- en: IBM, Microsoft, Amazon, and Google provide cloud platforms with an arsenal of
    disruptive machine learning algorithms. This provides a smooth approach to your
    market or department, along with the ability to set up a blockchain prototype
    online in a short space of time. With this approach, you can enter some additional
    prototype data in the model, export the data, or use an API to read the block
    sequences. Then, you will be able to apply machine learning algorithms to these
    reliable datasets. The only limit is our imagination.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will lead us into more AI power as we explore the world of
    neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptocurrency is the only use of blockchains today. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mining blockchains can be lucrative. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blockchains for companies cannot be applied to sales. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Smart contracts for blockchains are more accessible to write than standard offline
    contracts. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a block is in a blockchain network, everyone in the network can read the
    content. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A block in a blockchain guarantees that absolutely no fraud is possible. (Yes |
    No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is only one way of applying Bayes' theorem. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Training a naive Bayes dataset requires a standard function. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Machine learning algorithms will not change the intrinsic nature of the corporate
    business. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more on naive Bayes on scikit-learn''s website: [https://scikit-learn.org/stable/modules/naive_bayes.html](https://scikit-learn.org/stable/modules/naive_bayes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To explore IBM''s Hyperledger solution: [https://www.ibm.com/blockchain/hyperledger.html](https://www.ibm.com/blockchain/hyperledger.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
