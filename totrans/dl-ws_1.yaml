- en: 1\. Building Blocks of Deep Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to deep learning and its relationship
    with artificial intelligence and machine learning. We will also learn about some
    of the important deep learning architectures, such as the multi-layer perceptron,
    convolutional neural networks, recurrent neural networks, and generative adversarial
    networks. As we progress, we will get hands-on experience with the TensorFlow
    framework and use it to implement a few linear algebra operations. Finally, we
    will be introduced to the concept of optimizers. We will understand their role
    in deep learning by utilizing them to solve a quadratic equation. By the end of
    this chapter, you will have a good understanding of what deep learning is and
    how programming with TensorFlow works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have just come back from your yearly vacation. Being an avid social media
    user, you are busy uploading your photographs to your favorite social media app.
    When the photos get uploaded, you notice that the app automatically identifies
    your face and tags you in them almost instantly. In fact, it does that even in
    group photos. Even in some poorly lit photos, you notice that the app has, most
    of the time, tagged you correctly. How does the app learn how to do that?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: To identify a person in a picture, the app requires accurate information on
    the person's facial structure, bone structure, eye color, and many other details.
    But when you used that photo app, you didn't have to feed all these details explicitly
    to the app. All you did was upload your photos, and the app automatically began
    identifying you in them. How did the app know all these details?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: When you uploaded your first photo to the app, the app would have asked you
    to tag yourself. When you manually tagged yourself, the app automatically "learned"
    all the information it needed to know about your face. Then, every time you upload
    a photo, the app uses the information it learned to identify you. It improves
    when you manually tag yourself in photos in which the app incorrectly tagged you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This ability of the app to learn new details and improve itself with minimal
    human intervention is possible due to the power of **deep learning** (**DL**).
    Deep learning is a part of **artificial intelligence** (**AI**) that helps a machine
    learn by recognizing patterns from labeled data. But wait a minute, isn't that
    what **machine learning** (**ML**) does? Then what is the difference between deep
    learning and machine learning? What is the point of confluence among domains such
    as AI, machine learning, and deep learning? Let's take a quick look.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: AI, Machine Learning, and Deep Learning
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artificial intelligence is the branch of computer science aimed at developing
    machines that can simulate human intelligence. Human intelligence, in a simplified
    manner, can be explained as decisions that are taken based on the inputs received
    from our five senses – sight, hearing, touch, smell, and taste. AI is not a new
    field and has been in vogue since the 1950s. Since then, there have been multiple
    waves of ecstasy and agony within this domain. The 21st century has seen a resurgence
    in AI following the big strides made in computing, the availability of data, and
    a better understanding of theoretical underpinnings. Machine learning and deep
    learning are subfields of AI and are increasingly used interchangeably.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能是计算机科学的一个分支，旨在开发能够模拟人类智能的机器。人类智能可以简化为基于来自我们五感——视力、听力、触觉、嗅觉和味觉——的输入来做出决策。AI并不是一个新领域，自1950年代以来就已有发展。此后，这个领域经历了多次高潮与低谷。进入21世纪，随着计算能力的飞跃、数据的丰富和对理论基础的更好理解，AI迎来了复兴。机器学习和深度学习是AI的子领域，并且越来越多地被交替使用。
- en: 'The following figure depicts the relationship between AI, ML, and DL:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了AI、ML和DL之间的关系：
- en: '![Figure 1.1: Relationship between AI, ML, and DL'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：AI、ML和DL之间的关系'
- en: '](img/B15385_01_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_01.jpg)'
- en: 'Figure 1.1: Relationship between AI, ML, and DL'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：AI、ML和DL之间的关系
- en: Machine Learning
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习
- en: Machine learning is the subset of AI that performs specific tasks by identifying
    patterns within data and extracting inferences. The inferences that are derived
    from data are then used to predict outcomes on unseen data. Machine learning differs
    from traditional computer programming in its approach to solving specific tasks.
    In traditional computer programming, we write and execute specific business rules
    and heuristics to get the desired outcomes. However, in machine learning, the
    rules and heuristics are not explicitly written. These rules and heuristics are
    learned by providing a dataset. The dataset provided for learning the rules and
    heuristics is called a **training dataset**. The whole process of learning and
    inferring is called **training**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是AI的一个子集，通过识别数据中的模式并提取推论来执行特定任务。从数据中得出的推论随后用于预测未知数据的结果。机器学习与传统计算机编程在解决特定任务的方法上有所不同。在传统的计算机编程中，我们编写并执行特定的业务规则和启发式算法来获得期望的结果。然而，在机器学习中，这些规则和启发式算法并没有被明确编写。这些规则和启发式算法是通过提供数据集进行学习的。用于学习这些规则和启发式算法的数据集称为**训练数据集**。整个学习和推断的过程称为**训练**。
- en: 'Learning rules and heuristics is done using different algorithms that use statistical
    models for that purpose. These algorithms make use of many representations of
    data for learning. Each such representation of data is called an **example**.
    Each element within an example is called a **feature**. The following is an example
    of the famous IRIS dataset ([https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris)).
    This dataset is a representation of different species of iris flowers based on
    different characteristics, such as the length and width of their sepals and petals:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 学习规则和启发式算法是通过使用不同的算法来完成的，这些算法采用统计模型来实现这一目的。这些算法利用多种数据表示方式进行学习。每种数据的表示方式称为**示例**。示例中的每个元素称为**特征**。以下是著名的IRIS数据集的一个示例（[https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris)）。该数据集表示了不同种类的鸢尾花，基于不同的特征，如萼片和花瓣的长度与宽度：
- en: '![Figure 1.2: Sample data from the IRIS dataset'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：IRIS数据集的样本数据'
- en: '](img/B15385_01_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_02.jpg)'
- en: 'Figure 1.2: Sample data from the IRIS dataset'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：IRIS数据集的样本数据
- en: In the preceding dataset, each row of data represents an example, and each column
    is a feature. Machine learning algorithms make use of these features to draw inferences
    from the data. The veracity of the models, and thereby the outcomes that are predicted,
    depend a lot on the features of the data. If the features provided to the machine
    learning algorithm are a good representation of the problem statement, the chances
    of getting a good result are high. Some examples of machine learning algorithms
    are *linear regression*, *logistic regression*, *support vector machines*, *random
    forest*, and *XGBoost*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据集中，每一行数据代表一个例子，每一列是一个特征。机器学习算法利用这些特征从数据中推断出结论。模型的准确性，以及预测结果的可靠性，很大程度上依赖于数据的特征。如果提供给机器学习算法的特征能够很好地代表问题陈述，那么得到好结果的机会就会很高。一些常见的机器学习算法包括*线性回归*、*逻辑回归*、*支持向量机*、*随机森林*和*XGBoost*。
- en: Even though traditional machine learning algorithms are useful for a lot of
    use cases, they have a lot of dependence on the quality of the features to get
    superior outcomes. The creation of features is a time-consuming art and requires
    a lot of domain knowledge. However, even with comprehensive domain knowledge,
    there are still limitations on transferring that knowledge to derive features,
    thereby encapsulating the nuances of the data generating processes. Also, with
    the increasing complexity of the problems that are tackled with machine learning,
    particularly with the advent of unstructured data (images, voice, text, and so
    on), it can be almost impossible to create features that represent the complex
    functions, which, in turn, generate data. As a result, there is often a need to
    find a different approach to solving complex problems; that is where deep learning
    comes into play.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管传统的机器学习算法在许多应用场景中都很有用，但它们在获得优异结果时，非常依赖于特征的质量。特征的创建是一门耗时的艺术，且需要大量的领域知识。然而，即便拥有全面的领域知识，仍然存在将这些知识转化为特征的局限性，进而无法很好地封装数据生成过程中的细微差别。此外，随着机器学习所解决问题的复杂性增加，特别是非结构化数据（如图像、语音、文本等）的出现，几乎不可能创建能够表示复杂函数的特征，这些复杂函数反过来又生成数据。因此，往往需要找到一种不同的方法来解决复杂问题，这时深度学习就派上了用场。
- en: Deep Learning
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度学习
- en: Deep learning is a subset of machine learning and an extension of a certain
    kind of algorithm called Artificial Neural Networks (ANNs). Neural networks are
    not a new phenomenon. Neural networks were created in the first half of the 1940s.
    The development of neural networks was inspired by the knowledge of how the human
    brain works. Since then, there have been several ups and downs in this field.
    One defining moment that renewed enthusiasm around neural networks was the introduction
    of an algorithm called backpropagation by stalwarts in the field such as Geoffrey
    Hinton. For this reason, Hinton is widely regarded as the 'Godfather of Deep Learning'.
    We will be discussing neural networks in depth in *Chapter 2*, *Neural Networks.*
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习是机器学习的一个子集，是一种称为人工神经网络（ANN）的算法的扩展。神经网络并不是一种新现象。神经网络的创建可以追溯到20世纪40年代的上半期。神经网络的开发灵感来自于对人类大脑运作方式的了解。从那时起，这一领域经历了几次高潮和低谷。一个重新激发人们对神经网络兴趣的关键时刻是由该领域的巨头们，如Geoffrey
    Hinton，提出的反向传播算法。正因为如此，Hinton被广泛认为是“深度学习的教父”。我们将在*第2章*《神经网络》中深入讨论神经网络。
- en: 'ANNs with multiple (deep) layers lie at the heart of deep learning. One defining
    characteristic of deep learning models is their ability to learn features from
    the input data. Unlike traditional machine learning, where there is the need to
    create features, deep learning excels in learning different hierarchies of features
    across multiple layers. Say, for example, we are using a deep learning model to
    detect faces. The initial layers of the model will learn low-level approximations
    of a face, such as the edges of the face, as shown in *Figure 1.3*. Each succeeding
    layer takes the lower layers'' features and puts them together to form more complex
    features. In the case of face detection, if the initial layer has learned to detect
    edges, the subsequent layers will put these edges together to form parts of a
    face such as the nose or eyes. This process continues with each successive layer,
    with the final layer generating an image of a human face:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多层（深层）人工神经网络（ANNs）是深度学习的核心。深度学习模型的一个显著特点是其能够从输入数据中学习特征。与传统的机器学习不同，后者需要手动创建特征，深度学习擅长从多个层次学习不同的特征层级。例如，假设我们使用一个深度学习模型来检测人脸。模型的初始层会学习面部的低级近似特征，如面部的边缘，如*图
    1.3*所示。每个后续层会将前一层的特征组合起来，形成更复杂的特征。在人脸检测的例子中，如果初始层学会了检测边缘，后续层将这些边缘组合起来，形成面部的一部分，如鼻子或眼睛。这个过程在每一层继续进行，直到最后一层生成一个完整的人脸图像：
- en: '![Figure 1.3: Deep learning model for detecting faces'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3：用于检测人脸的深度学习模型'
- en: '](img/B15385_01_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_03.jpg)'
- en: 'Figure 1.3: Deep learning model for detecting faces'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：用于检测人脸的深度学习模型
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The preceding image is sourced from the popular research paper: Lee, Honglak
    & Grosse, Roger & Ranganath, Rajesh & Ng, Andrew. (2011). *Unsupervised Learning
    of Hierarchical Representations with Convolutional Deep Belief Networks.* Commun.
    ACM. 54\. 95-103\. 10.1145/2001269.2001295.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图片来自于一篇流行的研究论文：Lee, Honglak & Grosse, Roger & Ranganath, Rajesh & Ng, Andrew.
    (2011). *无监督学习层次表示与卷积深度置信网络.* Commun. ACM. 54\. 95-103\. 10.1145/2001269.2001295.
- en: Deep learning techniques have made great strides over the past decade. There
    are different factors that have led to the exponential rise of deep learning techniques.
    At the top of the list is the availability of large quantities of data. The digital
    age, with its increasing web of connected devices, has generated lots of data,
    especially unstructured data. This, in turn, has fueled the large-scale adoption
    of deep learning techniques as they are well-suited to handle large unstructured
    data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习技术在过去十年中取得了巨大的进步。多个因素促使了深度学习技术的指数增长，其中最重要的因素是大量数据的可用性。数字时代，随着越来越多设备的互联，产生了大量数据，特别是非结构化数据。这反过来促进了深度学习技术的大规模应用，因为它们非常适合处理大量的非结构化数据。
- en: Another major factor that has led to the rise in deep learning is the strides
    that have been made in computing infrastructure. Deep learning models that have
    large numbers of layers and millions of parameters necessitate great computing
    power. The advances in computing layers such as **Graphical Processing Units**
    (**GPUs**) and **Tensor Processing Units** (**TPUs**) at an affordable cost has
    led to the large-scale adoption of deep learning.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习崛起的另一个重要因素是计算基础设施的进步。深度学习模型通常包含大量层次和数百万个参数，因此需要强大的计算能力。图形处理单元（**GPU**）和张量处理单元（**TPU**）等计算层次的进步，以合理的成本提供了强大的计算能力，从而推动了深度学习的广泛应用。
- en: The pervasiveness of deep learning was also accelerated by open sourcing different
    frameworks in order to build and implement deep learning models. In 2015, the
    Google Brain team open sourced the TensorFlow framework and since then TensorFlow
    has grown to be one of the most popular frameworks for deep learning. The other
    major frameworks available are PyTorch, MXNet, and Caffe. We will be using the
    TensorFlow framework in this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习的普及还得益于不同框架的开源，这些框架用于构建和实现深度学习模型。2015年，Google Brain团队开源了TensorFlow框架，自那时以来，TensorFlow已成长为最受欢迎的深度学习框架之一。其他主要的框架包括PyTorch、MXNet和Caffe。本书将使用TensorFlow框架。
- en: Before we dive deep into the building blocks of deep learning, let's get our
    hands dirty with a quick demo that illustrates the power of deep learning models.
    You don't need to know any of the code that is presented in this demo. Simply
    follow the instructions and you'll be able to get a quick glimpse of the basic
    capabilities of deep learning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨深度学习的构建块之前，让我们通过一个简短的演示来实际体验深度学习模型的强大功能。你不需要了解演示中的所有代码。只需按照指示操作，你就能快速了解深度学习的基本能力。
- en: Using Deep Learning to Classify an Image
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用深度学习分类图像
- en: In the exercise that follows, we will classify an image of a pizza and convert
    the resulting class text into speech. To classify the image, we will be using
    a pre-trained model. The conversion of text into speech will be done using a freely
    available API called **Google Text-to-Speech** (**gTTS**). Before we get into
    it, let's understand some of the key building blocks of this demo.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将分类一个披萨的图像，并将分类结果的文本转换为语音。为了对图像进行分类，我们将使用一个预训练的模型。文本转语音将使用一个免费提供的API——**Google文本转语音**（**gTTS**）来完成。在开始之前，让我们先了解一些这个演示的关键构建块。
- en: Pre-Trained Models
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预训练模型
- en: Training a deep learning model requires a lot of computing infrastructure and
    time, with big datasets. However, to aid with research and learning, the deep
    learning community has also made models that have been trained on large datasets
    available. These pre-trained models can be downloaded and used for predictions
    or can be used for further training. In this demo, we will be using a pre-trained
    model called `ResNet50`. This model is available along with the Keras package.
    This pre-trained model can predict 1,000 different classes of objects that we
    encounter in our daily lives, such as birds, animals, automobiles, and more.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 训练一个深度学习模型需要大量的计算资源和时间，并且需要庞大的数据集。然而，为了促进研究和学习，深度学习社区也提供了在大数据集上训练好的模型。这些预训练模型可以下载并用于预测，或者用于进一步训练。在本次演示中，我们将使用一个名为`ResNet50`的预训练模型。这个模型与Keras包一起提供。这个预训练模型能够预测我们日常生活中遇到的1,000种不同类型的物体，比如鸟类、动物、汽车等。
- en: The Google Text-to-Speech API
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google文本转语音API
- en: Google has made its Text-to-Speech algorithm available for limited use. We will
    be using this algorithm to convert the predicted text into speech.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Google已经将其文本转语音算法开放供有限使用。我们将使用这个算法将预测的文本转换为语音。
- en: Prerequisite Packages for the Demo
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示所需的先决条件包
- en: 'For this demo to work, you will need the following packages installed on your
    machine:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个演示正常工作，你需要在机器上安装以下包：
- en: TensorFlow 2.0
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 2.0
- en: Keras
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras
- en: gTTS
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gTTS
- en: Please refer to the *Preface* to understand the process of installing the first
    two packages. Installing gTTS will be shown in the exercise. Let's dig into the
    demo.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*前言*以了解安装前两个包的过程。安装gTTS将在练习中展示。接下来，让我们深入了解演示。
- en: 'Exercise 1.01: Image and Speech Recognition Demo'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01：图像和语音识别演示
- en: 'In this exercise, we will demonstrate image recognition and speech-to-text
    conversion using deep learning models. At this point, you will not be able to
    understand each and every line of the code. This will be explained later. For
    now, just execute the code and find out how easy it is to build deep learning
    and AI applications with TensorFlow. Follow these steps to complete this exercise:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将演示使用深度学习模型进行图像识别和语音转文本的转换。此时，你可能无法理解代码中的每一行，这将在后续讲解中解释。现在，只需执行代码，了解使用TensorFlow构建深度学习和人工智能应用程序有多么简单。按照以下步骤完成本次练习：
- en: Open a Jupyter Notebook and name it *Exercise 1.01.* For details on how to start
    a Jupyter Notebook, please refer to the preface.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Jupyter Notebook并命名为*练习1.01*。关于如何启动Jupyter Notebook的详细信息，请参阅前言。
- en: 'Import all the required libraries:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必需的库：
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is a brief description of the packages we''ll be importing:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里简要描述我们将要导入的包：
- en: '`load_img`: Loads the image into the Jupyter Notebook'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`load_img`：将图像加载到Jupyter Notebook中'
- en: '`img_to_array`: Converts the image into a NumPy array, which is the desired
    format for Keras'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`img_to_array`：将图像转换为NumPy数组，这是Keras所需的格式'
- en: '`preprocess_input`: Converts the input into a format that''s acceptable for
    the model'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`preprocess_input`：将输入转换为模型可以接受的格式'
- en: '`decode_predictions`: Converts the numeric output of the model prediction into
    text labels'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`decode_predictions`：将模型预测的数值输出转换为文本标签'
- en: '`Resnet50`: This is the pre-trained image classification model'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Resnet50`：这是一个预训练的图像分类模型'
- en: 'Create an instance of the pre-trained `Resnet` model:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个预训练的`Resnet`模型实例：
- en: '[PRE1]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should get a message similar to the following as it downloads:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下载过程中你应收到类似以下的消息：
- en: '![Figure 1.4: Loading Resnet50'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.4：加载Resnet50'
- en: '](img/B15385_01_04.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15385_01_04.jpg)'
- en: 'Figure 1.4: Loading Resnet50'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.4：加载Resnet50
- en: '`Resnet50` is a pre-trained image classification model. For first-time users,
    it will take some time to download the model into your environment.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Resnet50`是一个预训练的图像分类模型。对于首次使用者，下载模型到你的环境中需要一些时间。'
- en: Download an image of a pizza from the internet and store it in the same folder
    that you are running the Jupyter Notebook in. Name the image `im1.jpg`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网上下载一张披萨的图片，并将其保存在运行Jupyter Notebook的同一文件夹中。将图片命名为`im1.jpg`。
- en: Note
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also use the image we are using by downloading it from this link: [https://packt.live/2AHTAC9](https://packt.live/2AHTAC9)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还可以通过此链接下载我们使用的图片：[https://packt.live/2AHTAC9](https://packt.live/2AHTAC9)
- en: 'Load the image to be classified using the following command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令加载待分类的图片：
- en: '[PRE2]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you are storing the image in another folder, the complete path of the location
    where the image is located has to be given in place of the `im1.jpg` command.
    For example, if the image is stored in `D:/projects/demo`, the code should be
    as follows:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将图片保存在另一个文件夹中，则必须提供图片所在位置的完整路径，代替`im1.jpg`命令。例如，如果图片保存在`D:/projects/demo`中，代码应如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s display the image using the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过以下命令来显示图片：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding command will be as follows:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令的输出将如下所示：
- en: '![Figure 1.5: Output displayed after loading the image'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.5：加载图片后显示的输出'
- en: '](img/B15385_01_05.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15385_01_05.jpg)'
- en: 'Figure 1.5: Output displayed after loading the image'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.5：加载图片后显示的输出
- en: 'Convert the image into a `numpy` array as the model expects it in this format:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片转换为`numpy`数组，因为模型期望它是这种格式：
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Reshape the image into a four-dimensional format since that''s what is expected
    by the model:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片调整为四维格式，因为这是模型期望的格式：
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Prepare the image for submission by running the `preprocess_input()` function:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`preprocess_input()`函数准备图片以供提交：
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the prediction:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行预测：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The prediction results in a number that needs to be converted into the corresponding
    label in text format:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预测结果是一个数字，需要将其转换为相应的文本格式标签：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, type in the following code to display the label:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，键入以下代码以显示标签：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Print the label using the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码打印标签：
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you have followed the steps correctly so far, the output will be as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果到目前为止你已正确按照步骤操作，输出结果将如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The model has successfully identified our image. Interesting, isn't it? In the
    next few steps, we'll take this a step further and convert this result into speech.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型已成功识别我们的图片。很有趣，不是吗？接下来的几个步骤，我们将进一步处理，将这个结果转化为语音。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: While we have used an image of a pizza here, you can use just about any image
    with this model. We urge you to try out this exercise multiple times with different
    images.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然我们在这里使用了一张披萨的图片，但你可以使用任何图片来进行模型测试。我们建议你多次尝试使用不同的图片进行此练习。
- en: 'Prepare the text to be converted into speech:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备要转换为语音的文本：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Install the `gtts` package, which is required for converting text into speech.
    This can be implemented in the Jupyter Notebook, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`gtts`包，该包用于将文本转换为语音。可以在Jupyter Notebook中按如下方式实现：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Import the required libraries:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will import two libraries. One is `gTTS`, that is, Google
    Text-to-Speech, which is a cloud-based open source API for converting text into
    speech. Another is the `os` library that is used to play the resulting audio file.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将导入两个库。一个是`gTTS`，即Google文本转语音服务，这是一个基于云的开源API，用于将文本转换为语音。另一个是`os`库，用于播放生成的音频文件。
- en: 'Call the `gTTS` API and pass the text as a parameter:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`gTTS` API并将文本作为参数传递：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You need to be online while running the preceding step.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行上述步骤时，你需要保持在线状态。
- en: Save the resulting audio file. This file will be saved in the home directory
    where the Jupyter Notebook is being run.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存生成的音频文件。该文件将保存在运行Jupyter Notebook的主目录中。
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can also specify the path where you want it to be saved by including the
    absolute path in front of the name; for example, `(myobj.save('D:/projects/prediction.mp3')`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还可以通过在文件名之前指定绝对路径来设置保存位置；例如，`(myobj.save('D:/projects/prediction.mp3')`。
- en: 'Play the audio file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放音频文件：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you have correctly followed the preceding steps, you will hear the words
    `This is a pizza` being spoken.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正确地遵循了前面的步骤，你将听到`This is a pizza`的语音。
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZPZx8B](https://packt.live/2ZPZx8B).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2ZPZx8B](https://packt.live/2ZPZx8B)。
- en: You can also run this example online at [https://packt.live/326cRIu](https://packt.live/326cRIu).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/326cRIu](https://packt.live/326cRIu)在线运行这个示例。你必须执行整个笔记本才能获得预期的结果。
- en: In this exercise, we learned how to build a deep learning model by making use
    of publicly available models using a few lines of code in TensorFlow. Now that
    you have got a taste of deep learning, let's move forward and learn about the
    different building blocks of deep learning.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何通过使用公共可用的模型并用几行代码在TensorFlow中构建深度学习模型。现在你已经体验了深度学习，让我们继续前进，了解深度学习的不同构建块。
- en: Deep Learning Models
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度学习模型
- en: At the heart of most of the popular deep learning models are ANNs, which are
    inspired by our knowledge of how the brain works. Even though no single model
    can be called perfect, different models perform better in different scenarios.
    In the sections that follow, we will learn about some of the most prominent models.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的深度学习模型的核心是人工神经网络（ANN），其灵感来源于我们对大脑工作原理的认识。虽然没有任何单一模型可以称为完美，但不同的模型在不同的场景下表现更好。在接下来的章节中，我们将了解一些最突出的模型。
- en: The Multi-Layer Perceptron
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多层感知器
- en: 'The **multi-layer perceptron** (**MLP**) is a basic type of neural network.
    An MLP is also known as a feed-forward network. A representation of an MLP can
    be seen in the following figure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**多层感知器**（**MLP**）是一种基本的神经网络类型。MLP也被称为前馈网络。以下图所示可以看到MLP的表示：'
- en: '![Figure 1.6: MLP representation'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：MLP表示'
- en: '](img/B15385_01_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_06.jpg)'
- en: 'Figure 1.6: MLP representation'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：MLP表示
- en: One of the basic building blocks of an MLP (or any neural network) is a neuron.
    A network consists of multiple neurons connected to successive layers. At a very
    basic level, an MLP will consist of an input layer, a hidden layer, and an output
    layer. The input layer will have neurons equal to the input data. Each input neuron
    will have a connection to all the neurons of the hidden layer. The final hidden
    layer will be connected to the output layer. The MLP is a very useful model and
    can be tried out on various classification and regression problems. The concept
    of an MLP will be covered in detail in *Chapter 2*, *Neural Networks.*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 多层感知器（MLP，或任何神经网络）的基本构建块之一是神经元。一个网络由多个神经元连接到后续的层。非常基础的MLP由输入层、隐藏层和输出层组成。输入层的神经元数量与输入数据相等。每个输入神经元将与隐藏层的所有神经元相连接。最终的隐藏层将与输出层连接。MLP是一个非常有用的模型，可以尝试应用于各种分类和回归问题。MLP的概念将在*第二章*，*神经网络*中详细介绍。
- en: Convolutional Neural Networks
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷积神经网络
- en: A convolutional neural network (CNN) is a class of deep learning model that
    is predominantly used for image recognition. When we discussed the MLP, we saw
    that each neuron in a layer is connected to every other neuron in the subsequent
    layer. However, CNNs adopt a different approach and do not resort to such a fully
    connected architecture. Instead, CNNs extract local features from images, which
    are then fed to the subsequent layers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积神经网络（CNN）是一类深度学习模型，主要用于图像识别。当我们讨论MLP时，我们看到每一层的神经元都与后续层的每个神经元相连接。然而，CNN采用了不同的方法，并没有使用这种完全连接的架构。相反，CNN从图像中提取局部特征，然后将这些特征传递到后续层。
- en: 'CNNs rose to prominence in 2012 when an architecture called AlexNet won a premier
    competition called the **ImageNet Large-Scale Visual Recognition Challenge** **(ILSVRC)**.
    ILSVRC is a large-scale computer vision competition where teams from around the
    globe compete for the prize of the best computer vision model. Through the 2012
    research paper titled *ImageNet Classification with Deep Convolutional Neural
    Networks* ([https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks)),
    Alex Krizhevsky, et al. (University of Toronto) showcased the true power of CNN
    architectures, which eventually won them the 2012 ILSVRC challenge. The following
    figure depicts the structure of the *AlexNet* model, a CNN model whose high performance
    catapulted CNNs to prominence in the deep learning domain. While the structure
    of this model may look complicated to you, in *Chapter 3*, *Image Classification
    with Convolutional Neural Networks*, the working of such CNN networks will be
    explained to you in detail:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7: CNN architecture of the AlexNet model'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_07.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.7: CNN architecture of the AlexNet model'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned diagram is sourced from the popular research paper: Krizhevsky,
    Alex & Sutskever, Ilya & Hinton, Geoffrey. (2012). *ImageNet Classification with
    Deep Convolutional Neural Networks.* Neural Information Processing Systems. 25\.
    10.1145/3065386.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Since 2012, there have been many breakthrough CNN architectures expanding the
    possibilities for computer vision. Some of the prominent architectures are ZFNet,
    Inception (GoogLeNet), VGG, and ResNet.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most prominent use cases where CNNs are put to use are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Image recognition and **optical character recognition** (**OCR**)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Face recognition on social media
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text classification
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object detection for self-driving cars
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image analysis for health care
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another great benefit of working with deep learning is that you needn't always
    build your models from scratch – you could use models built by others and use
    them for your own applications. This is known as "transfer learning", and it allows
    you to benefit from the active deep learning community.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We will apply transfer learning to image processing and learn about CNNs and
    their dynamics in detail in *Chapter 3*, *Image Classification with Convolutional
    Neural Networks*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Recurrent Neural Networks
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In traditional neural networks, the inputs are independent of the outputs.
    However, in cases such as language translation, where there is dependence on the
    words preceding and succeeding a word, there is a need to understand the dynamics
    of the sequences in which words appear. This problem was solved by a class of
    networks called **recurrent neural networks** (**RNNs**). RNNs are a class of
    deep learning networks where the output from the previous step is sent as input
    to the current step. A distinct characteristic of an RNN is a hidden layer, which
    remembers the information of other inputs in a sequence. A high-level representation
    of an RNN can be seen in the following figure. You''ll learn more about the inner
    workings of these networks in *Chapter 5,* *Deep Learning for Sequences*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: Structure of RNNs'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_08.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.8: Structure of RNNs'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of RNN architecture. Some of the most prominent ones
    are **long short-term memory** (**LSTM**) and **gated recurrent units** (**GRU**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important use cases for RNNs are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Language modeling and text generation
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine translation
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speech recognition
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating image descriptions
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RNNs will be covered in detail in *Chapter 5*, *Deep Learning for Sequences*,
    and *Chapter 6,* *LSTMs, GRUs, and Advanced RNNs*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Generative Adversarial Networks
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Generative adversarial networks** (**GANs**) are networks that are capable
    of generating data distributions similar to any real data distributions. One of
    the pioneers of deep learning, Yann LeCun, described GANs as one of the most promising
    ideas in deep learning in the last decade.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, suppose we want to generate images of dogs from random
    noise data. For this, we train a GAN network with real images of dogs and the
    noise data until we generate data that looks like the real images of dogs. The
    following diagram explains the concept behind GANs. At this stage, you might not
    fully understand this concept. It will be explained in detail in *Chapter 7*,
    *Generative Adversarial Networks*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: Structure of GANs'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_09.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.9: Structure of GANs'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned diagram is sourced from the popular research paper: Barrios,
    Buldain, Comech, Gilbert & Orue (2019). *Partial Discharge Classification Using
    Deep Learning Methods—Survey of Recent Progress* ([https://doi.org/10.3390/en12132485](https://doi.org/10.3390/en12132485)).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'GANs are a big area of research, and there are many use cases for them. Some
    of the useful applications of GANs are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Image translation
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text to image synthesis
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating videos
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The restoration of art
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GANs will be covered in detail in *Chapter 7*, *Generative Adversarial Networks*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibilities and promises of deep learning are huge. Deep learning applications
    have become ubiquitous in our daily lives. Some notable examples are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Chatbots
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robots
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart speakers (such as Alexa)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual assistants
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation engines
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drones
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-driving cars or autonomous vehicles
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ever-expanding canvas of possibilities makes it a great toolset in the
    arsenal of a data scientist. This book will progressively introduce you to the
    amazing world of deep learning and make you adept at applying it to real-world
    scenarios.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TensorFlow
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TensorFlow is a deep learning library developed by Google. At the time of writing
    this book, TensorFlow is by far the most popular deep learning library. It was
    originally developed by a team within Google called the Google Brain team for
    their internal use and was subsequently open sourced in 2015\. The Google Brain
    team has developed popular applications such as Google Photos and Google Cloud
    Speech-to-Text, which are deep learning applications based on TensorFlow. TensorFlow
    1.0 was released in 2017, and within a short period of time, it became the most
    popular deep learning library ahead of other existing libraries, such as Caffe,
    Theano, and PyTorch. It is considered the industry standard, and almost every
    organization that is doing something in the deep learning space has adopted it.
    Some of the key features of TensorFlow are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: It can be used with all common programming languages, such as Python, Java,
    and R
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be deployed on multiple platforms, including Android and Raspberry Pi
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run in a highly distributed mode and hence is highly scalable
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After being in Alpha/Beta release for a long time, the final version of TensorFlow
    2.0 was released on September 30, 2019\. The focus of TF2.0 was to make the development
    of deep learning applications easier. Let's go ahead and understand the basics
    of the TensorFlow 2.0 framework.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**Tensors**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Inside the TensorFlow program, every data element is called a **tensor**. A
    tensor is a representation of vectors and matrices in higher dimensions. The rank
    of a tensor denotes its dimensions. Some of the common data forms represented
    as tensors are as follows.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: A scalar is a tensor of rank 0, which only has magnitude.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: For example, `[ 12 ]` is a scalar of magnitude 12.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: A vector is a tensor of rank 1.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: For example, `[ 10 , 11, 12, 13]`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrix**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is a tensor of rank 2.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: For example, `[ [10,11] , [12,13] ]`. This tensor has two rows and two columns.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Tensor of rank 3**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a tensor in three dimensions. For example, image data is predominantly
    a three-dimensional tensor with width, height, and the number of channels as its
    three dimensions. The following is an example of a tensor with three dimensions,
    that is, it has two rows, three columns, and three channels:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: Tensor with three dimensions'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.10: Tensor with three dimensions'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape of a tensor is represented by an array and indicates the number of
    elements in each dimension. For example, if the shape of a tensor is [2,3,5],
    it means the tensor has three dimensions. If this were to be image data, this
    shape would mean that this tensor has two rows, three columns, and five channels.
    We can also get the rank from the shape. In this example, the rank of the tensor
    is three, since there are three dimensions. This is further illustrated in the
    following diagram:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 张量的形状由一个数组表示，表示每个维度中的元素个数。例如，如果一个张量的形状是 [2,3,5]，这意味着该张量有三个维度。如果这是图像数据，则此形状表示该张量有两行、三列和五个通道。我们还可以从形状中获取秩。在这个例子中，张量的秩是三，因为有三个维度。下面的图示进一步说明了这一点：
- en: '![Figure 1.11: Examples of Tensor rank and shape'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11：张量的秩和形状示例'
- en: '](img/B15385_01_11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_11.jpg)'
- en: 'Figure 1.11: Examples of Tensor rank and shape'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：张量的秩和形状示例
- en: Constants
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'Constants are used to store values that are not changed or modified during
    the course of the program. There are multiple ways in which a constant can be
    created, but the simplest way is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 常量用于存储在程序执行过程中不会被改变或修改的值。创建常量有多种方式，最简单的一种如下：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This creates a tensor initialized to 10\. Keep in mind that a constant''s value
    cannot be updated or modified by reassigning a new value to it. Another example
    is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个初始化为 10 的张量。请记住，常量的值不能通过重新赋值来更新或修改。另一个示例如下：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this line, we are instantiating a string as a constant.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们正在将一个字符串实例化为常量。
- en: Variables
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'A variable is used to store data that can be updated and modified during the
    course of the program. We will look at this in more detail in *Chapter 2*, *Neural
    Networks*. There are multiple ways of creating a variable, but the simplest way
    is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 变量用于存储在程序执行过程中可以更新和修改的数据。我们将在*第二章*，*神经网络*中详细讨论这一点。创建变量有多种方式，最简单的一种如下：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, the variable `b` is initialized to `20`. Note that in
    TensorFlow, unlike constants, the term `Variable` is written with an uppercase
    `V`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量`b`被初始化为`20`。请注意，在 TensorFlow 中，与常量不同，`Variable` 这个术语的首字母是大写的。
- en: 'A variable can be reassigned a different value during the course of the program.
    Variables can be used to assign any type of object, including scalars, vectors,
    and multi-dimensional arrays. The following is an example of how an array whose
    dimensions are 3 x 3 can be created in TensorFlow:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在程序执行过程中重新赋予不同的值。变量可以用于赋值任何类型的对象，包括标量、向量和多维数组。以下是如何在 TensorFlow 中创建一个维度为
    3 x 3 的数组的示例：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This variable can be initialized to a 3 x 3 matrix, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量可以初始化为一个 3 x 3 的矩阵，如下所示：
- en: '![Figure 1.12: 3 x 3 matrix'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12：3 x 3 矩阵'
- en: '](img/B15385_01_12.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_12.jpg)'
- en: 'Figure 1.12: 3 x 3 matrix'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：3 x 3 矩阵
- en: Now that we know some of the basic concepts of TensorFlow, let's learn how to
    put them into practice.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 TensorFlow 的一些基本概念，接下来让我们学习如何将它们付诸实践。
- en: Defining Functions in TensorFlow
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 TensorFlow 中定义函数
- en: 'A function can be created in Python using the following syntax:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中可以使用以下语法创建函数：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A function is initiated using the special operator `def`, followed by the name
    of the function, `myfunc`, and the arguments for the function. In the preceding
    example, the body of the function is in the second line, and the last line returns
    the output.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊运算符`def`来初始化一个函数，接着是函数的名称`myfunc`，以及函数的参数。在前面的示例中，函数体位于第二行，最后一行返回输出。
- en: In the following exercise, we will learn how to implement a small function using
    the variables and constants we defined earlier.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将学习如何使用之前定义的变量和常量来实现一个简单的函数。
- en: 'Exercise 1.02: Implementing a Mathematical Equation'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02：实现一个数学方程
- en: 'In this exercise, we will solve the following mathematical equation using TensorFlow:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将使用 TensorFlow 求解以下数学方程：
- en: '![Figure 1.13: Mathematical equation to be solved using TensorFlow'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13：使用 TensorFlow 求解的数学方程'
- en: '](img/B15385_01_13.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15385_01_13.jpg)'
- en: 'Figure 1.13: Mathematical equation to be solved using TensorFlow'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：使用 TensorFlow 求解的数学方程
- en: 'We will use TensorFlow to solve it, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 TensorFlow 来求解它，如下所示：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While there are multiple ways of doing this, we will only explore one of the
    ways in this exercise. Follow these steps to complete this exercise:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多种方法可以实现这一点，但在本练习中我们只会探索其中的一种方法。按照以下步骤完成此练习：
- en: Open a new Jupyter Notebook and rename it *Exercise 1.02*.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the TensorFlow library using the following command:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s solve the equation. For that, you will need to create two variables,
    `X` and `Y`, and initialize them to the given values of `3` and `4`, respectively:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our equation, the value of `2` isn''t changing, so we''ll store it as a
    constant by typing the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the function that will solve our equation:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Call the function by passing `X`, `Y`, and `C` as parameters. We''ll be storing
    the output of this function in a variable called `result`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Print the result using the `tf.print()` function:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output will be as follows:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2ClXKjj](https://packt.live/2ClXKjj).
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ZOIN1C](https://packt.live/2ZOIN1C).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we learned how to define and use a function. Those familiar
    with Python programming will notice that it is not a lot different from normal
    Python code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will prepare ourselves by looking at some basic
    linear algebra and familiarize ourselves with some of the common vector operations,
    so that understanding neural networks in the next chapter will be much easier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Linear Algebra with TensorFlow
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important linear algebra topic that will be used in neural networks
    is matrix multiplication. In this section, we will explain how matrix multiplication
    works and then use TensorFlow's built-in functions to solve some matrix multiplication
    examples. This is essential in preparation for neural networks in the next chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: How does matrix multiplication work? You might have studied this as part of
    high school, but let's do a quick recap.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have to perform a matrix multiplication between two matrices,
    A and B, where we have the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: Matrix A'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_14.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14: Matrix A'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: Matrix B'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_15.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: Matrix B'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The first step would be to check whether multiplying a 2 x 3 matrix by a 3 x
    2 matrix is possible. There is a prerequisite for matrix multiplication. Remember
    that C=R, that is, the number of columns (C) in the first matrix should be equal
    to the number of rows (R) in the second matrix. And remember the sequence matters
    here, and that's why, A x B is not equal to B x A. In this example, C=3 and R=3\.
    So, multiplication is possible.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The resultant matrix would have the number of rows equal to that in A and the
    number of columns equal to that in B. So, in this case, the result would be a
    2 x 2 matrix.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin multiplying the two matrices, take the elements of the first row of
    A (R1) and the elements of the first column of B (C1):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16: Matrix A(R1)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_16.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.16: Matrix A(R1)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17: Matrix B(C1)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_17.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.17: Matrix B(C1)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the sum of the element-wise products, that is, (1 x 7) + (2 x 9) + (3 x
    11) = 58\. This will be the first element in the resultant 2 x 2 matrix. We''ll
    call this incomplete matrix D(i) for now:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18: Incomplete matrix D(i)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_18.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.18: Incomplete matrix D(i)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat this with the first row of A(R1) and the second column of B (C2):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: First row of matrix A'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_19.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.19: First row of matrix A'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20: Second column of matrix B'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_20.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.20: Second column of matrix B'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the sum of the products of the corresponding elements, that is, (1 x 8)
    + (2 x 10) + (3 x 12) = 64\. This will be the second element in the resultant
    matrix:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21: Second element of matrix D(i)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_21.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.21: Second element of matrix D(i)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the same with the second row to get the final result:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22: Matrix D'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_22.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: Matrix D'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The same matrix multiplication can be performed in TensorFlow using a built-in
    method called `tf.matmul()`. The matrices that need to be multiplied must be supplied
    to the model as variables, as shown in the following example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding case, A and B are the matrices that we want to multiply. Let's
    practice this method by using TensorFlow to multiply the two matrices we multiplied
    manually.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Matrix Multiplication Using TensorFlow'
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the `tf.matmul()` method to multiply two matrices
    using `tensorflow`. Follow these steps to complete this exercise:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Open a new Jupyter Notebook and rename it *Exercise 1.03*.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `tensorflow` library and create two variables, `X` and `Y`, as matrices.
    `X` is a 2 x 3 matrix and `Y` is a 3 x 2 matrix:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Print and display the values of `X` and `Y` to make sure the matrices are created
    correctly. We''ll start by printing the value of `X`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output will be as follows:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s print the value of `Y`:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output will be as follows:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Perform matrix multiplication by calling the TensorFlow `tf.matmul()` function:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To display the result, print the value of `c1`:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output will be as follows:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s perform matrix multiplication by changing the order of the matrices:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To display the result, let''s print the value of `c2`:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The resulting output will be as follows.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the results are different since we changed the order.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eevyw4](https://packt.live/3eevyw4).
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2CfGGvE](https://packt.live/2CfGGvE).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we learned how to create matrices in TensorFlow and how to
    perform matrix multiplication. This will come in handy when we create our own
    neural networks.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The reshape Function
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reshape, as the name suggests, changes the shape of a tensor from its current
    shape to a new shape. For example, you can reshape a 2 × 3 matrix to a 3 × 2 matrix,
    as shown here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: Reshaped matrix'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_23.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: Reshaped matrix'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following 2 × 3 matrix, which we defined as follows in
    the previous exercise:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can print the shape of the matrix using the following code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From the following output, we can see the shape, which we already know:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, to reshape `X` into a 3 × 2 matrix, TensorFlow provides a handy function
    called `tf.reshape()`. The function is implemented with the following arguments:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, `X` is the matrix that needs to be reshaped, and `[3,2]`
    is the new shape that the `X` matrix has to be reshaped to.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Reshaping matrices is a handy operation when implementing neural networks.
    For example, a prerequisite when working with images using CNNs is that the image
    has to be of rank 3, that is, it has to have three dimensions: width, height,
    and depth. If our image is a grayscale image that has only two dimensions, the
    `reshape` operation will come in handy to add a third dimension. In this case,
    the third dimension will be 1:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24: Changing the dimension using reshape()'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_24.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.24: Changing the dimension using reshape()'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we are reshaping a matrix of shape `[5,4]` to a matrix
    of shape `[5,4,1]`. In the exercise that follows, we will be using the `reshape()`
    function to reshape a `[5,4]` matrix.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some important considerations when implementing the `reshape()` function:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The total number of elements in the new shape should be equal to the total number
    of elements in the original shape. For example, you can reshape a 2 × 3 matrix
    (a total of 6 elements) to a 3 × 2 matrix since the new shape also has 6 elements.
    However, you cannot reshape it to 3 × 3 or 3 × 4.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reshape()` function should not be confused with `transpose()`. In `reshape()`,
    the sequence of the elements of the matrix is retained and the elements are rearranged
    in the new shape in the same sequence. However, in the case of `transpose()`,
    the rows become columns and the columns become rows. Hence the sequence of the
    elements will change.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `reshape()` function will not change the original matrix unless you assign
    the new shape to it. Otherwise, it simply displays the new shape without actually
    changing the original variable. For example, let''s say `x` has shape [2,3] and
    you simply run `tf.reshape(x,[3,2])`. When you check the shape of `x` again, it
    will remain as [2,3]. In order to actually change the shape, you need to assign
    the new shape to it, like this:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let's try implementing `reshape()` in TensorFlow in the exercise that follows.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.04: Reshaping Matrices Using the reshape() Function in TensorFlow'
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will reshape a `[5,4]` matrix into the shape of `[5,4,1]`
    using the `reshape()` function. This exercise will help us understand how `reshape()`
    can be used to change the rank of a tensor. Follow these steps to complete this
    exercise:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Jupyter Notebook and rename it *Exercise 1.04*. Then, import `tensorflow`
    and create the matrix we want to reshape:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, we''ll print the variable `A` to check whether it is created correctly,
    using the following command:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be as follows:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s print the shape of `A`, just to be sure:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Currently, it has a rank of 2\. We'll be using the `reshape()` function to change
    its rank to 3.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will reshape `A` to the shape [5,4,1] using the following command.
    We''ve thrown in the `print` command just to see what the output looks like:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll get the following output:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That worked as expected.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see the new shape of `A`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can see that `A` still has the same shape. Remember that we discussed that
    in order to save the new shape, we need to assign it to itself. Let's do that
    in the next step.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we''ll assign the new shape to `A`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s check the new shape of `A` once again:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will see the following output:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With that, we have not just reshaped the matrix but also changed its rank from
    2 to 3\. In the next step, let's print out the contents of `A` just to be sure.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see what `A` contains now:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output, as expected, will be as follows:'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gHvyGQ](https://packt.live/3gHvyGQ).
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ZdjdUY](https://packt.live/2ZdjdUY).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we saw how to use the `reshape()` function. Using `reshape()`,
    we can change the rank and shape of tensors. We also learned that reshaping a
    matrix changes the shape of the matrix without changing the order of the elements
    within the matrix. Another important thing that we learned was that the reshape
    dimension has to align with the number of elements in the matrix. Having learned
    about the `reshape` function, we will go ahead and learn about the next function,
    which is Argmax.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The argmax Function
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's understand the `argmax` function, which is frequently used in neural
    networks. `Argmax` returns the position of the maximum value along a particular
    axis in a matrix or tensor. It must be noted that it does not return the maximum
    value, but rather the index position of the maximum value.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: For example, if `x` = `[1,10,3,5]`, then `tf.argmax(x)` will return 1 since
    the maximum value (which in this case is 10) is in the index position 1.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the index starts with 0\. So, considering the preceding example of
    `x`, the element 1 will have an index of 0, 10 will have an index of 1, and so
    on.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say we have the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25: An example matrix'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_25.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.25: An example matrix'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, `argmax` has to be used with the `axis` parameter. When `axis`
    equals 0, it returns the position of the maximum value in each column, as shown
    in the following figure:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.26: The argmax operation along axis 0'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_26.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.26: The argmax operation along axis 0'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the maximum value in the first column is 9, so the index, in
    this case, will be 2\. Similarly, if we move along to the second column, the maximum
    value is 5, which has an index of 0\. In the third column, the maximum value is
    8, and hence the index is 1\. If we were to run the `argmax` function on the preceding
    matrix with the `axis` as 0, we would get the following output:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When `axis` = 1, `argmax` returns the position of the maximum value across
    each row, like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.27: The argmax operation along axis 1'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_27.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.27: The argmax operation along axis 1'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving along the rows, we have 5 at index 1, 8 at index 2, and 9 at index 0\.
    If we were to run the `argmax` function on the preceding matrix with the axis
    as 1, we would get the following output:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With that, let's try and implement `argmax` on a matrix.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Implementing the argmax() Function'
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to use the `argmax` function to find the position
    of the maximum value in a given matrix along axes 0 and 1\. Follow these steps
    to complete this exercise:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `tensorflow` and create the following matrix:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s print `X` and see what the matrix looks like:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be as follows:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Print the shape of `X`:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output will be as follows:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let''s use `argmax` to find the positions of the maximum values while
    keeping `axis` as `0`:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output will be as follows:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Referring to the matrix in *Step 2*, we can see that, moving across the columns,
    the index of the maximum value (91) in the first column is 0\. Similarly, the
    index of the maximum value along the second column (88) is 1\. And finally, the
    maximum value across the third column (75) has index 2\. Hence, we have the aforementioned
    output.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s change the `axis` to `1`:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output will be as follows:'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Again, referring to the matrix in *Step 2*, if we move along the rows, the maximum
    value along the first row is 91, which is at index 0\. Similarly, the maximum
    value along the second row is 88, which is at index 1\. Finally, the third row
    is at index 0 again, with a maximum value of 75.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZR5q5p](https://packt.live/2ZR5q5p).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3eewhNO](https://packt.live/3eewhNO).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to use the `argmax` function to find the position
    of the maximum value along a given axis of a tensor. This will be used in the
    subsequent chapters when we perform classification using neural networks.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Optimizers
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at neural networks, let's learn about one more important concept,
    and that is optimizers. Optimizers are extensively used for training neural networks,
    so it is important to understand their application. In this chapter, let's get
    a basic introduction to the concept of an optimizer. As you might already be aware,
    the purpose of machine learning is to find a function (along with its parameters)
    that maps inputs to outputs.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say the original function of a data distribution is a linear
    function (linear regression) of the following form:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, `Y` is the dependent variable (label), `X` the independent variable (features),
    and `m` and `b` are the parameters of the model. Solving this problem with machine
    learning would entail learning the parameters `m` and `b` and thereby the form
    of the function that connects `X` to `Y`. Once the parameters have been learned,
    if we are given a new value for `X`, we can calculate or predict the value of
    `Y`. It is in learning these parameters that optimizers come into play. The learning
    process entails the following steps:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Assume some arbitrary random values for the parameters `m` and `b`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these assumed parameters, for a given dataset, estimate the values of `Y`
    for each `X` variable.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the difference between the predicted value of `Y` and the actual value
    of `Y` associated with the `X` variable. This difference is called the **loss
    function** or **cost function**. The magnitude of loss will depend on the parameter
    values we initially assumed. If the assumptions were way off the actual values,
    then the loss will be high. The way to get toward the right parameter is by changing
    or altering the initial assumed values of the parameters in such a way that the
    loss function is minimized. This task of changing the values of the parameters
    to reduce the loss function is called optimization.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are different types of optimizers that are used in deep learning. Some
    of the most popular ones are stochastic gradient descent, Adam, and RMSprop. The
    detailed functionality and the internal workings of optimizers will be described
    in *Chapter 2, Neural Networks*, but here, we will see how they are applied in
    solving certain common problems, such as simple linear regression. In this chapter,
    we will be using an optimizer called Adam, which is a very popular optimizer.
    We can define the Adam optimizer in TensorFlow using the following code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Once an optimizer has been defined, we can use it to minimize the loss using
    the following code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The terms `[m,b]` are the parameters that will be changed during the optimization
    process. Now, let's use an optimizer to train a simple linear regression model
    using TensorFlow.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: Using an Optimizer for a Simple Linear Regression'
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to see how to use an optimizer to train a simple
    linear regression model. We will start off by assuming arbitrary values for the
    parameters (`w` and `b`) in a linear equation `w*x + b`. Using the optimizer,
    we will observe how the values of the parameters change to get to the right parameter
    values, thus mapping the relationship between the input values (`x`) and output
    (`y`). Using the optimized parameter values, we will predict the output (`y`)
    for some given input values (`x`). After completing this exercise, we will see
    that the linear output, which is predicted by the optimized parameters, is very
    close to the real values of the output values. Follow these steps to complete
    this exercise:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Open a Jupyter Notebook and rename it *Exercise 1.06*.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `tensorflow`, create the variables, and initialize them to 0\. Here,
    our assumed values are zero for both these parameters:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Define a function for the linear regression model. We learned how to create
    functions in TensorFlow earlier:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Prepare the data in the form of features (`x`) and labels (`y`):'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the `loss` function. In this case, this is the absolute value of the
    difference between the predicted value and the label:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create an `Adam` optimizer instance with a learning rate of `.01`. The learning
    rate defines at what rate the optimizer should change the assumed parameters.
    We will discuss the learning rate in subsequent chapters:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Train the model by running the optimizer for 1,000 iterations to minimize the
    loss:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Print the trained values of the `w` and `b` parameters:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will be as follows:'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can see that the values of the `w` and `b` parameters have been changed from
    their original values of 0, which were assumed. This is what is done during the
    optimizing process. These updated parameter values will be used for predicting
    the values of `Y`.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The optimization process is stochastic in nature (having a random probability
    distribution), and you might get values for `w` and `b` that are different to
    the value that was printed here.
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the trained model to predict the output by passing in the `x` values. The
    model predicts the values, which are very close to the label values (`y`), which
    means the model was trained to a high level of accuracy:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output of the preceding command will be as follows:'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gSBs8b](https://packt.live/3gSBs8b).
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2OaFs7C](https://packt.live/2OaFs7C).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we saw how to use an optimizer to train a simple linear regression
    model. During this exercise, we saw how the initially assumed values of the parameters
    were updated to get the true values. Using the true values of the parameters,
    we were able to get the predictions close to the actual values. Understanding
    how to apply the optimizer will help you later with training neural network models.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the use of an optimizer, let's take what we've learned
    and apply the optimization function to solve a quadratic equation in the next
    activity.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.01: Solving a Quadratic Equation Using an Optimizer'
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will use an optimizer to solve the following quadratic
    equation:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.28: A quadratic equation'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15385_01_28.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.28: A quadratic equation'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the high-level steps you need to follow to complete this activity:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Open a new Jupyter Notebook and import the necessary packages, just as we did
    in the previous exercises.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the variable. Please note that, in this example, `x` is the variable
    that you will need to initialize. You can initialize it to a value of 0.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the `loss` function using the `lambda` function. The `loss` function
    will be the quadratic equation that you are trying to solve.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Adam` optimizer with a learning rate of `.01`.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the optimizer for different iterations and minimize the loss. You can start
    the number of iterations at 1,000 and then increase it in subsequent trials until
    you get the result you desire.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the optimized value of `x`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Please note that while your actual output might be a little different, it should
    be a value close to 5.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: The detailed steps for this activity, along with the solutions and additional
    commentary, are presented on page 388.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter. Let's revisit what we have learned
    so far. We started off by looking at the relationship between AI, machine learning,
    and deep learning. Then, we implemented a demo of deep learning by classifying
    an image and then implementing a text to speech conversion using a Google API.
    This was followed by a brief description of different use cases and types of deep
    learning, such as MLP, CNN, RNN, and GANs.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we were introduced to the TensorFlow framework and understood
    some of the basic building blocks, such as tensors and their rank and shape. We
    also implemented different linear algebra operations using TensorFlow, such as
    matrix multiplication. Later in the chapter, we performed some useful operations
    such as `reshape` and `argmax`. Finally, we were introduced to the concept of
    optimizers and implemented solutions for mathematical expressions using optimizers.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have laid the foundations for deep learning and introduced you to
    the TensorFlow framework, the stage has been set for you to take a deep dive into
    the fascinating world of neural networks. In the next chapter, you will be introduced
    to neural networks, and in the successive chapters, we will take a look at more
    in-depth deep learning concepts. We hope you enjoy this fascinating journey.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
