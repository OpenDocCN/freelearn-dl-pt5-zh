<html><head></head><body>
  <div id="_idContainer017">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-15" class="chapterTitle">Getting Started with Next-Generation Artificial Intelligence through Reinforcement Learning</h1>
    <p class="normal">Next-generation AI compels us to realize that machines do indeed think. Although machines do not think like us, their thought process has proven its efficiency in many areas. In the past, the belief was that AI would reproduce human thinking processes. Only neuromorphic computing (see <em class="italics">Chapter 18</em>, <em class="italics">Neuromorphic Computing</em>), remains set on this goal. Most AI has now gone beyond the way humans think, as we will see in this chapter.</p>
    <p class="normal">The <strong class="bold">Markov decision process</strong> (<strong class="bold">MDP</strong>), a <strong class="bold">reinforcement learning</strong> (<strong class="bold">RL</strong>) algorithm, perfectly illustrates<a id="_idIndexMarker000"/> how machines have become intelligent in their own<a id="_idIndexMarker001"/> unique way. Humans build their decision process on experience. MDPs are memoryless. Humans use logic and reasoning to think problems through. MDPs apply random decisions 100% of the time. Humans think in words, labeling everything they perceive. MDPs have an unsupervised approach that uses no labels or training data. MDPs boost the machine thought process of self-driving cars (SDCs), translation tools, scheduling software, and more. This memoryless, random, and unlabeled machine thought process marks a historical change in the way a former human problem was solved.</p>
    <p class="normal">With this realization comes a yet more mind-blowing fact. AI algorithms and hybrid solutions built on IoT, for example, have begun to surpass humans in strategic areas. Although AI cannot replace humans in every field, AI combined with classical automation now occupies key domains: banking, marketing, supply chain management, scheduling, and many other critical areas.</p>
    <p class="normal">As you will see, starting with this chapter, you can occupy a central role in this new world as an adaptive thinker. You can design AI solutions and implement them. There is no time to waste. In this chapter, we are going to dive quickly and directly into reinforcement learning through the MDP.</p>
    <p class="normal">Today, AI is essentially mathematics translated into source code, which makes it difficult to learn for traditional developers. However, we will tackle this approach pragmatically.</p>
    <p class="normal">The goal here is not to take the easy route. We're striving to break complexity into understandable parts and confront them with reality. You are going to find out right from the outset how to apply an adaptive thinker's process that will lead you from an idea to a solution in reinforcement learning, and right into the center of gravity of the next generation of AI.</p>
    <h1 id="_idParaDest-16" class="title">Reinforcement learning concepts</h1>
    <p class="normal">AI is constantly evolving. The classical approach states that:</p>
    <ul>
      <li class="list">AI covers all domains</li>
      <li class="list">Machine learning is a subset of AI, with clustering, classification, regression, and reinforcement learning</li>
      <li class="list">Deep learning is a subset of machine learning that involves neural networks</li>
    </ul>
    <p class="normal">However, these domains often overlap and it's difficult to fit neuromorphic computing, for example, with its sub-symbolic approach, into these categories (see <em class="italics">Chapter 18</em>, <em class="italics">Neuromorphic Computing</em>).</p>
    <p class="normal">In this chapter, RL <a id="_idIndexMarker002"/>clearly fits into machine learning. Let's have a brief look into the scientific foundations of the MDP, the RL algorithm we are going to explore. The main concepts to keep in mind are the following:</p>
    <ul>
      <li class="list"><strong class="bold">Optimal transport</strong>: In 1781, Gaspard <a id="_idIndexMarker003"/>Monge defined transport optimizing from one location to another using the shortest and most cost-effective path; for example, mining coal and then using the most cost-effective path to a factory. This was subsequently generalized to any form of path from point A to point B.</li>
      <li class="list"><strong class="bold">Boltzmann equation and constant</strong>: In <a id="_idIndexMarker004"/>the late <a id="_idIndexMarker005"/>19th century, Ludwig Boltzmann changed our vision of the world with his probabilistic distribution of particles beautifully summed up in his entropy formula:<p class="center"><em class="italics">S</em> = <em class="italics">k</em> * log <em class="italics">W</em></p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><em class="italics">S</em> represents the entropy (energy, disorder) of a system expressed. <em class="italics">k</em> is the Boltzmann constant, and <em class="italics">W</em> represents the number of microstates. We will explore Boltzmann's ideas further in <em class="italics">Chapter 14</em>, <em class="italics">Preparing the Input of Chatbots with Restricted Boltzmann Machines (RBMs) and Principal Component Analysis (PCA)</em>.</p>
      </li>
      <li class="list"><strong class="bold">Probabilistic distributions advanced further</strong>: Josiah Willard Gibbs took the probabilistic distributions<a id="_idIndexMarker006"/> of large numbers of particles a step further. At<a id="_idIndexMarker007"/> that point, probabilistic information theory was advancing quickly. At the turn of the 19th century, Andrey Markov applied probabilistic algorithms to language, among other areas. A modern era of information theory was born.</li>
      <li class="list"><strong class="bold">When Boltzmann and optimal transport meet</strong>: 2011 Fields Medal winner, Cédric Villani, brought <a id="_idIndexMarker008"/>Boltzmann's equation to yet another level. Villani then went on to unify optimal transport and Boltzmann. Cédric Villani proved something that was somewhat intuitively known to 19th century mathematicians but required proof.</li>
    </ul>
    <p class="normal">Let's take all of the preceding concepts and materialize them in a real-world example that will explain why reinforcement learning using the MDP, for example, is so innovative.</p>
    <p class="normal">Analyzing the following cup of tea will take you right into the next generation of AI:</p>
    <figure class="mediaobject"><img src="../Images/B15438_01_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.1: Consider a cup of tea</p>
    <p class="normal">You can look at this cup of tea in two different ways:</p>
    <ol>
      <li class="list"><strong class="bold">Macrostates</strong>: You<a id="_idIndexMarker009"/> look at the cup and content. You can see the volume of tea in the cup and you could feel the temperature when holding the cup in your hand.</li>
      <li class="list"><strong class="bold">Microstates</strong>: But<a id="_idIndexMarker010"/> can you tell how many molecules are in the tea, which ones are hot, warm, or cold, their velocity and directions? Impossible right?</li>
    </ol>
    <p class="normal">Now, imagine, the tea contains 2,000,000,000+ Facebook accounts, or 100,000,000+ Amazon Prime users with millions of deliveries per year. At this level, we simply abandon the idea of controlling every item. We work on trends and probabilities.</p>
    <p class="normal">Boltzmann provides a probabilistic approach to the evaluation of the features of our real world. Materializing Boltzmann in logistics through optimal transport means that the temperature could be the ranking of a product, the velocity can be linked to the distance to delivery, and the direction could be the itineraries we will study in this chapter.</p>
    <p class="normal">Markov picked up the ripe fruits of microstate probabilistic descriptions and applied it to his MDP. Reinforcement learning takes the huge volume of elements (particles in a cup of tea, delivery locations, social network accounts) and defines the probable paths they take.</p>
    <p class="normal">The turning point of human thought occurred when we simply could not analyze the state and path of the huge volumes facing our globalized world, which generates images, sounds, words, and numbers that exceed traditional software approaches.</p>
    <p class="normal">With this in mind, we can start exploring the MDP.</p>
    <h1 id="_idParaDest-17" class="title">How to adapt to machine thinking and become an adaptive thinker</h1>
    <p class="normal">Reinforcement learning, one of the foundations of machine learning, supposes learning through trial and error by interacting with an environment. This sounds familiar, doesn't it? That is what we humans do all our lives—in pain! Try things, evaluate, and then continue; or try something else.</p>
    <p class="normal">In real life, you are<a id="_idIndexMarker011"/> the agent of your thought process. In reinforcement learning, the<a id="_idIndexMarker012"/> agent is<a id="_idIndexMarker013"/> the function calculating randomly through this trial-and-error process. This thought process function in machine learning is the MDP agent. This form of empirical learning is sometimes called<a id="_idIndexMarker014"/> Q-learning.</p>
    <p class="normal">Mastering the theory and implementation of an MDP through a three-step method is a prerequisite.</p>
    <p class="normal">This chapter will detail the three-step approach that will turn you into an AI expert, in general terms:</p>
    <ol>
      <li class="list">Starting by describing a problem to solve with real-life cases</li>
      <li class="list">Then, building a mathematical model that considers real-life limitations</li>
      <li class="list">Then, writing source code or using a cloud platform solution</li>
    </ol>
    <p class="normal">This is a way for you to approach any project with an adaptive attitude from the outset. This shows that a human will always be at the center of AI by explaining how we can build the inputs, run an algorithm, and use the results of our code. Let's consider this three-step process and put it into action.</p>
    <h1 id="_idParaDest-18" class="title">Overcoming real-life issues using the three-step approach</h1>
    <p class="normal">The<a id="_idIndexMarker015"/> key point of this chapter is to avoid writing code that will never be used. First, begin by understanding the subject as a subject matter expert. Then, write the analysis with words and mathematics to make sure your reasoning reflects the subject and, most of all, that the program will make sense in real life. Finally, in step 3, only write the code when you are sure about the whole project.</p>
    <p class="normal">Too many developers start writing code without stopping to think about how the results of that code are going to manifest themselves within real-life situations. You could spend weeks developing the perfect code for a problem, only to find out that an external factor has rendered your solution useless. For instance, what if you coded a solar-powered robot to clear snow from the yard, only to discover that during winter, there isn't enough sunlight to power the robot!</p>
    <p class="normal">In this chapter, we are going to tackle the MDP (Q function) and apply it to reinforcement learning with the Bellman equation. We are going to approach it a little differently to most, however. We'll be thinking about practical application, not simply code execution. You can find tons of source code and examples on the web. The problem is, much like our snow robot, such source code rarely considers the complications that come about in real-life situations. Let's say you find a program that finds the optimal path for a drone delivery. There's an issue, though; it has many limits that need to be overcome due to the fact that the code has not been written with real-life practicality in mind. You, as an adaptive thinker, are going to ask some questions:</p>
    <ul>
      <li class="list">What if there are 5,000 drones over a major city at the same time? What happens if they try to move in straight lines and bump into each other?</li>
      <li class="list">Is a drone-jam legal? What about the noise over the city? What about tourism?</li>
      <li class="list">What about the weather? Weather forecasts are difficult to make, so how is this scheduled?</li>
      <li class="list">How can we resolve the problem of coordinating the use of charging and parking stations?</li>
    </ul>
    <p class="normal">In just a few minutes, you will be at the center of attention among theoreticians who know more than you, on one hand, and angry managers who want solutions they cannot get on the other. Your real-life approach will solve these problems. To do that, you must take the following three steps into account, starting with really getting involved in the real-life subject.</p>
    <p class="normal">In order to successfully implement our real-life approach, comprised of the three steps outlined in the previous section, there are a few prerequisites:</p>
    <ul>
      <li class="list"><strong class="bold">Be a subject matter expert (SME)</strong>: First, you have to be an SME. If a theoretician geek comes up with a hundred TensorFlow functions to solve a drone trajectory problem, you now know it is going to be a tough ride in which real-life parameters are constraining the algorithm. An<a id="_idIndexMarker016"/> SME knows the subject and thus can quickly identify the critical factors of a given field. AI often requires finding a solution to a complex problem that even an expert in a given field cannot express mathematically. Machine learning sometimes means finding a solution to a problem that humans do not know how to explain. Deep learning, involving complex networks, solves even more difficult problems.</li>
      <li class="list"><strong class="bold">Have enough mathematical knowledge to understand AI concepts</strong>: Once you have the proper natural language analysis, you need to build your abstract representation quickly. The best way is to look around and find an everyday life example and make a mathematical model of it. Mathematics is not an option in AI, but a prerequisite. The effort is worthwhile. Then, you can start writing a solid piece of source code or start implementing a cloud platform ML solution.</li>
      <li class="list"><strong class="bold">Know what source code is about as well as its potential and limits</strong>: MDP is an excellent way to go and start working on the three dimensions that will make you adaptive: describing what is around you in detail in words, translating that into mathematical representations, and then implementing the result in your source code.</li>
    </ul>
    <p class="normal">With those prerequisites in mind, let's look at how you can become a problem-solving AI expert by following our practical three-step process. Unsurprisingly, we'll begin at step 1.</p>
    <h2 id="_idParaDest-19" class="title">Step 1 – describing a problem to solve: MDP in natural language</h2>
    <p class="normal">Step 1 of any AI problem<a id="_idIndexMarker017"/> is to go as far as you can to understand the subject you<a id="_idIndexMarker018"/> are asked to represent. If it's <a id="_idIndexMarker019"/>a medical subject, don't just look at data; go to a hospital or a research center. If it's a private security application, go to the places where they will need to use it. If it's for social media, make sure to talk to many users directly. The key concept to bear in mind is that you have to get a "feel" for the subject, as if you were the real "user."</p>
    <p class="normal">For example, transpose it into something you know in your everyday life (work or personal), something you are an SME in. If you have a driver's license, then you are an SME of driving. You are certified. This is a fairly common certification, so let's use this as our subject matter in the example that will follow. If you do not have a driver's license or never drive, you can easily replace moving around in a car by imagining you are moving around on foot; you are an SME of getting from one place to another, regardless of what means of transport that might involve. However, bear in mind that a real-life project would involve additional technical aspects, such as traffic regulations for each country, so our imaginary SME does have its limits.</p>
    <p class="normal">Getting into the<a id="_idIndexMarker020"/> example, let's say you are an e-commerce business <a id="_idIndexMarker021"/>driver delivering a package in a location you are unfamiliar with. You are the operator of a self-driving vehicle. For the <a id="_idIndexMarker022"/>time being, you're driving manually. You have a GPS with a nice color map on it. The locations around you are represented by the letters <strong class="bold">A</strong> to <strong class="bold">F</strong>, as shown in the simplified map in the following diagram. You are presently at <strong class="bold">F</strong>. Your goal is to reach location <strong class="bold">C</strong>. You are happy, listening to the radio. Everything is going smoothly, and it looks like you are going to be there on time. The following diagram represents the locations and routes that you can cover:</p>
    <figure class="mediaobject"><img src="../Images/B15438_01_02.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_01_01.png"/></figure>
    <p class="packt_figref">Figure 1.2: A diagram of delivery routes</p>
    <p class="normal">The guidance system's state indicates the complete path to reach <strong class="bold">C</strong>. It is telling you that you are going to go from <strong class="bold">F</strong> to <strong class="bold">B</strong> to <strong class="bold">D</strong>, and then to <strong class="bold">C</strong>. It looks good!</p>
    <p class="normal">To break things down further, let's say:</p>
    <ul>
      <li class="list">The present state is the letter <em class="italics">s</em>. <em class="italics">s</em> is a variable, not an actual state. It can be one of the locations in <em class="italics">L</em>, the set of locations:<p class="center"><em class="italics">L</em> = {<strong class="bold">A</strong>, <strong class="bold">B</strong>, <strong class="bold">C</strong>, <strong class="bold">D</strong>, <strong class="bold">E</strong>, <strong class="bold">F</strong>}</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We say <em class="italics">present state</em> because there is no sequence in the learning process. The memoryless process goes from one present state to another. In the example in this chapter, the process starts at location <strong class="bold">F</strong>.</p>
      </li>
      <li class="list">Your next action is the letter <em class="italics">a</em> (action). This action <em class="italics">a</em> is not location <strong class="bold">A</strong>. The goal of this action is to take us to the next possible location in the graph. In this case, only <strong class="bold">B</strong> is possible. The goal of <em class="italics">a</em> is to take us from <em class="italics">s</em> (present state) to <em class="italics">s'</em> (new state).</li>
      <li class="list">The action <em class="italics">a</em> (not location <strong class="bold">A</strong>) is to go to location <strong class="bold">B</strong>. You look at your guidance system; it tells you there is no traffic, and that to go from your present state, <strong class="bold">F</strong>, to your next state, <strong class="bold">B</strong>, will take you only a few minutes. Let's say that the next state <strong class="bold">B</strong> is the letter <strong class="bold">B</strong>. This next state <strong class="bold">B</strong> is <em class="italics">s'</em>.</li>
    </ul>
    <p class="normal">At this point, you are still quite happy, and we can sum up your situation with the following sequence of events:</p>
    <p class="center"><em class="italics">s</em>, <em class="italics">a</em>, <em class="italics">s'</em></p>
    <p class="normal">The letter <em class="italics">s</em> is your <a id="_idIndexMarker023"/>present state, your present situation. The letter <em class="italics">a</em> is the<a id="_idIndexMarker024"/> action you're deciding, which is to go to the next location; there, you will be in another state, <em class="italics">s'</em>. We can say that<a id="_idIndexMarker025"/> thanks to the action <em class="italics">a</em>, you will go from <em class="italics">s</em> to <em class="italics">s'</em>.</p>
    <p class="normal">Now, imagine that the driver is not you anymore. You are tired for some reason. That is when a self-driving vehicle comes in handy. You set your car to autopilot. Now, you are no longer driving; the system is. Let's call that system the <strong class="bold">agent</strong>. At point <strong class="bold">F</strong>, you set your car to autopilot and let the self-driving agent take over.</p>
    <h3 id="_idParaDest-20" class="title">Watching the MDP agent at work</h3>
    <p class="normal">The self-driving AI is <a id="_idIndexMarker026"/>now in charge of the vehicle. It is acting as the MDP agent. This now sees what you have asked it to do and checks its <strong class="bold">mapping environment</strong>, which <a id="_idIndexMarker027"/>represents all the locations in the previous diagram from <strong class="bold">A</strong> to <strong class="bold">F</strong>.</p>
    <p class="normal">In the meantime, you are rightly worried. Is the agent going to make it or not? You are wondering whether its strategy meets yours. You <a id="_idIndexMarker028"/>have your <strong class="bold">policy</strong> <em class="italics">P</em>—your way of thinking—which is to take the shortest path possible. Will the agent agree? What's going on in its machine mind? You observe and begin to realize things you never noticed before. </p>
    <p class="normal">Since this is the first time you are using this car and guidance system, the agent is <strong class="bold">memoryless</strong>, which is an MDP feature. The agent doesn't know anything about what went on before. It seems to be happy with just calculating from this state <em class="italics">s</em> at location <strong class="bold">F</strong>. It will use machine power to run as many calculations as necessary to reach its goal.</p>
    <p class="normal">Another thing you are <a id="_idIndexMarker029"/>watching is the total distance from <strong class="bold">F</strong> to <strong class="bold">C</strong> to check whether things are OK. That means that the agent is calculating all the states from <strong class="bold">F</strong> to <strong class="bold">C</strong>.</p>
    <p class="normal">In this case, state <strong class="bold">F</strong> is state 1, which we can simplify by writing <em class="italics">s</em><sub>1</sub>; B is state 2, which we can simplify by writing <em class="italics">s</em><sub>2</sub>; D is <em class="italics">s</em><sub>3</sub>; and C is <em class="italics">s</em><sub>4</sub>. The agent is calculating all of these possible states to make a decision.</p>
    <p class="normal">The agent knows that when it reaches <strong class="bold">D</strong>, <strong class="bold">C</strong> will be better because the reward will be higher for going to C than anywhere else. Since it cannot eat a piece of cake to reward itself, the agent uses numbers. Our agent is a real number cruncher. When it is wrong, it gets a poor reward or nothing in this model. When it's right, it gets a reward represented by the letter <em class="italics">R</em>, which we'll encounter during step 2. This action-value (reward) transition, often named the Q function, is the core of many reinforcement learning algorithms.</p>
    <p class="normal">When our agent goes from one state to another, it performs a <em class="italics">transition</em> and gets a reward. For example, the transition can be from <strong class="bold">F</strong> to <strong class="bold">B</strong>, state 1 to state 2, or <em class="italics">s</em><sub>1</sub> to <em class="italics">s</em><sub>2</sub>.</p>
    <p class="normal">You are feeling great and are going to be on time. You are beginning to understand how the machine learning agent in your self-driving car is thinking. Suddenly, you look up and see that a traffic jam is building up. Location <strong class="bold">D</strong> is still far away, and now you do not know whether it would be good to go from <strong class="bold">D</strong> to <strong class="bold">C</strong> or <strong class="bold">D</strong> to <strong class="bold">E</strong>, in order to take another road to <strong class="bold">C</strong>, which involves less traffic. You are going to see what your agent thinks!</p>
    <p class="normal">The agent takes the traffic jam into account, is stubborn, and increases its reward to get to <strong class="bold">C</strong> by the shortest way. Its policy is to stick to the initial plan. You do not agree. You have another policy.</p>
    <p class="normal">You stop the car. You both have to agree before continuing. You have your opinion and policy; the agent does not agree. Before continuing, your views need to <strong class="bold">converge</strong>. <strong class="bold">Convergence</strong> is the <a id="_idIndexMarker030"/>key to making sure that your calculations are correct, and it's a way to evaluate the quality of a calculation.</p>
    <p class="normal">A mathematical representation is the best way to express this whole process at this point, which we will describe in the following step.</p>
    <h2 id="_idParaDest-21" class="title">Step 2 – building a mathematical model: the mathematical representation of the Bellman equation and MDP</h2>
    <p class="normal">Mathematics involves a<a id="_idIndexMarker031"/> whole change in your perspective of a problem. You are going from words to functions, the pillars of source coding.</p>
    <p class="normal">Expressing problems in <a id="_idIndexMarker032"/>mathematical notation<a id="_idIndexMarker033"/> does not mean getting lost in academic math to the point of never writing a single line of code. Just <a id="_idIndexMarker034"/>use mathematics to get a job done efficiently. Skipping mathematical representation will fast-track a few functions in the early stages of an AI project. However, when the real problems that occur in all AI projects surface, solving them with source code alone will prove virtually impossible. The goal here is to pick up enough mathematics to implement a solution in real-life companies.</p>
    <p class="normal">It is necessary to think through a problem by finding something familiar around us, such as the itinerary model covered early in this chapter. It is a good thing to write it down with some abstract letters and symbols as described before, with <em class="italics">a</em> meaning an action, and <em class="italics">s</em> meaning a state. Once you have understood the problem and expressed it clearly, you can proceed further.</p>
    <p class="normal">Now, mathematics will help to clarify the situation by means of shorter descriptions. With the main ideas in mind, it is time to convert them into equations.</p>
    <h3 id="_idParaDest-22" class="title">From MDP to the Bellman equation</h3>
    <p class="normal">In step 1, the agent went from <strong class="bold">F</strong>, or state 1 or <em class="italics">s</em>, to <strong class="bold">B</strong>, which was state 2 or <em class="italics">s'</em>.</p>
    <p class="normal">A strategy drove this decision—a policy represented by <em class="italics">P</em>. One mathematical expression contains the MDP state transition function:</p>
    <p class="center"><em class="italics">P</em><sub style="font-style: italic;">a</sub>(<em class="italics">s</em>, <em class="italics">s'</em>)</p>
    <p class="normal"><em class="italics">P</em> is the policy, the strategy made by the agent to go from <strong class="bold">F</strong> to <strong class="bold">B</strong> through action <em class="italics">a</em>. When going from <strong class="bold">F</strong> to <strong class="bold">B</strong>, this state transition is <a id="_idIndexMarker035"/>named the <strong class="bold">state transition function</strong>:</p>
    <ul>
      <li class="list"><em class="italics">a</em> is the action</li>
      <li class="list"><em class="italics">s</em> is state 1 (<strong class="bold">F</strong>), and <em class="italics">s'</em> is state 2 (<strong class="bold">B</strong>)</li>
    </ul>
    <p class="normal">The reward (right or wrong) matrix follows the same principle:</p>
    <p class="center"><em class="italics">R</em><sub style="font-style: italic;">a</sub>(<em class="italics">s</em>, <em class="italics">s'</em>)</p>
    <p class="normal">That means <em class="italics">R</em> is the reward for the action of going from state <em class="italics">s</em> to state <em class="italics">s'</em>. Going from one state to another will be a random process. Potentially, all states can go to any other state.</p>
    <p class="normal">Each line in the matrix in<a id="_idIndexMarker036"/> the example represents a letter from <strong class="bold">A</strong> to <strong class="bold">F</strong>, and each column represents a letter from <strong class="bold">A</strong> to <strong class="bold">F</strong>. All possible states are represented. The <code class="Code-In-Text--PACKT-">1</code> values represent the nodes (vertices) of the graph. Those are the possible locations. For example, line 1 represents the possible moves for letter <strong class="bold">A</strong>, line 2 for letter <strong class="bold">B</strong>, and line 6 for letter <strong class="bold">F</strong>. On the first line, <strong class="bold">A</strong> cannot go to <strong class="bold">C</strong> directly, so a <code class="Code-In-Text--PACKT-">0</code> value is entered. But, it can go to <strong class="bold">E</strong>, so a <code class="Code-In-Text--PACKT-">1</code> value is added.</p>
    <p class="normal">Some models start with <code class="Code-In-Text--PACKT-">-1</code> for impossible choices, such as <strong class="bold">B</strong> going directly to <strong class="bold">C</strong>, and <code class="Code-In-Text--PACKT-">0</code> values to define the locations. This model starts with <code class="Code-In-Text--PACKT-">0</code> and <code class="Code-In-Text--PACKT-">1</code> values. It sometimes takes weeks to design functions that will create a reward matrix (see <em class="italics">Chapter 2</em>, <em class="italics">Building a Reward Matrix – Designing Your Datasets</em>).</p>
    <p class="normal">The example we will be working on inputs a reward matrix so that the program can choose its best course of action. Then, the agent will go from state to state, learning the best trajectories for every possible starting location point. The goal of the MDP is to go to <strong class="bold">C</strong> (line 3, column 3 in the reward matrix), which has a starting value of 100 in the following Python code:</p>
    <pre class="programlisting"><code class="hljs angelscript"># Markov Decision Process (MDP) - The Bellman equations adapted to
# Reinforcement Learning
<span class="hljs-keyword">import</span> numpy as ql
# R <span class="hljs-keyword">is</span> The Reward Matrix <span class="hljs-keyword">for</span> each state
R = ql.matrix([ [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] ])
</code></pre>
    <p class="normal">Somebody familiar with Python might wonder why I used <code class="Code-In-Text--PACKT-">ql</code> instead of <code class="Code-In-Text--PACKT-">np</code>. Some might say "convention," "mainstream," "standard." My answer is a question. Can somebody define what "standard" AI is in this fast-moving world! My point here for the MDP is to use <code class="Code-In-Text--PACKT-">ql</code> as an abbreviation of "Q-learning" instead of the "standard" abbreviation of NumPy, which is <code class="Code-In-Text--PACKT-">np</code>. Naturally, beyond this special abbreviation for the MDP programs, I'll use <code class="Code-In-Text--PACKT-">np</code>. Just bear in mind that conventions are there to break so as to set ourselves free to explore new frontiers. Just make sure your program works well!</p>
    <p class="normal">There are several key properties of this decision process, among which there is the following:</p>
    <ul>
      <li class="list"><strong class="bold">The Markov property</strong>: The <a id="_idIndexMarker037"/>process does not take the past into account. It is the memoryless property of this decision process, just as you do in a car with a guidance system. You move forward to reach your goal.</li>
      <li class="list"><strong class="bold">Unsupervised learning</strong>: From this memoryless Markov property, it is safe to say that the MDP is <a id="_idIndexMarker038"/>not supervised learning. Supervised learning would mean that we would have all the labels of the reward matrix <em class="italics">R</em> and learn from them. We would know what <strong class="bold">A</strong> means and use that property to make a decision. We would, in the future, be looking at the past. MDP does not take these labels into account. Thus, MDP uses unsupervised learning to train. A decision has to be made in each state without knowing the past states or what they signify. It means that the car, for example, was on its own at each location, which is represented by each of its states.</li>
      <li class="list"><strong class="bold">Stochastic process</strong>: In step 1, when state <strong class="bold">D</strong> was reached, the agent controlling the mapping <a id="_idIndexMarker039"/>system and the driver didn't agree on where to go. A random choice could be made in a trial-and-error way, just like a coin toss. It is going to be a heads-or-tails process. The agent will toss the coin a significant number of times and measure the outcomes. That's precisely how MDP works and how the agent will learn.</li>
      <li class="list"><strong class="bold">Reinforcement learning</strong>: Repeating<a id="_idIndexMarker040"/> a trial-and-error process with feedback from the agent's environment.</li>
      <li class="list"><strong class="bold">Markov chain</strong>: The <a id="_idIndexMarker041"/>process of going from state to state with no history in a random, stochastic way is called a Markov chain.</li>
    </ul>
    <p class="normal">To sum it up, we have three tools:</p>
    <ul>
      <li class="list"><em class="italics">P</em><sub style="font-style: italic;">a</sub>(<em class="italics">s</em>, <em class="italics">s'</em>): A <strong class="bold">policy</strong>, <em class="italics">P</em>, or<a id="_idIndexMarker042"/> strategy to move from one state to another</li>
      <li class="list"><em class="italics">T</em><sub style="font-style: italic;">a</sub>(<em class="italics">s</em>, <em class="italics">s'</em>): A <em class="italics">T</em>, or <a id="_idIndexMarker043"/>stochastic (random) <strong class="bold">transition</strong>, function to carry out that action</li>
      <li class="list"><em class="italics">R</em><sub style="font-style: italic;">a</sub>(<em class="italics">s</em>, <em class="italics">s'</em>): An <em class="italics">R</em>, or <strong class="bold">reward</strong>, for<a id="_idIndexMarker044"/> that action, which can be negative, null, or positive</li>
    </ul>
    <p class="normal"><em class="italics">T</em> is the transition function, which makes the agent decide to go from one point to another with a policy. In this case, it will be random. That's what machine power is for, and that is how reinforcement learning is often implemented.</p>
    <h4 class="title">Randomness</h4>
    <p class="normal">Randomness is a key <a id="_idIndexMarker045"/>property of MDP, defining it as a stochastic process.</p>
    <p class="normal">The following code describes the choice the <strong class="bold">agent</strong> is going to make:</p>
    <pre class="programlisting"><code class="hljs lisp">next_action = int(<span class="hljs-name">ql</span>.random.choice(<span class="hljs-name">PossibleAction</span>,<span class="hljs-number">1</span>))
return next_action
</code></pre>
    <p class="normal">The code selects a new random action (state) at each episode.</p>
    <h4 class="title">The Bellman equation</h4>
    <p class="normal">The Bellman equation<a id="_idIndexMarker046"/> is the road to programming reinforcement learning.</p>
    <p class="normal">The Bellman equation completes the MDP. To calculate the value of a state, let's use <em class="italics">Q</em>, for the <em class="italics">Q</em> action-reward (or value) function. The pseudo source code of the Bellman equation can be expressed as follows for one individual state:</p>
    <figure class="mediaobject"><img src="../Images/B15438_01_001.png" alt=""/></figure>
    <p class="normal">The source code then translates the equation into a machine representation, as in the following code:</p>
    <pre class="programlisting"><code class="hljs fortran"># The Bellman equation
    Q[current_state, <span class="hljs-keyword">action</span>] = R[current_state, <span class="hljs-keyword">action</span>] +
        <span class="hljs-built_in">gamma</span> * MaxValue
</code></pre>
    <p class="normal">The source code variables of the Bellman equation are as follows:</p>
    <ul>
      <li class="list"><em class="italics">Q</em>(<em class="italics">s</em>): This is the value calculated for this state—the total reward. In step 1, when the agent went from <strong class="bold">F</strong> to <strong class="bold">B</strong>, the reward was a number such as 50 or 100 to show the agent that it's on the right track.</li>
      <li class="list"><em class="italics">R</em>(<em class="italics">s</em>): This is the sum of the values up to that point. It's the total reward at that point.</li>
      <li class="list"><img style="height: 0.8em !important" src="../Images/B15438_01_002.png" alt=""/>: This is here to remind us that trial and error has a price. We're wasting time, money, and energy. Furthermore, we don't even know whether the next step is right or wrong since we're in a trial-and-error mode. <strong class="bold">Gamma</strong> is<a id="_idIndexMarker047"/> often set to 0.8. What does that mean? Suppose you're taking an exam. You study and study, but you don't know the outcome. You might have 80 out of 100 (0.8) chances of clearing it. That's painful, but that's life. The <strong class="bold">gamma</strong> penalty, or learning rate, makes the Bellman equation realistic and efficient.</li>
      <li class="list">max(<em class="italics">s'</em>): <em class="italics">s'</em> is one of the possible states that can be reached with <em class="italics">P</em><sub style="font-style: italic;">a</sub>(<em class="italics">s</em>, <em class="italics">s'</em>); max is the highest value on the line of that state (location line in the reward matrix).</li>
    </ul>
    <p class="normal">At this point, you have done two-thirds of the job: understanding the real-life (process) and representing it in basic mathematics. You've built the mathematical model that describes your learning process, and you can implement that solution in code. Now, you are ready to code!</p>
    <h2 id="_idParaDest-23" class="title">Step 3 – writing source code: implementing the solution in Python</h2>
    <p class="normal">In step 1, a problem was <a id="_idIndexMarker048"/>described in natural language to be able to talk to experts and understand what was expected. In step 2, an essential mathematical bridge was built between natural language and source coding. Step 3 is the software implementation phase.</p>
    <p class="normal">When a problem comes up—and rest assured that one always does—it will be possible to go back over the mathematical bridge with the customer or company team, and even further back to the natural language process if necessary.</p>
    <p class="normal">This method guarantees success for any project. The code in this chapter is in Python 3.x. It is a reinforcement learning program using the Q function with the following reward matrix:</p>
    <pre class="programlisting"><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as ql
R = ql.matrix([ [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] ])
Q = ql.matrix(ql.zeros([<span class="hljs-number">6</span>,<span class="hljs-number">6</span>]))
gamma = <span class="hljs-number">0.8</span>
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">R</code> is the reward matrix described in the mathematical analysis.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Q</code> inherits the same structure as <code class="Code-In-Text--PACKT-">R</code>, but all values are set to <code class="Code-In-Text--PACKT-">0</code> since this is a learning matrix. It will progressively contain the results of the decision process. The <code class="Code-In-Text--PACKT-">gamma</code> variable is a double reminder that the system is learning and that its decisions have only an 80% chance of being correct each time. As the following code shows, the system explores the possible actions during the process:</p>
    <pre class="programlisting"><code class="hljs pf">agent_s_state = <span class="hljs-number">1</span>
<span class="hljs-comment"># The possible "a" actions when the agent is in a given state</span>
def possible_actions(<span class="hljs-keyword">state</span>):
    current_state_row = R[<span class="hljs-keyword">state</span>,]
    possible_act = ql.where(current_state_row &gt;<span class="hljs-number">0</span>)[<span class="hljs-number">1</span>]
    return possible_act
<span class="hljs-comment"># Get available actions in the current state</span>
PossibleAction = possible_actions(agent_s_state)
</code></pre>
    <p class="normal">The agent starts in state 1, for example. You can start wherever you want because it's a random process. Note that the process only takes values &gt; 0 into account. They represent possible moves (decisions).</p>
    <p class="normal">The current state goes through an analysis process to find possible actions (next possible states). You will note that there is no algorithm in the traditional sense with many rules. It's a pure random calculation, as the following <code class="Code-In-Text--PACKT-">random.choice</code> function shows:</p>
    <pre class="programlisting"><code class="hljs angelscript">def ActionChoice(available_actions_range):
    <span class="hljs-keyword">if</span>(sum(PossibleAction)&gt;<span class="hljs-number">0</span>):
        next_action = <span class="hljs-built_in">int</span>(ql.random.choice(PossibleAction,<span class="hljs-number">1</span>))
    <span class="hljs-keyword">if</span>(sum(PossibleAction)&lt;=<span class="hljs-number">0</span>):
        next_action = <span class="hljs-built_in">int</span>(ql.random.choice(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>))
    <span class="hljs-keyword">return</span> next_action
# Sample next action to be performed
action = ActionChoice(PossibleAction)
</code></pre>
    <p class="normal">Now comes the core of the<a id="_idIndexMarker049"/> system containing the Bellman equation, translated into the following source code:</p>
    <pre class="programlisting"><code class="hljs fortran">def reward(current_state, <span class="hljs-keyword">action</span>, <span class="hljs-built_in">gamma</span>):
    Max_State = ql.<span class="hljs-keyword">where</span>(Q[<span class="hljs-keyword">action</span>,] == ql.<span class="hljs-built_in">max</span>(Q[<span class="hljs-keyword">action</span>,]))[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> Max_State.<span class="hljs-built_in">shape</span>[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
        Max_State = <span class="hljs-built_in">int</span>(ql.random.choice(Max_State, <span class="hljs-built_in">size</span> = <span class="hljs-number">1</span>))
    <span class="hljs-keyword">else</span>:
        Max_State = <span class="hljs-built_in">int</span>(Max_State)
    MaxValue = Q[<span class="hljs-keyword">action</span>, Max_State]
    
    # Q <span class="hljs-function"><span class="hljs-keyword">function</span></span>
    Q[current_state, <span class="hljs-keyword">action</span>] = R[current_state, <span class="hljs-keyword">action</span>] +
        <span class="hljs-built_in">gamma</span> * MaxValue
# Rewarding Q matrix
reward(agent_s_state,<span class="hljs-keyword">action</span>,<span class="hljs-built_in">gamma</span>)
</code></pre>
    <p class="normal">You can see that the agent looks for the maximum value of the next possible state chosen at random.</p>
    <p class="normal">The best way to understand this is to run the program in your Python environment and <code class="Code-In-Text--PACKT-">print()</code> the intermediate values. I suggest that you open a spreadsheet and note the values. This will give you a clear view of the process.</p>
    <p class="normal">The last part is simply about running the learning process 50,000 times, just to be sure that the system learns everything there is to find. During each iteration, the agent will detect its present state, choose <a id="_idIndexMarker050"/>a course of action, and update the Q function matrix:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(50000):
    current_state = ql.random.randint(0, int(Q.shape[0]))
    PossibleAction = possible_actions(current_state)
    action = ActionChoice(PossibleAction)
    reward(current_state,action,gamma)
    
<span class="hljs-comment"># Displaying Q before the norm of Q phase</span>
<span class="hljs-builtin-name">print</span>(<span class="hljs-string">"Q :"</span>)
<span class="hljs-builtin-name">print</span>(Q)
<span class="hljs-comment"># Norm of Q</span>
<span class="hljs-builtin-name">print</span>(<span class="hljs-string">"Normed Q :"</span>)
<span class="hljs-builtin-name">print</span>(Q/ql.max(Q)<span class="hljs-number">*100</span>)
</code></pre>
    <p class="normal">The process continues until the learning process is over. Then, the program will print the result in <code class="Code-In-Text--PACKT-">Q</code> and the normed result. The normed result is the process of dividing all values by the sum of the values found. <code class="Code-In-Text--PACKT-">print(Q/ql.max(Q)*100)</code> norms <code class="Code-In-Text--PACKT-">Q</code> by dividing <code class="Code-In-Text--PACKT-">Q</code> by <code class="Code-In-Text--PACKT-">q1.max(Q)*100</code>. The result comes out as a normed percentage.</p>
    <p class="normal">You can run the process with <code class="Code-In-Text--PACKT-">mdp01.py</code>.</p>
    <h1 id="_idParaDest-24" class="title">The lessons of reinforcement learning</h1>
    <p class="normal">Unsupervised<a id="_idIndexMarker051"/> reinforcement machine learning, such as the MDP-driven Bellman equation, is toppling traditional decision-making software location by location. Memoryless reinforcement learning requires few to no business rules and, thus, doesn't require human knowledge to run.</p>
    <p class="normal">Being an adaptive next-generation AI thinker involves three prerequisites: the effort to be an SME, working on mathematical models to think like a machine, and understanding your source code's potential and limits.</p>
    <p class="normal">Machine power and reinforcement learning teach us two important lessons:</p>
    <ul>
      <li class="list"><strong class="bold">Lesson 1</strong>: Machine learning through reinforcement learning can beat human intelligence in many cases. No use fighting! The technology and solutions are already here in strategic domains.</li>
      <li class="list"><strong class="bold">Lesson 2</strong>: A machine has no emotions, but you do. And so do the people around you. Human emotions and teamwork are an essential asset. Become an SME for your team. Learn how to understand what they're trying to say intuitively and make a mathematical representation of it for them. Your job will never go away, even if you're setting up solutions that don't require much development, such as AutoML. AutoML, or automated machine learning, automates many tasks. AutoML automates functions such as the dataset pipeline, hyperparameters, and more. Development is partially or totally suppressed. But you still have to make sure the whole system is well designed.</li>
    </ul>
    <p class="normal">Reinforcement learning<a id="_idIndexMarker052"/> shows that no human can solve a problem the way a machine does. 50,000 iterations with random searching is not an option for a human. The number of empirical episodes can be reduced dramatically with a numerical convergence form of gradient descent (see <em class="italics">Chapter 3</em>, <em class="italics">Machine Intelligence – Evaluation Functions and Numerical Convergence</em>).</p>
    <p class="normal">Humans need to be more intuitive, make a few decisions, and see what happens, because humans cannot try thousands of ways of doing something. Reinforcement learning marks a new era for human thinking by surpassing human reasoning power in strategic fields.</p>
    <p class="normal">On the other hand, reinforcement<a id="_idIndexMarker053"/> learning requires mathematical models to function. Humans excel in mathematical abstraction, providing powerful intellectual fuel to those powerful machines.</p>
    <p class="normal">The boundaries between humans and machines have changed. Humans' ability to build mathematical models and ever-growing cloud platforms will serve online machine learning services.</p>
    <p class="normal">Finding out how to use the outputs of the reinforcement learning program we just studied shows how a human will always remain at the center of AI.</p>
    <h2 id="_idParaDest-25" class="title">How to use the outputs</h2>
    <p class="normal">The reinforcement program <a id="_idIndexMarker054"/>we studied contains no trace of a specific field, as in traditional software. The program contains the Bellman equation with stochastic (random) choices based on the reward matrix. The goal is to find a route to <strong class="bold">C</strong> (line 3, column 3) that has an attractive reward (<code class="Code-In-Text--PACKT-">100</code>):</p>
    <pre class="programlisting"><code class="hljs angelscript"># Markov Decision Process (MDP) – The Bellman equations adapted to
# Reinforcement Learning with the Q action-value(reward) matrix
<span class="hljs-keyword">import</span> numpy as ql
# R <span class="hljs-keyword">is</span> The Reward Matrix <span class="hljs-keyword">for</span> each state
R = ql.matrix([ [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="highlight"><span class="hljs-number">100</span></span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] ])
</code></pre>
    <p class="normal">That reward matrix goes through the Bellman equation and produces a result in Python:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-attr">Q :</span>
<span class="hljs-string">[[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">258.44</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">321.8</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">207.752</span><span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">500</span><span class="hljs-string">.</span> <span class="hljs-number">321.8</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">258.44</span> <span class="hljs-number">401</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">258.44</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">207.752</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">321.8</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">258.44</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]]</span>
<span class="hljs-attr">Normed Q :</span>
<span class="hljs-string">[[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">51.688</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">64.36</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">41.5504</span><span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">100</span><span class="hljs-string">.</span> <span class="hljs-number">64.36</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">51.688</span> <span class="hljs-number">80.2</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">51.688</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">41.5504</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">64.36</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]</span>
 <span class="hljs-string">[</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">51.688</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-number">0</span><span class="hljs-string">.</span> <span class="hljs-string">]]</span>
</code></pre>
    <p class="normal">The result contains the values of each state produced by the reinforced learning process, and also a normed <code class="Code-In-Text--PACKT-">Q</code> (the highest value divided by other values).</p>
    <p class="normal">As Python geeks, we are overjoyed! We made something that is rather difficult work, namely, reinforcement learning. As mathematical amateurs, we are elated. We know what MDP and the Bellman equation mean.</p>
    <p class="normal">However, as natural language thinkers, we have made little progress. No customer or user can read that data and make sense of it. Furthermore, we cannot explain how we implemented an intelligent version of their job in the machine. We didn't.</p>
    <p class="normal">We hardly <a id="_idIndexMarker055"/>dare say that reinforcement learning can beat anybody in the company, making random choices 50,000 times until the right answer came up.</p>
    <p class="normal">Furthermore, we got the program to work, but hardly know what to do with the result ourselves. The consultant on the project cannot help because of the matrix format of the solution.</p>
    <p class="normal">Being an adaptive thinker means knowing how to be good in all steps of a project. To solve this new problem, let's go back to step 1 with the result. Going back to step 1 means that if you have problems either with the results themselves or understanding them, it is necessary to go back to the SME level, the real-life situation, and see what is going wrong.</p>
    <p class="normal">By formatting the result in Python, a graphics tool, or a spreadsheet, the result can be  displayed as follows:</p>
    <table id="table001-1" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <strong class="heading">A</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">B</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">C</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">D</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">E</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">F</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">A</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">258.44</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">B</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">321.8</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">207.752</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">C</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">500</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">321.8</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">D</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">258.44</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">401.</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">258.44</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">E</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">207.752</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">321.8</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">F</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">258.44</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Now, we can start reading the solution:</p>
    <ul>
      <li class="list">Choose a starting state. Take <strong class="bold">F</strong>, for example.</li>
      <li class="list">The <strong class="bold">F</strong> line represents the state. Since the maximum value is 258.44 in the <strong class="bold">B</strong> column, we go to state <strong class="bold">B</strong>, the second line.</li>
      <li class="list">The maximum value in state <strong class="bold">B</strong> in the second line leads us to the <strong class="bold">D</strong> state in the  fourth column.</li>
      <li class="list">The highest maximum of the <strong class="bold">D</strong> state (fourth line) leads us to the <strong class="bold">C</strong> state.</li>
    </ul>
    <p class="normal">Note that if you start at the <strong class="bold">C</strong> state and decide not to stay at <strong class="bold">C</strong>, the <strong class="bold">D</strong> state becomes the maximum value, which will lead you back to <strong class="bold">C</strong>. However, the MDP will never do this naturally. You will have to force the system to do it.</p>
    <p class="normal">You have now obtained a sequence: <strong class="bold">F</strong>-&gt;<strong class="bold">B</strong>-&gt;<strong class="bold">D</strong>-&gt;<strong class="bold">C</strong>. By choosing other points of departure, you can obtain other sequences by simply sorting the table.</p>
    <p class="normal">A useful way of putting it remains the normalized version in percentages, as shown in the following table:</p>
    <table id="table002" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <strong class="heading">A</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">B</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">C</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">D</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">E</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">F</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">A</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">51.68%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">B</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">64.36%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">41.55%</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">C</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">100%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">64.36%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">D</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">51.68%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">80.2%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">51.68%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">E</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">41.55%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">64.36%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">F</strong>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">51.68%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">-</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Now comes the very tricky part. We started the chapter with a trip on the road. But I made no mention of it in the results analysis.</p>
    <p class="normal">An important property of <a id="_idIndexMarker056"/>reinforcement learning comes from the fact that we are working with a mathematical model that can be applied to anything. No human rules are needed. We can use this program for many other subjects without writing thousands of lines of code.</p>
    <h3 id="_idParaDest-26" class="title">Possible use cases</h3>
    <p class="normal">There are many cases to<a id="_idIndexMarker057"/> which we could adapt our reinforcement learning model without having to change any of its details.</p>
    <h4 class="title">Case 1: optimizing a delivery for a driver, human or not</h4>
    <p class="normal">This model was described in this chapter.</p>
    <h4 class="title">Case 2: optimizing warehouse flows</h4>
    <p class="normal">The same reward matrix can apply to go from point <strong class="bold">F</strong> to <strong class="bold">C</strong> in a warehouse, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B15438_01_03.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_01_02.png"/></figure>
    <p class="packt_figref">Figure 1.3: A diagram illustrating a warehouse flow problem</p>
    <p class="normal">In this warehouse, the <strong class="bold">F</strong>-&gt;<strong class="bold">B</strong>-&gt;<strong class="bold">D</strong>-&gt;<strong class="bold">C</strong> sequence makes visual sense. If somebody goes from point <strong class="bold">F</strong> to <strong class="bold">C</strong>, then this physical path makes sense without going through walls.</p>
    <p class="normal">It can be used for a video game, a factory, or any form of layout.</p>
    <h4 class="title">Case 3: automated planning and scheduling (APS)</h4>
    <p class="normal">By converting the <a id="_idIndexMarker058"/>system into a scheduling vector, the whole scenery changes. We have left the more comfortable world of physical processing of letters, faces, and trips. Though fantastic, those applications are social media's tip of the iceberg. The real challenge of AI begins in the abstract universe of human thinking.</p>
    <p class="normal">Every single company, person, or system requires automatic planning and scheduling (see <em class="italics">Chapter 12</em>, <em class="italics">AI and the Internet of Things (IoT)</em>). The six <strong class="bold">A</strong> to <strong class="bold">F</strong> steps in the example of this chapter could well be six tasks to perform in a given unknown order represented by the following vector <em class="italics">x</em>:</p>
    <figure class="mediaobject"><img style="height: 7em !important" src="../Images/B15438_01_003.png" alt=""/></figure>
    <p class="normal">The reward matrix then reflects the weights of constraints of the tasks of vector <em class="italics">x</em> to perform. For example, in a factory, you cannot assemble the parts of a product before manufacturing them.</p>
    <p class="normal">In this case, the sequence obtained represents the schedule of the manufacturing process.</p>
    <h4 class="title">Cases 4 and more: your imagination</h4>
    <p class="normal">By using physical layouts or abstract decision-making vectors, matrices, and tensors, you can build a world of solutions in a mathematical reinforcement learning model. Naturally, the following chapters will enhance your toolbox with many other concepts.</p>
    <p class="normal">Before moving on, you might want to imagine some situations in which you could use the A to F letters to express some kind of path.</p>
    <p class="normal">To help you with these mind experiment simulations, open <code class="Code-In-Text--PACKT-">mdp02.py</code> and go to line 97, which starts with the following code that enables a simulation tool. <code class="Code-In-Text--PACKT-">nextc</code> and <code class="Code-In-Text--PACKT-">nextci</code> are simply variables to remember where the path begins and will end. They are set to <code class="Code-In-Text--PACKT-">-1</code> so as to avoid 0, which is a location.</p>
    <p class="normal">The primary goal is to focus on the expression "concept code." The locations have become any concept you wish. A could be your bedroom, and C your kitchen. The path would go from where you wake up to where you have breakfast. A could be an idea you have, and F the end of a thinking process. The path would go from A (How can I hang this picture on the wall?) to E (I need to drill a hole) and, after a few phases, to F (I hung the picture on the wall). You can imagine thousands of paths like this as long as you define the reward matrix, the "concept code," and a starting point:</p>
    <pre class="programlisting"><code class="hljs awk"><span class="hljs-string">"""# Improving the program by introducing a decision-making process"""</span>
nextc=-<span class="hljs-number">1</span>
nextci=-<span class="hljs-number">1</span>
conceptcode=[<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"F"</span>]
</code></pre>
    <p class="normal">This code takes the result of the calculation, labels the result matrix, and accepts an input as shown in the following code snippet:</p>
    <pre class="programlisting"><code class="hljs isbl"><span class="hljs-variable">origin</span>=<span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-title">input</span>(
    <span class="hljs-string">"index number origin(A=0,B=1,C=2,D=3,E=4,F=5): "</span>))</span>
</code></pre>
    <p class="normal">The input only accepts the <a id="_idIndexMarker059"/>label numerical code: <code class="Code-In-Text--PACKT-">A=0</code>, <code class="Code-In-Text--PACKT-">B=1</code> … <code class="Code-In-Text--PACKT-">F=5</code>. The function then runs a classical calculation on the results to find the best path. Let's takes an example.</p>
    <p class="normal">When you are prompted to enter a starting point, enter <code class="Code-In-Text--PACKT-">5</code>, for example, as follows:</p>
    <pre class="programlisting"><code class="hljs angelscript">index number origin(A=<span class="hljs-number">0</span>,B=<span class="hljs-number">1</span>,C=<span class="hljs-number">2</span>,D=<span class="hljs-number">3</span>,E=<span class="hljs-number">4</span>,F=<span class="hljs-number">5</span>): <span class="hljs-number">5</span>
</code></pre>
    <p class="normal">The program will then produce the optimal path based on the output of the MDP process, as shown in the following output:</p>
    <pre class="programlisting"><code class="hljs coq">Concept <span class="hljs-keyword">Path</span>
-&gt; F
-&gt; B
-&gt; D
-&gt; C
</code></pre>
    <p class="normal">Try multiple scenarios and possibilities. Imagine what you could apply this to:</p>
    <ul>
      <li class="list">An e-commerce website flow (visit, cart, checkout, purchase) imagining that a user visits the site and then resumes a session at a later time. You can use the same reward matrix and "concept code" explored in this chapter. For example, a visitor visits a web page at 10 a.m., starting at point A of your website. Satisfied with a product, the visitor puts the product in a cart, which is point E of your website. Then, the visitor leaves the site before going to the purchase page, which is C. D is the critical point. Why didn't the visitor purchase the product? What's going on? <p class="list">You can decide to have an automatic email sent after 24 hours saying: "There is a 10% discount on all purchases during the next 48 hours." This way, you will target all the visitors stuck at D and push them toward C.</p>
      </li>
      <li class="list">A sequence of possible words in a sentence (subject, verb, object). Predicting letters and words was one of Andrey Markov's first applications 100+ years ago! You can imagine that B is the letter "a" of the alphabet. If D is "t," it is much more probable than F if F is "o," which is less probable in the English language. If an MDP reward matrix is built such as B leads to D or F, B can thus either go<a id="_idIndexMarker060"/> to D or to F. There are thus two possibilities, D or F. Andrey Markov would suppose, for example, that B is a variable that represents the letter "a," D is a variable that represents the letter "t" and F is a variable that represents the letter "o." After studying the structure of a language closely, he would find that the letter "a" would more likely be followed by "t" than by "o" in the English language. If one observes the English language, it is more likely to find an "a-t" sequence than an "a-o" sequence. In a Markov decision process, a higher probability will be awarded to the "a-t" sequence and a lower one to "a-o." If one goes back to the variables, the B-D sequence will come out as more probable than the B-F sequence.</li>
      <li class="list">And anything you can find that fits the model that works is great!</li>
    </ul>
    <h2 id="_idParaDest-27" class="title">Machine learning versus traditional applications</h2>
    <p class="normal">Reinforcement learning based <a id="_idIndexMarker061"/>on stochastic (random) processes will <a id="_idIndexMarker062"/>evolve beyond traditional approaches. In the past, we would sit down and listen to future users to understand their way of thinking.</p>
    <p class="normal">We would then go back to our keyboard and try to imitate the human way of thinking. Those days are over. We need proper datasets and ML/DL equations to move forward. Applied mathematics has taken reinforcement learning to the next level. In my opinion, traditional software will soon be in the museum of computer science. The complexity of the huge volumes of data we are facing will require AI at some point.</p>
    <p class="normal">An artificial adaptive thinker sees the world through applied mathematics translated into machine representations.</p>
    <p class="normal">Use the Python source code example provided in this chapter in different ways. Run it and try to change some parameters to see what happens. Play around with the number of iterations as well. Lower the number from 50,000 down to where you find it fits best. Change the reward matrix a little to see what happens. Design your reward matrix trajectory. This can be an itinerary or decision-making process.</p>
    <h1 id="_idParaDest-28" class="title">Summary</h1>
    <p class="normal">Presently, AI is predominantly a branch of applied mathematics, not of neurosciences. You must master the basics of linear algebra and probabilities. That's a difficult task for a developer used to intuitive creativity. With that knowledge, you will see that humans cannot rival machines that have CPU and mathematical functions. You will also understand that machines, contrary to the hype around you, don't have emotions; although we can represent them to a scary point in chatbots (see <em class="italics">Chapter 16, Improving the Emotional Intelligence Deficiencies of Chatbots</em>).</p>
    <p class="normal">A multi-dimensional approach is a prerequisite in an AI/ML/DL project. First, talk and write about the project, then make a mathematical representation, and finally go for software production (setting up an existing platform or writing code). In real life, AI solutions do not just grow spontaneously in companies as some hype would have us believe. You need to talk to the teams and work with them. That part is the real fulfilling aspect of a project—imagining it first and then implementing it with a group of real-life people.</p>
    <p class="normal">MDP, a stochastic random action-reward (value) system enhanced by the Bellman equation, will provide effective solutions to many AI problems. These mathematical tools fit perfectly in corporate environments.</p>
    <p class="normal">Reinforcement learning using the Q action-value function is memoryless (no past) and unsupervised (the data is not labeled or classified). MDP provides endless avenues to solve real-life problems without spending hours trying to invent rules to make a system work.</p>
    <p class="normal">Now that you are at the heart of Google's DeepMind approach, it is time to go to <em class="italics">Chapter 2</em>, <em class="italics">Building a Reward Matrix – Designing Your Datasets</em>, and discover how to create the reward matrix in the first place through explanations and source code.</p>
    <h1 id="_idParaDest-29" class="title">Questions</h1>
    <p class="normal">The answers to the questions are in <em class="italics">Appendix B</em>, with further explanations:</p>
    <ol>
      <li class="list">Is reinforcement learning memoryless? (Yes | No)</li>
      <li class="list">Does reinforcement learning use stochastic (random) functions? (Yes | No)</li>
      <li class="list">Is MDP based on a rule base? (Yes | No)</li>
      <li class="list">Is the Q function based on the MDP? (Yes | No)</li>
      <li class="list">Is mathematics essential to AI? (Yes | No)</li>
      <li class="list">Can the Bellman-MDP process in this chapter apply to many problems? (Yes | No)</li>
      <li class="list">Is it impossible for a machine learning program to create another program by itself? (Yes | No)</li>
      <li class="list">Is a consultant required to enter business rules in a reinforcement learning program? (Yes | No)</li>
      <li class="list">Is reinforcement learning supervised or unsupervised? (Supervised | Unsupervised)</li>
      <li class="list">Can Q-learning run without a reward matrix? (Yes | No)</li>
    </ol>
    <h1 id="_idParaDest-30" class="title">Further reading</h1>
    <ul>
      <li class="list">Andrey Markov: <a href="https://www.britannica.com/biography/Andrey-Andreyevich-Markov"><span class="url">https://www.britannica.com/biography/Andrey-Andreyevich-Markov</span></a></li>
      <li class="list">The Markov process: <a href="https://www.britannica.com/science/Markov-process"><span class="url">https://www.britannica.com/science/Markov-process</span></a></li>
    </ul>
  </div>
</body></html>