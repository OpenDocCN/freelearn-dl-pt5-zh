<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Neural Networks for Neural Search</h1>
<p>Search <a id="_idIndexMarker000"/>has always been a crucial part of all information systems; getting the right information to the right user is integral. This is because a user query, as in a set of keywords, cannot fully represent a user’s information needs. Traditionally, symbolic search<a id="_idIndexMarker001"/> has been developed to allow users to perform keyword-based searches. However, such search applications were bound to a text-based search box. With the recent developments in deep learning and artificial intelligence, we can encode any kind of data into vectors and measure the similarities between two vectors. This allows users to create a query with any kind of data and get any kind of search result.</p>
<p>In this chapter, we will review important concepts regarding information retrieval and neural search, as well as looking at the benefits that neural search provides to developers. Before we start introducing neural search, we will first introduce the drawbacks of the traditional symbolic-based search. Then, we’ll move on to looking at how to use neural networks in order to build a cross/multi-modality search. This will include looking at its major applications.</p>
<p>In this chapter, we’re going to cover the following main topics in particular:</p>
<ul>
<li>Legacy search versus neural search</li>
<li>Machine learning for search</li>
<li>Practical applications for neural search</li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
<p>This chapter has the following technical requirements:</p>
<ul>
<li><strong class="bold">Hardware</strong>: A desktop or laptop computer with a minimum of 4 GB of RAM; 8 GB is suggested</li>
<li><strong class="bold">Operating system</strong>: A Unix-like operating system such as macOS, or any Linux-based distribution, such as Ubuntu</li>
<li><strong class="bold">Programming Language</strong>: Python 3.7 or higher, and Python Package Installer, or pip</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Legacy search versus neural search</h1>
<p>This<a id="_idIndexMarker002"/> section will guide you through the fundamentals<a id="_idIndexMarker003"/> of symbolic search systems, the different types of search applications, and their importance. This is followed by a brief description of how the symbolic search system works, with some code written in Python. Last but not least, we’ll summarize the pros and cons of the traditional symbolic search versus neural search. This will help us to understand how a neural search can better bridge the gap between a user’s intent and the retrieved documents.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Exploring various data types and search scenarios</h2>
<p>In today’s society, governments, enterprises, and individuals create a huge amount of data by using various platforms every day. We live in the era of big data, where things such as texts, images, videos, and audio files play a significant role in society and the fulfillment of daily tasks. </p>
<p>Generally speaking, there are three types of data:</p>
<ul>
<li><strong class="bold">Structured data:</strong> This<a id="_idIndexMarker004"/> includes data that is logically expressed and realized by a<a id="_idIndexMarker005"/> two-dimensional table structure. Structured data strictly follows a specific data format and length specifications and is mainly stored and managed using relational databases.</li>
<li><strong class="bold">Unstructured data:</strong> This has<a id="_idIndexMarker006"/> neither a regular or complete structure<a id="_idIndexMarker007"/> nor a predefined data model. This type of data is not appropriately managed by representing the data using a two-dimensional logical table used in databases. This includes office documents, text, pictures, hypertext markup language (HTML), various reports, images, and audio and video information in all formats. </li>
<li><strong class="bold">Semi-structured data:</strong> This <a id="_idIndexMarker008"/>falls somewhere between <a id="_idIndexMarker009"/>structured and<a id="_idIndexMarker010"/> unstructured data. It includes log files, <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>), and <strong class="bold">Javascript Object Notation</strong> (<strong class="bold">JSON</strong>). Semi-structured data does not conform to the data model structure associated with relational databases or other data tables, but it contains relevant tags that can be used to separate semantic elements that are used to stratify records and fields. </li>
</ul>
<p>Search indices<a id="_idIndexMarker011"/> are widely used to hunt for unstructured and semi-structured data within a massive data collection to meet the information needs of users. Based on the levels and applications of the document collection, searches can be further divided into three types: web search, enterprise search, and personal search. </p>
<p>In a <strong class="bold">web search</strong>, the <a id="_idIndexMarker012"/>search engine first needs to index hundreds of millions of documents. The search results are then returned to users in an efficient manner while the system is continuously optimized. Typical examples of web search applications are Google, Bing, and Baidu. </p>
<p>In addition to web search, as a software development engineer, you are likely to encounter <em class="italic">enterprise</em> and <em class="italic">personal search</em> operations. In enterprise search scenarios, the<a id="_idIndexMarker013"/> search engine<a id="_idIndexMarker014"/> indexes internal documents of an enterprise to serve the employees and customers of the business, such as an internal patent search index of a company, or the search index of a music platform, such as SoundCloud. </p>
<p>If you are developing an email application and intend to allow users to search for historical emails, this constitutes a typical example of a personal search. This book focuses on enterprise and personal types of search operations.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Make sure<a id="_idIndexMarker015"/> you understand the difference between search and match. Search, in most cases, is done in documents organized in an unstructured or semi-structured<a id="_idIndexMarker016"/> format, while match (such as an SQL-like query) takes place on structured data, such as tabular data.</p>
<p>As for different data types, the concept of modality plays an important role in a search system. Modality<a id="_idIndexMarker017"/> refers to the form of information such as text, images, video, and audio files. Cross-modality search (also known as <em class="italic">cross-media search</em>) refers to retrieving<a id="_idIndexMarker018"/> samples from different modes with similar semantics by exploring the relationship between different modalities and employing a certain modal sample.</p>
<p>For example, when we enter a keyword in an email inbox application, we can find the appropriate email returns as a result of a unimodal search – searching text by text. When you enter a keyword on a page for image retrieval, the search engine will return appropriate images as a result of a cross-modal search, searching images by text. </p>
<p>Of course, a unimodal search<a id="_idIndexMarker019"/> is not limited to searching text by text. The app known as Shazam, which is popular in the App Store, helps users to identify music and returns a track’s title to users in a short time. This can be seen as an application of unimodal search. Here, the concept of modality no longer refers to text, but to audio. On Pinterest, users can locate similar images through an image search, where the modality refers to an image. Likewise, the scope of a cross-modal search covers far more than searching for images by text.</p>
<p>Let’s consider this from another perspective. Is it possible for us to search across multiple modalities? Of course, the answer is “Yes!” Imagine a search scenario where a user uploads a photo of clothes and wants to look for similar types of clothing (we usually call this type of application “shop the look”), and at the same time enters a paragraph that describes the clothes in the search box to improve the accuracy of the search. In this way, our search keywords span two modalities (text and images). We refer to this search scenario as a multi-modal search.</p>
<p>Now that we have a grasp of the concept of modality, we will elaborate on the working principles, advantages, and disadvantages of symbolic search systems. By the end of this section, you will understand, that symbolic search systems cannot deal with different modalities.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>How does the traditional search system work?</h2>
<p>As a <a id="_idIndexMarker020"/>developer, you may have used Elasticsearch or Apache Solr to build a search system in web applications. These two widely used search frameworks were developed based on Apache Lucene. We’ll take Lucene as a case in point to introduce the components of a search system. Imagine you intend to search for a keyword in thousands of text documents (<strong class="source-inline">txt</strong>). How will you complete this task? </p>
<p>The easiest solution is to traverse all text documents from a path and read through the contents of these documents. If the keyword is in the file, the name of the document will be returned:</p>
<pre class="source-code"># src/chapter-1/sequential_match.py
import os
import glob
dir_path = os.path.dirname(os.path.realpath(__file__))
def match_sequentially():
    matches = []
    query = 'hello jina'
    txt_files = glob.glob(f'{dir_path}/resources/*.txt')
    for txt_file in txt_files: 
        with open(txt_file, 'r') as f:
            if query in f.read(): 
                matches.append(txt_file)
    return matches
if __name__ == '__main__':
    matches = match_sequentially()
    print(matches)</pre>
<p>The <a id="_idIndexMarker021"/>code fulfills the simplest search function by traversing all files with the extension <strong class="source-inline">.txt</strong> in the current directory and then opening those files in turn. If the keyword <strong class="source-inline">hello</strong> <strong class="source-inline">jina</strong> used for the query is available, the filename will be printed with all the matching files. Although these lines of code allow you to conduct a basic search, the process has many flaws:</p>
<ul>
<li><strong class="bold">Poor scalability</strong>: In a production environment, there may be millions of files to be retrieved. Meanwhile, users of the retrieval system expect to obtain retrieval results in the shortest possible time, posing stringent requirements for the performance of the search system.</li>
<li><strong class="bold">Lack of a relevance measurement</strong>: The code helps you achieve the most basic Boolean retrieval, which is to return the result of a match or mismatch. In a real-world scenario, users need a score to measure the relevance degree from a search system that is sorted in descending order, with more relevant files being returned to users first. Obviously, the aforementioned code snippets are <a id="_idIndexMarker022"/>unable to fulfill this function.</li>
</ul>
<p>To address these issues, we need to <em class="italic">index</em> the files to be <a id="_idIndexMarker023"/>retrieved. <strong class="bold">Indexing</strong> refers to a process of converting a file type that allows a rapid search and skipping the continuous scanning of all files. </p>
<p>As an important part of our daily lives, indexing is comparable to consulting a dictionary and visiting a library. We’ll use the most widely used search library, Lucene, to illustrate the idea.</p>
<p>Lucene Core (<a href="https://lucene.apache.org/">https://lucene.apache.org/</a>) is a<a id="_idIndexMarker024"/> Java library providing powerful indexing and <a id="_idIndexMarker025"/>search features, as well as spellchecking, hit highlighting, and advanced analysis/tokenization capabilities. Apache Lucene sets the standard for search and indexing performance. It is the search core of both Apache Solr and Elasticsearch.</p>
<p>In Lucene, after all collections of files to be retrieved are loaded, you may extract texts from such files and convert them to Lucene Documents, which generally contain the title, body, abstract, author, and URL of a file.</p>
<p>Next, your file will be analyzed by <a id="_idIndexMarker026"/>Lucene’s <em class="italic">text analyzer</em>, which generally includes the following processes: </p>
<p><strong class="bold">Tokenizer</strong>: This splits the<a id="_idIndexMarker027"/> raw input paragraphs into tokens that cannot be further decomposed.</p>
<p><strong class="bold">Decomposing</strong> <strong class="bold">compound</strong> <strong class="bold">words</strong>: In<a id="_idIndexMarker028"/> languages such as German, words composed of two or more tokens are called compound words.</p>
<p><strong class="bold">Spell correction</strong>: Lucene allows users to <a id="_idIndexMarker029"/>conduct spellchecking to enhance the accuracy of retrieval.</p>
<p><strong class="bold">Synonym analysis:</strong> This<a id="_idIndexMarker030"/> enables users to manually add synonyms in Lucene to improve the recall rate of the search system (note: the accuracy rate and recall rate will be elaborated upon shortly).</p>
<p><strong class="bold">Stemming and lemmatization:</strong> The former enables users to derive the root by removing the suffix of a<a id="_idIndexMarker031"/> word (for example, <em class="italic">play</em>, the root form, is<a id="_idIndexMarker032"/> derived from the words <em class="italic">plays</em>, <em class="italic">playing</em>, and <em class="italic">played</em>), while the latter helps users convert words into basic forms, such as <em class="italic">is</em>, <em class="italic">are</em>, and <em class="italic">been</em>, which are converted to <em class="italic">be</em>.</p>
<p>Let’s attempt <a id="_idIndexMarker033"/>to preprocess some texts using <strong class="bold">NLTK</strong>. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">NLTK <a id="_idIndexMarker034"/>is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to over 50 corpora and lexical resources.</p>
<p>First, install a Python package called <strong class="source-inline">nltk</strong> with this command:</p>
<p class="source-code">pip install nltk</p>
<p class="source-code">python -m nltk.downloader 'punkt'</p>
<p>We preprocess the text <strong class="source-inline">Jina is a neural search framework built with cutting-edge technology called deep learning</strong>:</p>
<pre class="source-code">import nltk
sentence = 'Jina is a neural search framework built with cutting-edge technology called deep learning'
def tokenize_and_stem():
    tokens = nltk.word_tokenize(sentence)
    stemmer = nltk.stem.porter.PorterStemmer()
    stemmed_tokens = [stemmer.stem(token) for token in 
                     tokens]
    return stemmed_tokens
if __name__ == '__main__':
    tokens = tokenize_and_stem()
    print(tokens)</pre>
<p>This code<a id="_idIndexMarker035"/> enables us to carry out two operations on a sentence: tokenizing and stemming. The results of each are printed respectively. The raw input strings are parsed into a list of strings in Python, and finally each parsed token is lemmatized to its basic form. For instance, <strong class="source-inline">cutting</strong> and <strong class="source-inline">called</strong> are respectively converted to <strong class="source-inline">cut</strong> and <strong class="source-inline">call</strong>. For more operations, please refer to the <a id="_idIndexMarker036"/>official documentation of NLTK (<a href="https://www.nltk.org/">https://www.nltk.org/</a>).</p>
<p>After files are processed with the Lucene Document, the <em class="italic">clean</em> files will be indexed. Generally, in a<a id="_idIndexMarker037"/> traditional search system, all files are indexed using an <strong class="bold">inverted index</strong>. An inverted index (also referred to as<a id="_idIndexMarker038"/> a <strong class="bold">postings file</strong> or <strong class="bold">inverted file</strong>) is an index data structure storing a map of content, such as words or numbers, to its locations in a database file, or in a document or a set of documents.</p>
<p>Simply put, an<a id="_idIndexMarker039"/> inverted index <a id="_idIndexMarker040"/>consists of two parts: a <strong class="bold">term dictionary</strong>, and <strong class="bold">postings</strong>. </p>
<p>Tokens, their IDs, and the <a id="_idIndexMarker041"/>document frequency (the frequency of such tokens appearing in the entire collection of documents to be retrieved) are stored in the term dictionary. A collection of all tokens is called a vocabulary. All tokens are sorted in alphabetical order in the dictionary. </p>
<p>In the postings, we save the token ID and the document IDs where the token occurred. Assuming that in the aforesaid example, the token <strong class="source-inline">jina</strong> from our query keyword <strong class="source-inline">hello jina</strong> appears three times in the entire collection of documents (in <strong class="source-inline">1.txt</strong>, <strong class="source-inline">3.txt</strong>, and <strong class="source-inline">11.txt</strong>), then the token is “jina” and the document frequency is 3. Meanwhile, the names of the three text documents, <strong class="source-inline">1.txt</strong>, <strong class="source-inline">3.txt</strong>, and <strong class="source-inline">11.txt</strong>, are saved in the <a id="_idIndexMarker042"/>posting. Then, the indexing of the text file is completed as shown in the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<img alt="Figure 1.1 – Data structure of inverted index " height="663" src="image/Figure_1.1_B17488.jpg" width="1295"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Data structure of inverted index</p>
<p>When a user <a id="_idIndexMarker043"/>makes a query, keywords used for the query are generally shorter than the collection of documents to be retrieved. Lucene can perform the same preprocessing for such keywords (such as tokenization, decomposition, and spelling correction). </p>
<p>The processed tokens are mapped to the postings through the term dictionary in the inverted index so that matched files can be quickly found. Finally, Lucene’s scoring starts to work and scores each related file discovered according to a vector space model. Our index file is stored in an inverted index, which may be represented as a vector. </p>
<p>Assuming that<a id="_idIndexMarker044"/> our query keyword is <strong class="source-inline">jina</strong>, we map it to the vector of the inverted index and have it represented by <strong class="source-inline">-</strong> when it does not appear in the file; then the query vector <strong class="source-inline">[-,'jina',-,-, ...]</strong> can be obtained. This is how we represent a <em class="italic">query</em>, as a <strong class="bold">vector space model</strong>, in a traditional search engine. </p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<img alt="Figure 1.2 – Term occurrence in the vector space model " height="416" src="image/Figure_1.2_B17488.jpg" width="1465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Term occurrence in the vector space model</p>
<p>Next, in order to<a id="_idIndexMarker045"/> derive the ranking, we need to numerically<a id="_idIndexMarker046"/> represent the token of the space vector model. Generally, <strong class="bold">tf-idf</strong> is regarded as a simple approach. </p>
<p>With this algorithm, we grant a higher weight to any token that appears relatively frequently. If such a token appears multiple times in many documents, we believe that the token is weakly representative, and the weight of the token will be reduced again. If the token does not appear in the documents, its weight is 0. </p>
<p>In Lucene, an<a id="_idIndexMarker047"/> algorithm called <strong class="bold">bm-25</strong> is<a id="_idIndexMarker048"/> employed more frequently, which further optimizes tf-idf. After numerical calculation, the vector is expressed as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 1.3 – Vector space representation " height="416" src="image/Figure_1.3_B17488.jpg" width="1465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Vector space representation</p>
<p>As shown in the <a id="_idIndexMarker049"/>preceding figure, because the word <strong class="bold">a</strong> appears too frequently, it appears in document 1 and document 2 and has a low weight score. The token <em class="italic">jina</em>, a<a id="_idIndexMarker050"/> relatively uncommon word (appearing in document 2), has been granted a higher weight. </p>
<p>In the query vector, because the query keyword only has one word, <em class="italic">jina</em>, its weight is set as 1 and the weights of other tokens that do not appear are set as 0. Afterward, we multiply the query vector and the document vector element by element and add up the results to obtain the score of each document corresponding to the query keyword. Then, reverse sorting is performed so that the sorted documents can be returned to the user according to the score sorted in an inverted order (from high to low scores).</p>
<p>In short, if the keyword used for a query appears more frequently in a particular file and less frequently in the vocabulary file, its relative score will be higher and returned to the user with a higher priority. Of course, Lucene also grants different weights to various parts of a file. For example, the title and keywords of the file will have a higher scoring weight than the body would. Given the fact this book is about neural search, this aspect will not be elaborated upon further here. </p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Pros and cons of the traditional search system</h2>
<p>In the previous section, we briefly revisited traditional symbolic search. Perhaps you have noticed that both the Lucene we introduced previously and the Lucene-based search frameworks, such as Elasticsearch and Solr, are based on text retrieval. This has quite a few advantages in the application scenarios of searching text by text:</p>
<p><strong class="bold">Mature technology</strong>: Since<a id="_idIndexMarker051"/> research and development were done in 1999, the Lucene and Lucene-based search systems have existed for over 20 years and have been widely used in various web applications.</p>
<p><strong class="bold">Easy integration</strong>: As users, developers of a web application do not need to have a deep understanding of Elasticsearch, Solr, or the operating logic of Lucene; only a small amount of code is required to integrate a high-performing, extensible search system into web applications.</p>
<p><strong class="bold">Well-developed ecosystem</strong>: Thanks to the operation of Elastic Company, Elasticsearch has extended its search system functionality significantly. Currently, it is not only a search framework, but also a platform equipped with user management, a restful interface, data backup and restoration, and security management such as single sign-in, log audit, and other functions. Meanwhile, the <a id="_idIndexMarker052"/>Elasticsearch community has contributed a variety of plugins and integrations.</p>
<p>At the same time, you have probably realized that both Elasticsearch and Solr with Lucene at the core have <a id="_idIndexMarker053"/>unavoidable flaws. </p>
<p>In the previous section, we introduced the concept of modality. Lucene and Elasticsearch, which is built on<a id="_idIndexMarker054"/> top of it, are inherently unable to support cross-modal and multi-modal search options. Let’s take a moment to review the operating principle of Lucene, as Lucene has powered most of the search systems users are using on a daily basis. When texts are preprocessed in the first place, the search keyword must be text. When a data collection to be retrieved is preprocessed and indexed, likewise the index result is also the text stored in the inverted index. </p>
<p>In this way, the Lucene-based search platform can only rely on the text modality and retrieve data in the text modality. If objects to be retrieved are images, audio, or video files, how can they be found using a traditional search system? It is quite simple; two main methods are employed:</p>
<p><strong class="bold">Manual tagging and adding metadata</strong>: For example, when a user uploads a song to a music platform, they may manually tag the author, album, music type, release time, and other data. Doing so ensures that users are able to retrieve music using text.</p>
<p><strong class="bold">Hypothesis of the surrounding text</strong>: If an image, in the absence of user tagging, appears in an article, it will be assumed by the traditional search system to be more closely associated with its surrounding text. Accordingly, when a user’s query keyword matches the surrounding text of the image, the latter will be matched.</p>
<p>The essence of the two methods is to convert the document of non-text modality into a text modality so as to effectively use the current retrieval technology. However, this modal conversion process either relies on a large amount of manual tagging, or is done at the cost of query accuracy, which greatly undermines the user’s search experience.</p>
<p>Likewise, this type of search mode limits the user’s search habits to a keyword search and cannot be extended to a real cross-modal or even multi-modal search. For deeper insight into this issue, we may use a vector space to represent keywords of a paragraph and use another vector space to denote a text document to be retrieved. However, due to the restrictions of the technology back in the days when we had to rely on traditional search systems, we were unable to use the space vector to represent a piece of music, image, or video. It is also impossible to map two documents of different modalities to the same space vector to compare their similarities.</p>
<p>With the research and development on (statistical) machine learning techniques, more and more researchers and engineers have started to empower their search system using machine learning algorithms.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Machine learning for search</h1>
<p>As a cross-disciplinary<a id="_idIndexMarker055"/> task, neural search has gone beyond the boundaries of information retrieval. It requires a general understanding of the concepts of machine learning, deep learning, and how we can apply these techniques to improve a search task. In this section, we will give a brief introduction to machine learning and how it can be applied to search systems.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Understanding machine learning and artificial intelligence</h2>
<p><strong class="bold">Machine learning</strong> refers to a<a id="_idIndexMarker056"/> technique that teaches computers to make decisions in a way that comes naturally to humans by enabling computers to learn the inherent laws of data and acquire new experience and knowledge, thus improving their intelligence.</p>
<p>Because various<a id="_idIndexMarker057"/> industries require an increased level of efficiency during data processing and analysis due to their growing demand for data, a large number of machine learning algorithms have emerged. The concept of statistical machine learning algorithms<a id="_idIndexMarker058"/> primarily refers to the steps and processes of solving optimization problems through mathematical and statistical methods.</p>
<p>With respect to different data and model requirements, appropriate machine learning algorithms are selected and employed to tackle practical issues in a more efficient manner. Machine learning has achieved great success in many fields, such as natural language understanding, computer vision, machine translation, and expert systems. It is fair to say that whether a system has a <em class="italic">learning</em> function or not has become a hallmark of it possessing intelligence.</p>
<p>Hinton et al. (2006) proposed the concept <a id="_idIndexMarker059"/>of <strong class="bold">deep learning </strong>(deep learning/deep neural networks). In 2009, Hinton introduced deep neural networks to scholars specialized in voices. Hence, in 2010, this field of research witnessed a remarkable breakthrough in speech recognition. In the next 11 years, <strong class="bold">convolutional neural networks </strong>(<strong class="bold">CNNs</strong>) were <a id="_idIndexMarker060"/>applied in the field of image recognition, leading to significant achievements. </p>
<p>Three founders of neural networks, LeCun, Bengio, and Hinton (2015), published a review titled <em class="italic">Deep Learning</em> in Nature. This shows that deep neural networks have not only been accepted by academia, but also the industrial field. Furthermore, in 2016 and 2017, the world witnessed a general expansion in deep learning. AlphaGo and AlphaZero were<a id="_idIndexMarker061"/> invented by Google after a short learning <a id="_idIndexMarker062"/>period and won a landslide victory over the top three Go players in the world. The intelligent voice system launched by iFLYTEK boasts a recognition accuracy rate of over 97% and stands at the forefront of AI worldwide; the autonomous driving systems developed by companies such as Google and Tesla have passed a milestone of testing on the road. These achievements have unveiled the value and charm of neural networks to humans again.</p>
<p>Machine learning <a id="_idIndexMarker063"/>has been applied to various industries, so maybe we can ask ourselves: can we apply machine learning to search applications? The answer here is “Yes.” In the next section, we’ll give a brief overview of different types of machine learning and how search can benefit from it.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Machine learning and learning-to-rank</h2>
<p>Imagine a scenario where you intend to train a model capable of evaluating the price of a new apartment or house based on the collected data related to local real estate information<a id="_idIndexMarker064"/> and prices. This is one of the most important tasks of machine learning: <strong class="bold">regression</strong>. </p>
<p>Before the popularization of the deep learning technique, data analysts would have had to clean this data, use business logic to perform feature engineering, and design features of a real estate price predictor, such as the floor area, construction time, and type of apartments or houses, as well as the average prices of surrounding apartments or houses, and so on. </p>
<p>After feature engineering has been completed, raw data will be used to form a two-dimensional data table similar to Excel. The horizontal axis represents each house record, and the vertical axis represents each feature. The data is usually divided into two to three parts again: the majority of the data is used <a id="_idIndexMarker065"/>for <em class="italic">model training</em>, while a small amount <a id="_idIndexMarker066"/>of the data is used for <em class="italic">model evaluation. </em></p>
<p>Next, machine learning engineers will select one or more appropriate algorithms from the machine learning toolkit to train the model and evaluate the performance of the model in the test data. Finally, the model with the best performance will be deployed in the production environment to serve customers.</p>
<p>Imagine another scenario where many landmark pictures have been collected from social networks. When a user uploads a new landmark picture, you expect your system to <a id="_idIndexMarker067"/>automatically recognize the name of the site. This is another important task of machine learning: <strong class="bold">classification</strong>.</p>
<p>In the field of traditional machine learning and computer vision, some features, such as SIFT, SURF, and HOG, are employed<a id="_idIndexMarker068"/> to develop a <strong class="bold">Bag-of-Visual-Words </strong>(<strong class="bold">BoW</strong>)<strong class="bold"> </strong>through which a vector representation of this photo is established. Moreover, models are used to predict the classification. Nowadays, deep learning serves as the model to extract visual features from images without the requirement<a id="_idIndexMarker069"/> of feature engineering.</p>
<p>Let’s take a moment to look at our two examples. During the training process of predicting prices of houses (apartments), models are trained using <em class="italic">feature engineering</em>. All the training data is ground-truth, i.e., the house (apartment) prices and landmark names are documented. Such tasks are collectively referred to as supervised machine learning in the field of machine learning.</p>
<p>Since we can perform regression analysis and classification of data through supervised machine learning, is it possible to apply supervised machine learning in the search? The answer is yes, of course.</p>
<p>Assuming that our task is to optimize the search system, the goal is to predict the user’s click rate for the document and return documents with a higher predicted click rate to the user first. This is <a id="_idIndexMarker070"/>called <strong class="bold">learning-to-rank</strong> (first stage) and <strong class="bold">neural information retrieval </strong>(second stage). The concept of learning-to-rank (based on statistical machine learning), as proposed by academia in the early 1990s, evolved<a id="_idIndexMarker071"/> for nearly 20 years before experiencing a downturn since the emergence of deep learning in 2010, when neural information retrieval was at its peak.</p>
<p>Just like the prediction of an apartment (or house) price, or landmark recognition, engineers first performed data engineering after collecting such data. Common features include the number of query keywords in the document title/body, the percentage of the document title body that contains the query keywords, the tf-idf score, and the bm-25 score, among others. It follows that the final score of a traditional search system is used as a numerical feature during the training of models. </p>
<p>In a real-world scenario, Microsoft’s Bing search platform was designed with its own <em class="italic">Microsoft Learning to Rank Datasets</em>, which contain 136 features. Besides, they published a contest for learning-to-rank, calling for the use of these datasets as a basic training model for predicting the matching degree of web pages. After that, a trained model is applied in the production environment of a Bing search, which has improved the search effect to a certain extent. </p>
<p>At the same time, search companies such as Google, Yahoo, and Baidu have also conducted a large amount of research and have partially deployed their research results into the production environment.</p>
<p>In the fields of <a id="_idIndexMarker072"/>enterprise and personal search, Elastic has developed its learning-to-rank plugin named ElasticSearch LTR, which can be plug-in into your ES-powered search system. As a user, you still need to use a familiar machine learning framework to design features, train the learning-to-rank model, evaluate the model performance, and select models. Elasticsearch’s support for learning-to-rank can be plugged into the existence search system and get a new predicted ranking score based on model output. Although machine learning can be used to design models for multi-modal data, Elasticsearch places more emphasis on text-to-text search. Figure 1.4 demonstrates how learning-to-rank works in a search system. </p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 1.4 – Learning-to-rank " height="767" src="image/Figure_1.4_B17488.jpg" width="1341"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Learning-to-rank</p>
<p>This book will focus on <a id="_idIndexMarker073"/>search powered by deep neural networks, namely <strong class="bold">neural information retrieval</strong>.</p>
<p>The advantage of neural<a id="_idIndexMarker074"/> information retrieval is that users do not have to <em class="italic">design</em> features by themselves. Normally, we leverage two independent deep learning models (neural nets) as feature extractors to extract vectors from queries and documents respectively. Then, we measure the similarity between two vectors using metrics, such as cosine similarity. At this stage, neural-network-powered search has become very promising for industrial use cases. In the next section, we will introduce some of the potential applications for neural-network-powered search.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Practical applications powered by neural search</h1>
<p>The previous section <a id="_idIndexMarker075"/>provided an overview of the representation and principles of dense vectors. This section will focus on the application of these vectors. During our daily work and study, all files will have a unique modality, such as a text, image, audio, or video file, and so on. If documents of any modality can be represented by dense vectors and then mapped to the same vector space, it is possible to compare the cross-modal similarity. This also allows us to use one modality to search for data in another modality.</p>
<p>This scenario was first extensively put into practice in the field of e-commerce with the common use of <em class="italic">image search</em>, for example. Its major application in this field includes having a product photo and hunting for related or similar products offline and online. </p>
<p>The e-commerce search primarily consists of steps such as the following:</p>
<ol>
<li><strong class="bold">Preprocessing</strong></li>
<li><strong class="bold">Feature extraction and fusion</strong></li>
<li><strong class="bold">Large-scale similarity search</strong></li>
</ol>
<p>During <a id="_idIndexMarker076"/>preprocessing, techniques such as <strong class="bold">resizing</strong>, <strong class="bold">normalization</strong>, and <strong class="bold">semantic</strong> <strong class="bold">segmentation</strong> may first be employed to process images. Resizing and normalization<a id="_idIndexMarker077"/> enable the input image<a id="_idIndexMarker078"/> to match the input format of the pre-trained neural network. Semantic segmentation has the function of removing background noise from the image and leaving only the product itself. Of course, we need to pre-train a neural pathway for feature extraction, which will be elaborated on shortly. By the same token, if the dataset of an e-commerce product to be retrieved has a large amount of noise, such as a large number of buildings, pedestrians, and so on in the background of fashion photos, it will be necessary to train a<a id="_idIndexMarker079"/> semantic segmentation model that can help us accurately extract the product profile from photos. </p>
<p>During <a id="_idIndexMarker080"/>feature extraction, a <strong class="bold">fully connected</strong> (<strong class="bold">FC</strong>) layer<a id="_idIndexMarker081"/> of deep learning is generally used as a feature extractor. The common backbone models of deep learning are AlexNet, VGGNet, Inception, and ResNet. These models are usually pre-trained on a large-scale dataset (such as the ImageNet dataset) to complete classification tasks. Transfer learning<a id="_idIndexMarker082"/> is carried out with the dataset in the e-commerce field in a bid to make the feature extractor suitable for the field, such as the feature extraction of fashion. Currently, a feature extractor with deep learning <a id="_idIndexMarker083"/>techniques at its core can be regarded as a <em class="italic">global feature extractor</em>. In some applications, traditional computer vision features, such as SIFT or VLAD, are employed for the extraction of local features and fusion with global features to enhance vector representation. The global feature will transform the preprocessed image into a dense vector representation.  </p>
<p>When users make a query based on the search for images with images, the keyword used for the query is also an image. The system will generate a dense vector representation of that image. Then, users will be able to find the most similar image by comparing the dense vector of the image to be queried against those of all images in the library. This is feasible in theory. However, in reality, with the rapid increase in the number of commodities, there may be tens of millions of dense vectors of indexed images. As a result, the comparison of vectors in a pair-wise manner will fail to meet the user’s requirements for a quick response from the retrieval system. </p>
<p>Therefore, <em class="italic">large-scale similarity search techniques</em>, such as <a id="_idIndexMarker084"/>product quantization, are generally used to divide the vector to be searched into multiple buckets and perform a quick match based on the<a id="_idIndexMarker085"/> buckets by minimizing the recall<a id="_idIndexMarker086"/> rate and greatly speeding up the vector-matching process. Therefore, this technique is also commonly referred to as <em class="italic">approximate nearest neighbor</em>, or <em class="italic">ANN retrieval</em>. Commonly used ANN libraries include the FAISS, which is maintained by Facebook, and Annoy, maintained by Spotify. </p>
<p>Likewise, the search for images by images in an e-commerce scenario is also applicable to other scenarios, such as <em class="italic">Tourism Landmark Retrieval</em> (using pictures of tourist attractions to quickly locate other pictures of that attraction or similar tourist attractions), or <em class="italic">Celebrity Retrieval</em> (used to find photos of celebrities and retrieve their pictures). In the field of search engines, there are many such applications, which are collectively <a id="_idIndexMarker087"/>referred to as <em class="italic">reverse image search</em>. </p>
<p>Another interesting <a id="_idIndexMarker088"/>application is <strong class="bold">question answering</strong>. Neural-network-based search systems could be powerful when building a question-answering (QA) system on different tasks. First, the questions and answers that are currently available are taken as a training dataset on which to develop a pre-trained model of texts. When the user enters a question, the pre-trained model is employed to encode the question into a dense vector representation, conduct similarity matching in the dense vector representation of the existing repository of answers, and quickly help users find the answer to a question. Second, many<a id="_idIndexMarker089"/> question-answering systems, such as Quora, StackOverflow, and Zhihu, already have a large number of previously asked questions. When a user wants to ask a question, the question-answering system first determines whether the question has already been asked by <a id="_idIndexMarker090"/>someone else. If so, the user will be advised to click and check the answers to similar questions instead of repeating the query. This also involves<a id="_idIndexMarker091"/> similarity match, which is <a id="_idIndexMarker092"/>normally referred to as <em class="italic">deduplication</em> or <em class="italic">paraphrase identification</em>. </p>
<p>Meanwhile, in the real world, a large number of unexplored applications can be completed using neural information retrieval. For instance, if you employ text to search for untagged music, it is necessary to map the text and music representation to the same vector space. Then, the appearance time of scenarios in the video can be located using images. Conversely, when a user is watching a video, a product that appears in the video is <a id="_idIndexMarker093"/>retrieved and the purchase can be completed. Alternatively, deep learning can be carried out for specialized data retrieval, such as source code retrieval, DNA sequence retrieval, and more!</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>New terms learned in this chapter</h1>
<ul>
<li><strong class="bold">Traditional search</strong>: Mostly <a id="_idIndexMarker094"/>applied to text retrieval. Measures the similarity by the weighted score of occurrences of a set of tokens from a query and documents.</li>
<li><strong class="bold">Indexing</strong>: The process<a id="_idIndexMarker095"/> of converting files that allow a rapid search and skipping the continuous scanning of all files.</li>
<li><strong class="bold">Searching</strong>: The<a id="_idIndexMarker096"/> process of conducting similarity score computation against a user query and indexed documents inside the document store and returning the top-k matches.</li>
<li><strong class="bold">Vector space model</strong>: A way to represent a document numerically. The dimension of the VSM<a id="_idIndexMarker097"/> is the number of distinct tokens in all documents. The value of each dimension is the weight of each term.</li>
<li><strong class="bold">TF-IDF</strong>: Term-Frequency <a id="_idIndexMarker098"/>Inverse Document Frequency is an algorithm that is intended to reflect how important a word is to a document in a collection of documents that are to be indexed.</li>
<li><strong class="bold">Machine learning</strong>: This <a id="_idIndexMarker099"/>refers to a technique that teaches computers to make decisions in a way that comes naturally to humans by enabling computers to learn the distribution of data and acquire new experience and knowledge.</li>
<li><strong class="bold">Deep neural networks</strong>: A <strong class="bold">deep neural network</strong> (<strong class="bold">DNN</strong>) is an <strong class="bold">artificial neural network</strong> (<strong class="bold">ANN</strong>) with <a id="_idIndexMarker100"/>multiple layers between the <a id="_idIndexMarker101"/>input and output layers that aims to predict, classify, or learn a compact representation (dense vector) of a piece of data. </li>
<li><strong class="bold">Neural search</strong>: Unlike symbolic search, neural search<a id="_idIndexMarker102"/> makes use of the representation (a dense vector) generated by DNNs and measures the similarity between a query vector and a document vector, returning the top-k matches based on certain metrics.</li>
</ul>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Summary</h1>
<p>In this chapter, you have learned about the key concepts of searching and matching. We have also covered the difference between legacy search and neural-network-based search. We saw how neural networks can help us tackle the issues traditional search cannot solve, such as cross-modality or multi-modality search.</p>
<p>Neural networks are able to encode different types of information into a common embedding space and make different pieces of information comparable, and that’s why deep learning and neural networks have the potential to better fulfill a user’s information needs.</p>
<p>We have introduced several possible applications using deep-learning-powered search systems, for instance, vision-based product search in fashion or tourism, or text-based search for question answering and text deduplication. More kinds of application are still to be explored!</p>
<p>You should now understand the core idea behind neural search: neural search has the ability to encode any kind of data into an expressive representation, namely an <strong class="bold">embedding</strong>. Creating a quality embedding is crucial to a search application powered by deep learning, since it determines the quality of the final search result.</p>
<p>In the next chapter, we will introduce the foundations of embeddings, such as how to encode information into embeddings, how to measure the distance between different embeddings, and some of the most important models we can use to encode different modalities of data.</p>
</div>
</div>
</body></html>