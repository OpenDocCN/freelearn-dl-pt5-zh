["```py\n    procs = [FillMissing,Categorify]\n    dep_var = 'salary'\n    cont,cat = cont_cat_split(df, 1, dep_var=dep_var)\n    ```", "```py\n    dls=TabularDataLoaders.from_df(\n    df, path, procs= procs,\n    cat_names= cat, cont_names = cont, \n    y_names = dep_var, \n    valid_idx=list(range(1024,1260)), bs=64)\n    ```", "```py\n    learn = tabular_learner(dls,layers=[200,100], metrics=accuracy)\n    learn.fit_one_cycle(3)\n    ```", "```py\n    learn.summary()\n    ```", "```py\n    pip install kaggle\n    ```", "```py\n    {\"username\":<YOUR ID>,\"key\":<YOUR KEY>}\n    ```", "```py\n    creds = '{\"username\":<YOUR ID>,\"key\":<YOUR KEY>}'\n    ```", "```py\n    cred_path = Path('~/.kaggle/kaggle.json').expanduser()\n    ```", "```py\n    path = URLs.path('house_price')\n    ```", "```py\n    if not path.exists():\n        path.mkdir()\n        api.competition_download_cli('house-prices-advanced-regression-techniques', path=path)\n        file_extract(path/'house-prices-advanced-regression-techniques.zip')\n        path.ls(file_type='text')\n    ```", "```py\n    [Path('/storage/archive/house_price/sample_submission.csv'),\n    Path('/storage/archive/house_price/data_description.txt'),\n    Path('/storage/archive/house_price/train.csv'),\n    Path('/storage/archive/house_price/test.csv')]\n    ```", "```py\n    df_train = pd.read_csv(path/'train.csv')\n    ```", "```py\n    df_test = pd.read_csv(path/'test.csv')\n    ```", "```py\n    def under_over(x,mean_x):\n        if (x <= mean_x):\n            returner = '0'\n        else:\n            returner = '1'\n        return(returner)\n    ```", "```py\n    mean_sp = int(df_train['SalePrice'].mean())\n    df_train['SalePrice'] = df_train['SalePrice'].apply(lambda x: under_over(x,mean_sp))\n    df_train.head()\n    ```", "```py\n    df_train['SalePrice'].value_counts()\n    ```", "```py\n    dep_var = 'SalePrice'\n    cont,cat = cont_cat_split(df_train, 1, dep_var=dep_var)\n    ```", "```py\n    count = df_train.isna().sum()\n    df_train_missing = (pd.concat([count.rename('missing_count'),count.div(len(df_train)).rename('missing_ratio')],axis = 1).loc[count.ne(0)])\n    ```", "```py\n    df_train[cat] = df_train[cat].fillna(df_train[cat].mode().iloc[0])\n    df_test[cat] = df_test[cat].fillna(df_test[cat].mode().iloc[0])\n    df_train[cont] = df_train[cont].fillna(0.0)\n    df_test[cont] = df_test[cont].fillna(0.0)\n    ```", "```py\n    count = df_train.isna().sum()\n    df_train_missing = (pd.concat([count.rename('missing_count'),count.div(len(df_train)).rename('missing_ratio')],axis = 1).loc[count.ne(0)])\n    ```", "```py\n    procs = [Categorify, Normalize]\n    dls_house=TabularDataLoaders.from_df(\n        df_train,path,procs= procs,\n        cat_names= cat, cont_names = cont, y_names = dep_var, \n        valid_idx=list(range((df_train.shape[0]-100),df_train.shape[0])), \n        bs=64)\n    ```", "```py\n    learn = tabular_learner(dls_house, layers=[200,100], metrics=accuracy)\n    learn.fit_one_cycle(5)\n    ```", "```py\n    dl = learn.dls.test_dl(df_test)\n    ```", "```py\n    learn.show_results()\n    ```", "```py\n    cd /storage/archive\n    ```", "```py\n    mkdir kl_property\n    ```", "```py\n    /notebooks/temp:\n\n    ```", "```py\n\n    ```", "```py\ncp /notebooks/temp/data_kaggle.csv /storage/archive/kl_property/data_kaggle.csv\n```", "```py\n    path = URLs.path('kl_property')\n    ```", "```py\n    df_train = pd.read_csv(path/'data_kaggle.csv')\n    ```", "```py\n    df_train.head()\n    ```", "```py\n    df_train.shape\n    ```", "```py\n    df_train.dropna(subset=['Price'], inplace=True)\n    df_train['Price'] = df_train['Price'].apply(lambda x: remove_currency(\"RM \",x))\n    df_train['Price'] = pd.to_numeric(df_train['Price'].str.replace(',',''), errors='coerce')\n    ```", "```py\n    clean_up_list = [\"-\",\"\\+\",'\\'','\\~',\"xx\",\"sf\",\"acre\",\"#\"]\n    df_train = clean_up_size(df_train,clean_up_list)\n    ```", "```py\n    mean_sp = int(df_train['Price'].mean())\n    if categorical_target:\n        df_train['Price'] = df_train['Price'].apply(lambda x: under_over(x,mean_sp))\n    ```", "```py\n    procs = [FillMissing,Categorify]\n    dep_var = 'Price'\n    cont,cat = cont_cat_split(df_train, 1, dep_var=dep_var)\n    ```", "```py\n    dls = TabularDataLoaders.from_df(df_train,path,procs= procs, \n             cat_names= cat, cont_names = cont, \n             y_names = dep_var,\n             valid_idx=list(range((df_train.shape[0]-5000),df_train.shape[0])), \n             bs=64)\n    ```", "```py\n    ! pip install pandas_datareader\n    import numpy as np\n    import pandas as pd\n    import os\n    import yaml\n    # For reading stock data\n    from pandas_datareader.data import DataReader\n    # For time stamps\n    from datetime import datetime\n    ```", "```py\n    df = DataReader('AZN', 'stooq')\n    ```", "```py\n    count = df.isna().sum()\n    df_missing = (pd.concat([count.rename('missing_count'),count.div(len(df)).rename('missing_ratio')],axis = 1).loc[count.ne(0)])\n    ```", "```py\n    dep_var = 'Close'\n    # define columns that are continuous / categorical\n    cont,cat = cont_cat_split(df, 1, dep_var=dep_var)\n    ```", "```py\n    procs = [Normalize]\n    dls = TabularDataLoaders.from_df(df,procs= procs,\n            cat_names= cat, cont_names = cont, \n            y_names = dep_var, \n            valid_idx=list(range((df.shape[0]-50),df.shape[0])), bs=64)\n    ```", "```py\n    learn = tabular_learner(dls, metrics=accuracy)\n    learn.fit_one_cycle(30)\n    ```", "```py\n    def get_target(value,threshold):\n        '''return based on whether the input value is greater than or less than input threshold'''\n        if value <= threshold:\n            return_value = \"0\"\n        else:\n            return_value = \"1\"\n        return(return_value)\n    ```", "```py\n    threshold = df['Close'].mean()\n    df['target'] = df['Close'].apply(lambda x: get_target(x,threshold))\n    ```", "```py\n    dep_var = 'target'\n    cont = ['High', 'Low', 'Open', 'Volume']\n    ```", "```py\n    dls = TabularDataLoaders.from_df(df,procs= procs, \n        cat_names= cat, cont_names = cont, \n        y_names = dep_var, \n        valid_idx=list(range((df.shape[0]-50),df.shape[0])), \n        bs=64)\n    learn = tabular_learner(dls, metrics=accuracy)\n    learn.fit_one_cycle(30)\n    ```", "```py\n    learn.export('adult_sample_model.pkl')\n    ```", "```py\n    learn = load_learner('/notebooks/temp/models/adult_sample_model.pkl')\n    ```", "```py\n    df_test = pd.read_csv('adult_sample_test.csv')\n    ```", "```py\n    test_sample = df_test.iloc[0]\n    learn.predict(test_sample)\n    ```", "```py\n    cd /storage/archive\n    ```", "```py\n    mkdir price_prediction\n    ```", "```py\ncd /storage/archive/price_prediction\n```", "```py\ncp /notebooks/temp/sales_train.csv  sales_train.csv \ncp /notebooks/temp/test.csv  test.csv\n```", "```py\n    path = URLs.path('price_prediction') \n    df_train = pd.read_csv(path/'sales_train.csv')\n    ```"]