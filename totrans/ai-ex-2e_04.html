<html><head></head><body>
  <div id="_idContainer073">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-55" class="chapterTitle">Optimizing Your Solutions with K-Means Clustering</h1>
    <p class="normal">No matter how much we know, the key point is the ability to deliver an <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) solution. Implementing a <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) or <strong class="bold">deep learning</strong> (<strong class="bold">DL</strong>) program remains difficult and will become more complex as technology progresses at exponential rates.</p>
    <p class="normal">There is no such thing as a simple or easy way to design AI systems. A system is either efficient or not, beyond being either easy or not. Either the designed AI solution provides real-life practical uses, or it builds up into a program that fails to work in various environments beyond the scope of its training sets.</p>
    <p class="normal">This chapter doesn't deal with how to build the most difficult system possible to show off our knowledge and experience. It faces the hard truth of real-life delivery and ways to overcome obstacles. For example, without the right datasets, your project will never take off. Even an unsupervised ML program requires reliable data in some form or other.</p>
    <p class="normal">Transportation itineraries on the road, on trains, in the air, in warehouses, and increasingly in outer space require well-tuned ML algorithms. The staggering expansion of e-commerce generates huge warehouse transportation needs with automated guided vehicles (AGVs), then endless miles on the road, by train, or by air to deliver the products. Distance calculation and optimization is now a core goal in many fields. An AGV that optimizes its warehouse distance to load or unload trucks will make the storage and delivery processes faster for customers that expect their purchases to arrive immediately.</p>
    <p class="normal">This chapter provides the methodology and tools needed to overcome everyday AI project obstacles with k-means clustering, a key ML algorithm.</p>
    <p class="normal">This chapter covers the following topics:</p>
    <ul>
      <li class="list">Designing datasets</li>
      <li class="list">The design matrix</li>
      <li class="list">Dimensionality reduction</li>
      <li class="list">Determining the volume of a training set</li>
      <li class="list">k-means clustering</li>
      <li class="list">Unsupervised learning</li>
      <li class="list">Data conditioning management for the training dataset</li>
      <li class="list">Lloyd's algorithm</li>
      <li class="list">Building a Python k-means clustering program</li>
      <li class="list">Hyperparameters</li>
      <li class="list">Test dataset and prediction</li>
      <li class="list">Saving and using an ML model with Pickle</li>
    </ul>
    <p class="normal">We'll begin by talking about how to optimize and manage datasets.</p>
    <h1 id="_idParaDest-56" class="title">Dataset optimization and control</h1>
    <p class="normal">At one point, a manager or customer will inevitably ask an AI expert about the exact data required for an ML project, and in which format it's needed. Providing an answer will take some hard thinking and work.</p>
    <p class="normal">One might wonder <a id="_idIndexMarker128"/>why the data is not open, like when we download ready-to-use datasets to learn AI algorithms. In corporate life, there are security rules and processes. Often the data required is on one or more servers. You will not be granted permission to do anything you want. You will have to specify your needs and requests. Obtaining data in the way required for AI comes at a cost for a corporation. You will have to justify your requests.</p>
    <p class="normal">Start by properly designing the dataset and choosing the right ML model. The dataset and ML model will fit the fundamental requirement to optimize AGV distances. Each AGV in a given warehouse must reduce the distance it takes to go from a pier (where boats might drop off cargo) to a storage area, from one storage area to another area (packaging, for example), and from a storage area to a pier. This will bring the overall costs of a warehouse down and maximize profit.</p>
    <h2 id="_idParaDest-57" class="title">Designing a dataset and choosing an ML/DL model</h2>
    <p class="normal">On paper, finding a <a id="_idIndexMarker129"/>good model for an AGV comes down to minimizing the distance it takes to move something from point A to point B. Let's consider a scenario where we want to move products from a warehouse over to a pier. The sum of the distances <em class="italics">D</em> could be a way to measure the process:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_001.png" alt=""/></figure>
    <p class="normal"><em class="italics">f</em>(<em class="italics">p</em>) represents the action<a id="_idIndexMarker130"/> of going from a warehouse location to a pier and the distance it represents. It takes you from the location in a shop where you picked something up, (<em class="italics">p</em>), and the door of the shop on your way out. You can imagine that if you go straight from that location, pay, and go out, then that is the shortest way. But if you pick the product up, wander around the shop first, and then go out, the distance (and time) is longer. The sum of all of the distances of all the people wandering in this shop, for example, is <em class="italics">D</em>.</p>
    <p class="normal">The concept of the problem to <a id="_idIndexMarker131"/>solve in any self-guided bot system can be summed up as follows:</p>
    <p class="center"><strong class="bold">find the wanderers</strong></p>
    <p class="normal">How can a bot wander? It is automatic and is often guided by efficient ML programs. But a bot, like any other form of transportation, often encounters obstacles.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">When a bot encounters an obstacle, either it stops, waits, or takes another route.</p>
    </div>
    <p class="normal">We now have a paradigm to investigate and implement:</p>
    <ul>
      <li class="list">Detect the wanderers</li>
      <li class="list">Optimize the choice of bots</li>
    </ul>
    <p class="normal">We all know that the shortest point from location A to location B is a straight line. Right? Well, in a warehouse, as in life, it is not always true! Suppose you are in your car going in a straight line from A to B but there is a huge traffic jam. It could take a very long time to go a relatively short distance. If you took a right turn and drove around the jam, you might save a lot of time. You end up consuming more gas, and the cost of driving from A to B goes up. You are a wanderer.</p>
    <p class="normal">In real-life traffic, there is not much you can do. You cannot decide that cars can only drive at certain hours on a road going from A to B. You cannot decide to send the cars to the locations that minimize traffic. In real life, this would mean telling the driver to go to another mall, another restaurant, or any other similar location to avoid building up traffic. That would not work!</p>
    <p class="normal">But if you are a warehouse<a id="_idIndexMarker132"/> manager that can control all of the AGVs, there is a lot you can do about this. You can make sure that AGVs make it quickly to their locations over a very short distance and come back to make room for other AGVs and thus reduce costs. You can detect the wanderers and configure your schedule and AGVs so that they minimize cost and maximize profit. No profit, no warehouse.</p>
    <h3 id="_idParaDest-58" class="title">Approval of the design matrix</h3>
    <p class="normal">The plan is to first obtain as <a id="_idIndexMarker133"/>much data as possible and then choose an ML/DL model. The dataset must contain all locations the bots (the AGVs) come from on their way to the piers on a given day. It's a location-to-pier analysis. Their distances are recorded in their system to provide the basis of an excellent design matrix. A design matrix contains a different example on each row, and each column is a feature. The following format fits the need:</p>
    <table id="table001-4" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Index</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Bot #</strong>
            <strong class="heading">(AGV)</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Start (from location)</strong>
            <strong class="heading">Timestamp:</strong>
            <strong class="heading">yyyy,mm,dd,hh,mm</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">End (at the pier)</strong>
            <strong class="heading">Timestamp:</strong>
            <strong class="heading">yyyy,mm,dd,hh,mm</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Location</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Pier number</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Distance</strong>
            <strong class="heading">Meters</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">001</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">year-month-day-hour-minute</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">year-month-day-hour-minute</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">80</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">7</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">92</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">002</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">003</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">3</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">004</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">4</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">005</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">5</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
      </tbody>
    </table>
    <p class="normal">The design matrix is one of the best ways to design an ML solution. In this case:</p>
    <ul>
      <li class="list"><strong class="bold">Index</strong>: The mission number of the bot</li>
      <li class="list"><strong class="bold">Bot #</strong>: Identifies the vehicle</li>
      <li class="list"><strong class="bold">Start</strong>: Timestamp when the bot left a location</li>
      <li class="list"><strong class="bold">End</strong>: Timestamp when the bot reaches a pier where a truck is waiting to be loaded</li>
      <li class="list"><strong class="bold">Location</strong>: The location in the warehouse where a product should be retrieved</li>
      <li class="list"><strong class="bold">Distance</strong>: The distance from the location to the pier in meters</li>
    </ul>
    <p class="normal">Distance is expressed in meters in the metric system. The metric system is the world's most reliable measurement system because it works in base 10 without having to resort to conversions.</p>
    <p class="normal">A yard has to be divided by 3 to obtain feet. A foot has to be divided into 12 to obtain inches. To work in smaller units, a 1/16th of an inch may be necessary.</p>
    <p class="normal">A meter is 100 <a id="_idIndexMarker134"/>centimeters, and a centimeter is 10 millimeters, then we can use 1/100 of a millimeter, and so on.</p>
    <p class="normal">Run your calculations with the metric system even if you have to produce reports in other units of measurement.</p>
    <h4 class="title">Getting approval on the format of the design matrix</h4>
    <p class="normal">Real-life <a id="_idIndexMarker135"/>implementations differ from experimenting with ready-to-use downloadable datasets. Information does not come easy in corporations.</p>
    <p class="normal">In this example, in a real-life situation, let's suppose:</p>
    <ul>
      <li class="list">The bot number is not stored in the mainframe, but in the local system that manages the AGVs.</li>
      <li class="list">In the mainframe, there is a start time, which is when an AGV picks up its load at the location, and an end time when it reaches the pier.</li>
      <li class="list">The location can be obtained in the mainframe as well as the pier.</li>
      <li class="list">No distance is recorded.</li>
    </ul>
    <p class="normal">It would be necessary to have access to the data in the AGV's local system to retrieve the AGV number and correlate it with the data in the mainframe.</p>
    <p class="normal">However, things are not so simple in a large organization. For example:</p>
    <ul>
      <li class="list">Retrieving data from the AGV guiding system might not be possible this fiscal year. Those vehicles are expensive, and no additional budget can be allocated.</li>
      <li class="list">Nobody knows the distance from a location to a pier. As long as the AGVs deliver the right products on time at the right piers, nobody so far has been interested in distances.</li>
      <li class="list">The AGV mission codes in the mainframe are not the same as in the local AGV guiding system, so they cannot be merged into a dataset without development.</li>
    </ul>
    <p class="normal">An AI project, like any other project, can slip away in no time. If a project comes to a standstill, it might just be shelved. Designing datasets requires imagination and responsiveness.</p>
    <div class="packt_tip">
      <p>Keeping an AI project alive means moving quickly.</p>
    </div>
    <p class="normal">If the project does not <a id="_idIndexMarker136"/>move quickly, it will lose momentum. The actors of the project will turn to other projects that are moving more quickly for their company and their careers.</p>
    <p class="normal">Suppose your project stops because nobody can provide the distances you need to build your model. If you have the start time, end time, and speed, then you can work around the problem and calculate the distances yourself. If your team does not find this solution quickly, then the project will be at a standstill. The top management will say that the team costs too much to be focused on a project that is not moving ahead, no matter what. The project can be shelved right then and there.</p>
    <p class="normal">Dimensionality reduction will not only help the AI model; it will also make it easier to gather information.</p>
    <h4 class="title">Dimensionality reduction</h4>
    <p class="normal">Dimensionality reduction<a id="_idIndexMarker137"/> can be applied to reduce the number of features in, for example, an image. Each pixel of a 3D image, for example, is linked to a neuron, which in turn brings the representation down to a 2D view with some form of function. For example, converting a color image into shades of a now-gray image can do the trick. Once that is done, simply reducing the values to, for example, 1 (light) or 0 (dark), makes it even easier for the network. Using an image converted to 0 and 1 pixels makes some classification processes more efficient, just like when we avoid a car on the road. We just see the object and avoid it.</p>
    <p class="normal">We perform dimensionality reduction all day long. When you walk from one office to another on the same floor of a building requiring no stairs or an elevator, you are not thinking that the Earth is round and that you're walking over a slight curve. </p>
    <p class="normal">You have performed a <strong class="bold">dimensionality reduction</strong>. You are <a id="_idIndexMarker138"/>also performing a <strong class="bold">manifold</strong> operation. It means that locally, on that floor, you do not need to worry about the global roundness of the Earth. Your manifold view of the Earth in your dimensionality reduction representation is enough to get you from your office to another one on that floor.</p>
    <p class="normal">When you pick up your cup of coffee, you focus on not missing it and aiming for the edges of it. You don't think about every single <strong class="bold">feature</strong> of that cup, such as its size, color, decoration, diameter, and the exact volume of coffee in it. You identify the edge of the cup and pick it up. That is dimensionality reduction. Without dimensionality reduction, nothing can be accomplished. It would take you 10 minutes to analyze the cup of coffee and pick it up in that case!</p>
    <p class="normal">When you pick that cup of coffee up, you test to see whether it is too hot, too cold, or just fine. You don't put a thermometer in the cup to obtain the precise temperature. You have again performed a dimensionality reduction of the features of that cup of coffee. Furthermore, when you picked it up, you computed a manifold representation by just observing the little distance around the cup, reducing the dimension of information around you. You are not worrying about the shape of the table, whether it was dirty on the other side, and other features.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">ML and DL techniques such as dimensionality reduction can be viewed as tools and can be used in any field to speed up calculation times.</p>
    </div>
    <p class="normal">Although we often relate dimensionality reduction to ML and DL, dimensionality reduction is as old as mathematics and even humanity! Somebody, long ago, went to a beach and saw that the sun was beautiful. That person, for the first time in humanity, drew a circle in the sand. The circle was not in 3D like the sun, nor did it have color, but the humans around that person were astonished:</p>
    <ul>
      <li class="list">A group of humans were watching the sun</li>
      <li class="list">A human took the color out</li>
      <li class="list">The human also took the 3D view out</li>
      <li class="list">They represented the sun with a circle in a much smaller dimensional space</li>
      <li class="list">The first mathematician was born!</li>
    </ul>
    <p class="normal">A k-means clustering algorithm provides an efficient way to represent the bot example we are dealing with in this chapter. Each location will form a cluster, as explained in the next section. </p>
    <p class="normal">A workaround to the<a id="_idIndexMarker139"/> missing data problem would be to run the k-means clustering algorithm with the following data format:</p>
    <table id="table002-2" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Index</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Location</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Start from location: Timestamp: yyyy,mm,dd,hh,mm</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">End at location: Timestamp: yyyy,mm,dd,hh,mm</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">001</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
      </tbody>
    </table>
    <h4 class="title">The volume of a training dataset</h4>
    <p class="normal">In this model, we will focus on<a id="_idIndexMarker140"/> six locations to analyze. Six locations are chosen in the main warehouse with a group of truck loading points. Taking around 5,000 examples into account, that should represent the work of all the 25 AGVs purchased by <strong class="bold">AGI-AI</strong> running 24 hours a day.</p>
    <p class="normal">Now that we've talked about optimizing and controlling a dataset, let's move on to coming up with actual solutions. In the next section, we'll talk about implementing k-means clustering.</p>
    <h1 id="_idParaDest-59" class="title">Implementing a k-means clustering solution</h1>
    <p class="normal">The dataset requires<a id="_idIndexMarker141"/> preprocessing to be converted into a prototype to prove the financial value of the project.</p>
    <div class="packt_tip">
      <p>Never implement an ML solution in a corporate environment without knowing how much profit it represents and the cost of getting the job done. Without profit, a company will not survive. ML, like any other investment, must provide a return on investment (ROI). In our case, ML will reduce the cost of transportation in the warehouse by reducing AGV distances.</p>
    </div>
    <h2 id="_idParaDest-60" class="title">The vision</h2>
    <p class="normal">The primary goal of an ML project <a id="_idIndexMarker142"/>involving bots can be summed up in one sentence: finding profit by optimizing bot activity. Achieving that goal will lead to obtaining a budget for a full-scale project.</p>
    <p class="normal">The data provided does not contain distances. However, an estimation can be made per location as follows:</p>
    <p class="center">distance = (end time – start time)/average speed of a bot</p>
    <p class="normal">The start location is <a id="_idIndexMarker143"/>usually a loading point near a pier in this particular warehouse configuration.</p>
    <h3 id="_idParaDest-61" class="title">The data</h3>
    <p class="normal">The data provided<a id="_idIndexMarker144"/> contains start times <em class="italics">s</em><sub style="font-style: italic;">t</sub>, end times <em class="italics">end</em><sub style="font-style: italic;">t</sub>, and delivery locations. To calculate distances, we can use the following equation:</p>
    <p class="center"><em class="italics">d</em><sub style="font-style: italic;">i</sub>(<em class="italics">ll</em>) = (<em class="italics">end</em><sub style="font-style: italic;">t</sub> – <em class="italics">s</em><sub style="font-style: italic;">t</sub>)/<em class="italics">v</em></p>
    <ul>
      <li class="list"><em class="italics">v</em> = velocity of the AGV per minute</li>
      <li class="list"><em class="italics">end</em><sub style="font-style: italic;">t</sub> – <em class="italics">s</em><sub style="font-style: italic;">t</sub> is expressed in minutes</li>
      <li class="list"><em class="italics">d</em><sub style="font-style: italic;">i</sub> = estimated distance an AGV has gone in a given time</li>
    </ul>
    <p class="normal">A preprocessing program will read the initial file format and data and output a new file, <code class="Code-In-Text--PACKT-">data.csv</code>, in the following reduced dimensionality format with two features:</p>
    <table id="table003" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Distance</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Location</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">55</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">53</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">18</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">17</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h4 class="title">Conditioning management</h4>
    <p class="normal">Data conditioning <a id="_idIndexMarker145"/>means preparing the data that will become the input of the system. <strong class="bold">Poor conditioning</strong> can have two outcomes:</p>
    <ul>
      <li class="list">Bad data <a id="_idIndexMarker146"/>containing noise that makes no difference (large volumes and minor errors)</li>
      <li class="list">Bad data containing noise that makes a difference (regardless of volumes, the data influences the outcome)</li>
    </ul>
    <p class="normal">In this particular case, let's suppose that out of the 5,000 records provided for the dataset, 25 distances are not reliable. A 0.005% noise level should not be a problem. The amount of acceptable noise depends on each project. It cannot be an arbitrary figure.</p>
    <p class="normal">Sometimes, noise will have a profound effect, and sometimes it will not. Suppose 2,500 records out of 5,000 records contained noise. Maybe the 2,500 remaining records provide a sufficient variety of samples to produce a reliable result. In another case, maybe, 10 missing samples out of 5,000 records will stop a project because those 10 samples were the only ones of a special kind that could critically change the calculations.</p>
    <p class="normal">You will have to experiment and determine the level of acceptable noise for a given project.</p>
    <p class="normal">Let's get our hands <a id="_idIndexMarker147"/>dirty and analyze the data.</p>
    <p class="normal">The location numbers start at #1. #1 is near the loading point of the products. The bot has to bring the products to this point. To be more precise, in this warehouse configuration, the bot goes and gets a box (or crate) of products and brings them back to location 1. At location 1, humans check the products and package them. After that, humans carefully load the products in the delivery trucks.</p>
    <p class="normal">The distance from one location to the next is about 1 meter. For example, from location 1 to location 5, the distance is about 5 meters, or 5 m. Also, since all locations lead to location 1 for the AGVs in this model, the theoretical distances will be calculated from location 1. To generalize the rule and define a distance <em class="italics">d</em><sub style="font-style: italic;">i</sub> for a location <em class="italics">lj</em> the calculation can be simplified:</p>
    <p class="center"><em class="italics">d</em><sub style="font-style: italic;">i</sub>(<em class="italics">lj</em>)=<em class="italics">lj</em></p>
    <p class="normal"><em class="italics">d</em><sub style="font-style: italic;">i</sub> is expressed in meters. Since the locations start at number 1 through <em class="italics">n</em>, the location number is equal to the approximate distance from the first location from which the bots depart.</p>
    <p class="normal">Let us suppose that, looking at the data, it quickly appears that many distances are superior to their location numbers. That is strange because the distance should be about equal to the location. Thus, by reducing the number of dimensions and focusing on approximations of the main features, key concepts can be represented.</p>
    <p class="normal">The time has come to build a strategy and a program.</p>
    <h3 id="_idParaDest-62" class="title">The strategy</h3>
    <p class="normal">As in all ML projects, there are key standard corporate guidelines<a id="_idIndexMarker148"/> that should not be avoided:</p>
    <ul>
      <li class="list">Quickly write a proof of concept (POC). A POC will prove that the ML solution will be efficient. In this case, bot activity will be visualized.</li>
      <li class="list">Check the results in detail.</li>
      <li class="list">Calculate the potential optimized profit with a solution that is yet to be found. Profit will justify the investment. The cost can be an indicator. But then cost reduction must be sufficient to increase profit by a significant rate for a given corporation.</li>
      <li class="list">Obtain approval with a solid case and obtain a green light for the project.</li>
    </ul>
    <p class="normal">Now that our strategy <a id="_idIndexMarker149"/>is clear, we can choose a model. k-means clustering is a good algorithm to start with for this project. It will create clusters that almost literally represent the areas in which the AGVs should be located. By choosing simple dimensions, the visual representation is close enough to reality for a user to understand the calculations.</p>
    <h2 id="_idParaDest-63" class="title">The k-means clustering program</h2>
    <p class="normal">k-means clustering <a id="_idIndexMarker150"/>is a powerful unsupervised learning algorithm. We often perform k-means clustering in our lives. Take, for example, a lunch you want to organize for a team of about 50 people in an open space that can just fit those people.</p>
    <p class="normal">Your friend and another friend first decide to set up a table in the middle. Your friend points out that the people in that room will form a big cluster <em class="italics">k</em>, and with only one table in the geometric center (or centroid) <em class="italics">c</em>, it will not be practical. The people near the wall will not have access to the main table, as shown in the following figure.</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_01.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/1table.png"/></figure>
    <p class="packt_figref">Figure 4.1: A scenario where people try to cluster around a single table</p>
    <p class="normal">The people not close to the table (the rectangle in the middle) will not have easy access to the table.</p>
    <p class="normal">You now try two tables (centroids) <em class="italics">c</em><sub>1</sub> and <em class="italics">c</em><sub>2</sub> in various places for two clusters of people <em class="italics">k</em><sub>1</sub> and <em class="italics">k</em><sub>2</sub>.</p>
    <p class="normal">The people <em class="italics">x</em><sub>1</sub> to <em class="italics">x</em><sub style="font-style: italic;">n</sub> form a dataset <em class="italics">X</em>. When imagining <em class="italics">X</em>, it appears that the table is not in the right place.</p>
    <p class="normal">The best thing to do is to move a table <em class="italics">c</em>, and then estimate that the mean distance of the people (a subset of <em class="italics">X</em>) to the table will be about the same in their group or cluster <em class="italics">k</em>. The same is done for the other table. You draw a line with chalk on the floor to make sure that each group or cluster is at about the mean distance from its table.</p>
    <p class="normal">This intuitive approach to <a id="_idIndexMarker151"/>k-means clustering can be summed up as follows:</p>
    <ul>
      <li class="list"><strong class="bold">Step 1</strong>: You have been drawing lines with chalk to decide which group (cluster <em class="italics">k</em>) each person <em class="italics">x</em> will be in, by looking at the mean distance from the table <em class="italics">c</em>.</li>
      <li class="list"><strong class="bold">Step 2</strong>: You have been moving the tables around accordingly to optimize step 1.</li>
    </ul>
    <p class="normal">A Python program simulating a three-table model computed using k-means clustering would produce the following result:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_02.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/3tables.png"/></figure>
    <p class="packt_figref">Figure 4.2: A three-table model computed by k-means clustering</p>
    <p class="normal">Having provided an intuitive example, let's talk about the mathematical definition of k-means clustering.</p>
    <h3 id="_idParaDest-64" class="title">The mathematical definition of k-means clustering</h3>
    <p class="normal">Dataset <em class="italics">X</em> provides <em class="italics">N</em> points. These <a id="_idIndexMarker152"/>points or data points are formed by using distance as the <em class="italics">x</em>-axis in a Cartesian representation and the location as the <em class="italics">y</em>-axis in a Cartesian representation. This low-level representation is a white box approach, even if the data is processed and transformed by the algorithm. A white box approach is when the process is transparent, and we can actually see what the algorithm is doing. A black box is when an input goes into a system, and we will not be able to understand what the system did by just looking at the result.</p>
    <p class="normal">However, high-level representations are required to represent more features through clusters. In that case, it will not be possible to see a direct link between the actual meanings and their ML representation. We will explore these high-dimensional representations in the chapters to come.</p>
    <p class="normal">If you have one bot in location 1 as the first record of your file, it will be represented as <em class="italics">x</em> axis = 1 and <em class="italics">y</em> axis = 1 by the black dot, which is the data point, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_03.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_06_2.jpg"/></figure>
    <p class="packt_figref">Figure 4.3: Cartesian representation</p>
    <p class="normal">In this example, 5,000 records are loaded from <code class="Code-In-Text--PACKT-">data.csv</code>, which is in the same directory as the program. The data is unlabeled with no linear separation. The goal is to allocate the <em class="italics">X</em> data points to <em class="italics">K</em> clusters. The number of clusters is an input value. Each cluster will have its geometric center or centroid. If you decide to have three clusters <em class="italics">K</em>, then the result will be as follows:</p>
    <ul>
      <li class="list">Three clusters <em class="italics">K</em> in three colors in a visual representation</li>
      <li class="list">Three geometric centers or centroids representing the center of the mean of the sum of distances of <em class="italics">x</em> data points of that cluster</li>
    </ul>
    <p class="normal">If you decide on six clusters, then you will obtain six centroids, and so on.</p>
    <p class="normal">Described in mathematical terms, the formula in respect of <img src="../Images/B15438_04_002.png" alt=""/>, <img src="../Images/B15438_04_003.png" alt=""/> is as follows:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_004.png" alt=""/></figure>
    <p class="normal">The sum of each <em class="italics">k</em> (cluster) from 1 to the number of clusters <em class="italics">K</em> of the sum of all distances of members <em class="italics">x</em><sub style="font-style: italic;">i</sub> to <em class="italics">x</em><sub style="font-style: italic;">n</sub> of each cluster <em class="italics">K</em> from their position to the geometric center (centroid) <img src="../Images/B15438_04_005.png" alt=""/> must be minimized.</p>
    <p class="normal">The smaller the <a id="_idIndexMarker153"/>distance from each member <em class="italics">x</em> to centroid <img src="../Images/B15438_04_005.png" alt=""/>, the more the system is optimized. Note that the distance is squared each time because this is a Euclidean distance in this version of the algorithm.</p>
    <p class="normal">The Euclidean distance, in one dimension, is the distance between two points, <em class="italics">x</em> and <em class="italics">y</em>, for example, expressed as follows:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_007.png" alt=""/></figure>
    <p class="normal">The distance between <em class="italics">x</em> and <em class="italics">y</em> expressed in Euclidean distance is not the real distance that an AGV will actually travel inside a warehouse. The model in the chapter was built so that the distances would remain sufficiently realistic to make good clusters and improve the organization of the warehouse. It's sufficient because an AGV will often go in nearly straight lines from a pier to the closest aisle and then to a storage point, for example.</p>
    <p class="normal">To calculate the actual distances, we often use Manhattan distances. Manhattan distances are taxi-cab distances. You calculate the distance up a block then to the left, for example, another block and so on, adding the distances along the way. This is because you can't drive through the buildings.</p>
    <p class="normal">In our case, it would be like saying that a taxi-cab can only, more or less, drive up and down a given avenue, like a bus, and avoid turning right or left.</p>
    <p class="normal">We will use Lloyd's algorithm with Euclidean distances to estimate the clusters that AGVs will have to stay in to avoid wandering.</p>
    <h4 class="title">Lloyd's algorithm</h4>
    <p class="normal">There are several <a id="_idIndexMarker154"/>variations of Lloyd's algorithm. But all of them follow a common philosophy.</p>
    <p class="normal">For a given <em class="italics">x</em><sub style="font-style: italic;">n</sub> (data point), the distance from the centroid <img src="../Images/B15438_04_005.png" alt=""/> in its cluster must be less than going to another center, just like how a person in the lunch example wants to be closer to one table rather than having to go far to get a sandwich because of the crowd.</p>
    <p class="normal">The best centroid <img src="../Images/B15438_04_005.png" alt=""/> for a given <em class="italics">x</em><sub style="font-style: italic;">n</sub> is as follows:</p>
    <p class="center"><img src="../Images/B15438_04_010.png" alt=""/></p>
    <p class="normal">This calculation is done for all <img src="../Images/B15438_04_005.png" alt=""/> (centroids) in all the clusters from <em class="italics">k</em><sub>1</sub> to <em class="italics">K</em>.</p>
    <p class="normal">Once each <em class="italics">x</em><sub style="font-style: italic;">i</sub> has been allocated to a <em class="italics">K</em><sub style="font-style: italic;">k</sub>, the algorithm recomputes <img src="../Images/B15438_04_005.png" alt=""/> by calculating the means of all the points that belong to each cluster and readjusts the centroid <img src="../Images/B15438_04_013.png" alt=""/>.</p>
    <p class="normal">We've now covered all of the concepts that we need to begin coding. Let's get into the Python program!</p>
    <h3 id="_idParaDest-65" class="title">The Python program</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">k-means_clustering_1.py</code>, the <a id="_idIndexMarker155"/>Python program, uses the <code class="Code-In-Text--PACKT-">sklearn</code> library, <code class="Code-In-Text--PACKT-">pandas</code> for data analysis (only used to import the data in this program), and <code class="Code-In-Text--PACKT-">matplotlib</code> to plot the results as data points (the coordinates of the data) and clusters (data points classified in each cluster with a color). First, the following models are imported:</p>
    <pre class="programlisting"><code class="hljs elm"><span class="hljs-title">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-title">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt
</code></pre>
    <p class="normal">Next, we'll go through the stages of implementing k-means clustering.</p>
    <h4 class="title">1 – The training dataset</h4>
    <p class="normal">The training dataset consists of<a id="_idIndexMarker156"/> 5,000 lines. The first line contains a header for maintenance purposes (data checking), which is <em class="italics">not</em> used. k-means clustering is an <strong class="bold">unsupervised learning</strong> algorithm, meaning that it classifies unlabeled data into cluster-labeled data to<a id="_idIndexMarker157"/> make future predictions. The following code displays the dataset:</p>
    <pre class="programlisting"><code class="hljs stylus"><span class="hljs-selector-id">#I</span>. The training Dataset
dataset = pd.read_csv(<span class="hljs-string">'data.csv'</span>)
<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dataset.head()</span></span>)
<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dataset)</span></span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">print(dataset)</code> line can be useful (though not necessary) to check the training data during a prototype phase or for maintenance purposes. The following output confirms that the data was correctly imported:</p>
    <pre class="programlisting"><code class="hljs awk"><span class="hljs-string">'''Output of print(dataset)
Distance location
0 80 53
1 18 8
2 55 38
...
'''</span>
</code></pre>
    <h4 class="title">2 – Hyperparameters</h4>
    <p class="normal"><strong class="bold">Hyperparameters</strong> determine the behavior of the <a id="_idIndexMarker158"/>computation method. In this case, two hyperparameters<a id="_idIndexMarker159"/> are necessary:</p>
    <ul>
      <li class="list">The <code class="Code-In-Text--PACKT-">k</code> number of clusters that will be computed. This number can and will be changed during the case study meetings to find out the best organization process, as explained in the next section. After a few runs, we will intuitively set <code class="Code-In-Text--PACKT-">k</code> to <code class="Code-In-Text--PACKT-">6</code>.</li>
      <li class="list">The <em class="italics">f</em>-number of features that will be taken into account. In this case, there are two features: distance and location.</li>
    </ul>
    <p class="normal">The program implements a k-means function, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-comment">#II.Hyperparameters</span>
<span class="hljs-comment"># Features = 2</span>
<span class="hljs-attr">k</span> = <span class="hljs-number">6</span>
<span class="hljs-attr">kmeans</span> = KMeans(n_clusters=k)
</code></pre>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">Features</code> hyperparameter is commented. In this case, the number of features is implicit and determined by the format of the training dataset, which contains two columns.</p>
    <h4 class="title">3 – The k-means clustering algorithm</h4>
    <p class="normal"><code class="Code-In-Text--PACKT-">sklearn</code> now does the<a id="_idIndexMarker160"/> job using the training dataset and hyperparameters in the following lines of code:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-comment">#III.k-means clustering algorithm</span>
<span class="hljs-attr">kmeans</span> = kmeans.fit(dataset) <span class="hljs-comment">#Computing k-means clustering</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">gcenters</code> array contains the geometric centers or centroids and can be printed for verification purposes, as shown in this snippet:</p>
    <pre class="programlisting"><code class="hljs 1c">gcenters = kmeans.cluster_centers_
print(<span class="hljs-string">"The geometric centers or centroids:"</span>)
print(gcenters)
'''Ouput of centroid coordinates
[[ 48.<span class="hljs-number">798675</span>5 85.<span class="hljs-number">76688742</span>]
[ 32.<span class="hljs-number">12590799</span> 54.<span class="hljs-number">84866828</span>]
[ 96.<span class="hljs-number">06151645</span> 84.<span class="hljs-number">57939914</span>]
[ 68.<span class="hljs-number">84578885</span> 55.<span class="hljs-number">63226572</span>]
[ 48.<span class="hljs-number">44532803</span> 24.<span class="hljs-number">433399</span>6 ]
[ 21.<span class="hljs-number">38965517</span> 15.<span class="hljs-number">04597701</span>]]
'''
</code></pre>
    <p class="normal">These geometric centers need to be visualized with labels for decision-making purposes.</p>
    <h4 class="title">4 – Defining the result labels</h4>
    <p class="normal">The initial unlabeled data <a id="_idIndexMarker161"/>can now be classified into cluster labels, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-comment">#IV.Defining the Result labels</span>
<span class="hljs-attr">labels</span> = kmeans.labels_
<span class="hljs-attr">colors</span> = [<span class="hljs-string">'blue'</span>,<span class="hljs-string">'red'</span>,<span class="hljs-string">'green'</span>,<span class="hljs-string">'black'</span>,<span class="hljs-string">'yellow'</span>,<span class="hljs-string">'brown'</span>,<span class="hljs-string">'orange'</span>]
</code></pre>
    <p class="normal">Colors can be used for semantic purposes beyond nice display labels. A color for each top customer or leading product can be assigned, for example.</p>
    <h4 class="title">5 – Displaying the results – data points and clusters</h4>
    <p class="normal">To make sense to a<a id="_idIndexMarker162"/> team or management, the program now prepares to display the<a id="_idIndexMarker163"/> results as <strong class="bold">data points</strong> and <strong class="bold">clusters</strong>. The<a id="_idIndexMarker164"/> data will be represented as coordinates and the clusters as colors <a id="_idIndexMarker165"/>with a <strong class="bold">geometric center</strong> or <strong class="bold">centroid</strong>, as<a id="_idIndexMarker166"/> implemented in this code:</p>
    <pre class="programlisting"><code class="hljs sas">#V.Displaying the results : datapoints <span class="hljs-meta">and</span> clusters
y = 0
for <span class="hljs-meta">x</span> <span class="hljs-meta">in</span> labels:
    plt.scatter(dataset.iloc[y,0], dataset.iloc[y,1],color=colors[<span class="hljs-meta">x</span>])
    y+=1
for <span class="hljs-meta">x</span> <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>k):
    lines = plt.plot(gcenters[<span class="hljs-meta">x</span>,0],gcenters[<span class="hljs-meta">x</span>,1],<span class="hljs-string">'kx'</span>)
<span class="hljs-meta">title</span> = (<span class="hljs-string">'No of clusters (k) = {}'</span>).<span class="hljs-meta">format</span>(k)
plt.<span class="hljs-meta">title</span>(<span class="hljs-meta">title</span>)
plt.xlabel(<span class="hljs-string">'Distance'</span>)
plt.ylabel(<span class="hljs-string">'Location'</span>)
plt.show()
</code></pre>
    <p class="normal">The dataset is now ready to <a id="_idIndexMarker167"/>be analyzed. The data has been transformed into data points (Cartesian points) and clusters (the colors). The <em class="italics">x</em> points represent the geometric centers or centroids, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_04.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/KMeansClusters.jpg"/></figure>
    <p class="packt_figref">Figure 4.4: Output (data points and clusters)</p>
    <h4 class="title">Test dataset and prediction</h4>
    <p class="normal">In this case, the test dataset<a id="_idIndexMarker168"/> has two main functions. First, some test data confirms<a id="_idIndexMarker169"/> the <strong class="bold">prediction</strong> level of the trained and now-labeled dataset. The input contains random distances and locations. The following code implements the output that predicts which cluster the data points will be in:</p>
    <pre class="programlisting"><code class="hljs asciidoc">#VI.Test dataset and prediction
x<span class="hljs-emphasis">_test = [[40.0,67],[20.0,61],[90.0,90],
          [50.0,54],[20.0,80],[90.0,60]]
prediction = kmeans.predict(x_</span>test)
print("The predictions:")
print (prediction)
'''
Output of the cluster number of each example
<span class="hljs-meta">[3 3 2 3 3 4]</span>
'''
</code></pre>
    <p class="normal">The second purpose, in the future, will be to enter data for <strong class="bold">decision-making</strong> purposes, as explained in the next section.</p>
    <h2 id="_idParaDest-66" class="title">Saving and loading the model</h2>
    <p class="normal">In this section, <code class="Code-In-Text--PACKT-">k-means_clustering_1.py</code> will save the model using Pickle. Pickle, a Python library, saves the <a id="_idIndexMarker170"/>model in a serialized file, as shown at the end of the program:</p>
    <pre class="programlisting"><code class="hljs sas"># save model
<span class="hljs-meta">filename</span>=<span class="hljs-string">"kmc_model.sav"</span>
pickle.dump(kmeans,<span class="hljs-meta"> open(</span><span class="hljs-meta">filename</span>, <span class="hljs-string">'wb'</span>))
</code></pre>
    <p class="normal">The Python<a id="_idIndexMarker171"/> Pickle module is imported in the header <a id="_idIndexMarker172"/>of the program:</p>
    <pre class="programlisting"><code class="hljs elm"><span class="hljs-keyword">import</span> pickle
</code></pre>
    <p class="normal">Now, the model, <code class="Code-In-Text--PACKT-">kmeans</code>, is saved in a file named <code class="Code-In-Text--PACKT-">kmc_model.sav</code>.</p>
    <p class="normal">To test this model, we will now open <code class="Code-In-Text--PACKT-">k-means_clustering_2.py</code> to load the model without any training involved and make predictions:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-comment">#load model</span>
<span class="hljs-attr">filename</span>=<span class="hljs-string">"kmc_model.sav"</span>
<span class="hljs-attr">kmeans</span> = pickle.load(open(filename, <span class="hljs-string">'rb'</span>))
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">kmc_model.save</code> is loaded and plugged into a classifier called <code class="Code-In-Text--PACKT-">kmeans</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">x_test</code> same test data as in <code class="Code-In-Text--PACKT-">k-means_clustering_1.py</code>:</p>
    <pre class="programlisting"><code class="hljs angelscript">#test data
x_test = [[<span class="hljs-number">40.0</span>,<span class="hljs-number">67</span>],[<span class="hljs-number">20.0</span>,<span class="hljs-number">61</span>],[<span class="hljs-number">90.0</span>,<span class="hljs-number">90</span>],
          [<span class="hljs-number">50.0</span>,<span class="hljs-number">54</span>],[<span class="hljs-number">20.0</span>,<span class="hljs-number">80</span>],[<span class="hljs-number">90.0</span>,<span class="hljs-number">60</span>]]
</code></pre>
    <p class="normal">We now run and display the predictions:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-comment">#prediction</span>
prediction = kmeans.predict(x_test)
<span class="hljs-builtin-name">print</span>(<span class="hljs-string">"The predictions:"</span>)
<span class="hljs-builtin-name">print</span> (prediction)
</code></pre>
    <p class="normal">The predictions are the same as in <code class="Code-In-Text--PACKT-">k-means_clustering_1.py</code>:</p>
    <pre class="programlisting"><code class="hljs angelscript">The predictions:
[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>]
</code></pre>
    <p class="normal">Each prediction<a id="_idIndexMarker173"/> is an output cluster number from 0 to<a id="_idIndexMarker174"/> 5 of the corresponding coordinates used as input. For example, [40.0,67] is a part of cluster #0.</p>
    <p class="normal">The next step is to analyze the results.</p>
    <h2 id="_idParaDest-67" class="title">Analyzing the results</h2>
    <p class="normal">The following image<a id="_idIndexMarker175"/> shows the gain zone. The gain zone is the zone in which the distances exceed the value 80.</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_05.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/KMeansClusters_2.jpg"/></figure>
    <p class="packt_figref">Figure 4.5: Gain zone area</p>
    <p class="normal">The gain zone area provides useful information.</p>
    <p class="normal">From the computations made, that gain zone shows the losses made on the locations displayed. It takes a sample of the possible locations into account. 10% of the total distance could be saved.</p>
    <p class="normal">The cause is that the bots are not going directly to the right locations, but are <em class="italics">wandering</em> around unplanned obstacles.</p>
    <p class="normal">The average distance from one location to another is 1 meter. The AGVs all start from location 0 or 1. So the distance is strictly proportional to the locations in this particular example.</p>
    <p class="normal">To find the gain zone of a location, you draw a red horizontal line from location 80, for example, and a vertical line from a distance 80 (add a couple of meters to take small variances into account).</p>
    <p class="normal">Data analysis is made easier by data visualization. Visualizing the clusters makes it easier for management to understand the outputs and make decisions.</p>
    <p class="normal">None of the data points <a id="_idIndexMarker176"/>on the 80-location line should be beyond the maximum limit. The limit is 80 meters + a small variance of a few meters. Beyond that line, on the right-hand side of the figure, is where the company is losing money, and something must be done to optimize the distances. This loss zone is the gain zone for a project. The gain zone on the k-means cluster results shows that some of the locations of 40 to 60 exceed a distance of 80 meters.</p>
    <h3 id="_idParaDest-68" class="title">Bot virtual clusters as a solution</h3>
    <p class="normal">Planners <a id="_idIndexMarker177"/>anticipate bot tasks. They send them to probable locations from which they will have to pick up products and bring them back to the truck-loading points.</p>
    <p class="normal">In the following example, we will take the example of AGVs that are assigned to a cluster area for locations 40 to 60. If an AGV goes further, up to location 70, for example, a penalty of 10 virtual (estimated) meters is added to its performance. It is easy to check. If an AGV is detected at location 70, it is out of its area.</p>
    <p class="normal">The business rule for the AGV assigned to locations 40 to 60 is that it must never exceed location 60. If the software planning the events works well, it will never assign the AGV to an area exceeding location 60. Business rules must thus be provided to the planners.</p>
    <p class="normal">One of the solutions is to provide AGV virtual clusters as a business rule, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B15438_04_06.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/KMeansClusters3.jpg"/></figure>
    <p class="packt_figref">Figure 4.6: AGV virtual clusters</p>
    <p class="normal">The rules are as follows:</p>
    <ul>
      <li class="list"><strong class="bold">Rule 1</strong>: The line in the middle represents a new business rule. In phase 1 of the project, an AGV used for locations 40 to 60 cannot go beyond 60 meters plus a small variance line.</li>
      <li class="list"><strong class="bold">Rule 2</strong>: A <a id="_idIndexMarker178"/>cluster will represent the pick-up zone for an AGV. The centroid will now be its parking zone. Distances will be optimized until all the clusters respect rule 1. If rule 1 is not followed, the AGVs will travel unnecessary distances, increasing the overall cost of transporting goods in the warehouse.</li>
    </ul>
    <h3 id="_idParaDest-69" class="title">The limits of the implementation of the k-means clustering algorithm</h3>
    <p class="normal">In this chapter, an example<a id="_idIndexMarker179"/> was explored. When the volumes increase, the features reach high-level abstract representations, and noise pollutes the data, humans face several problems:</p>
    <ul>
      <li class="list">How do we analyze a result that surpasses human analytical capacity?</li>
      <li class="list">Is the algorithm reliable for larger datasets that may contain features that were overlooked?</li>
    </ul>
    <p class="normal">In <em class="italics">Chapter 5</em>, <em class="italics">How to Use Decision Trees to Enhance k-Means Clustering</em>, we will explore these problems and find solutions.</p>
    <h1 id="_idParaDest-70" class="title">Summary</h1>
    <p class="normal">Up to this point, we have explored Python with the NumPy, TensorFlow, scikit-learn, pandas, and Matplotlib libraries. More platforms and libraries will be used in this book. In the months and years to come, even more languages, libraries, frameworks, and platforms will appear on the market.</p>
    <p class="normal"><em class="italics">However, AI is not only about development techniques</em>. Building a k-means clustering program from scratch requires careful planning. The program relies on data that is rarely available as we expect it. That's where our imagination comes in handy to find the right features for our datasets.</p>
    <p class="normal">Once the dataset has been defined, poor conditioning can compromise the project. Some small changes in the data will lead to incorrect results.</p>
    <p class="normal">Preparing the training dataset from scratch takes much more time than we would initially expect. AI was designed to make life easier, but that's after a project has been successfully implemented. The problem is that building a solution requires major dataset work and constant surveillance.</p>
    <p class="normal">Then comes the hard work of programming a k-means clustering solution that must be explained to a team. Lloyd's algorithm comes in very handy to that effect by reducing development time.</p>
    <p class="normal">In the next chapter, <em class="italics">When and How to Use Artificial Intelligence</em>, we will seek solutions to the limits of k-means clustering problems through dataset techniques. We will also explore random forests and enter the world of ensemble meta-algorithms, which will provide assisted AI to humans to analyze machine thinking.</p>
    <h1 id="_idParaDest-71" class="title">Questions</h1>
    <ol>
      <li class="list">Can a prototype be built with random data in corporate environments? (Yes | No)</li>
      <li class="list">Do design matrices contain one example per matrix? (Yes | No)</li>
      <li class="list">AGVs can never be widespread. (Yes | No)</li>
      <li class="list">Can k-means clustering be applied to drone traffic? (Yes | No)</li>
      <li class="list">Can k-means clustering be applied to forecasting? (Yes | No)</li>
      <li class="list">Lloyd's algorithm is a two-step approach. (Yes | No)</li>
      <li class="list">Do hyperparameters control the behavior of the algorithm? (Yes | No)</li>
      <li class="list">Once a program works, the way it is presented does not matter. (Yes | No)</li>
      <li class="list">k-means clustering is only a classification algorithm. It's not a prediction algorithm. (Yes | No)</li>
    </ol>
    <h1 id="_idParaDest-72" class="title">Further reading</h1>
    <ul>
      <li class="list">The scikit-learn website contains additional information on k-means clustering: <a href="http://scikitlearn.org/stable/modules/generated/sklearn.cluster.KMeans.html"><span class="url">http://scikitlearn.org/stable/modules/generated/sklearn.cluster.KMeans.html</span></a></li>
      <li class="list">You can find Python's data analysis library here: <a href="https://pandas.pydata.org/"><span class="url">https://pandas.pydata.org/</span></a></li>
    </ul>
  </div>
</body></html>