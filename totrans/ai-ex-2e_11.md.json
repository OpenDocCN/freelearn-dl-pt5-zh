["```py\n#II. Convolutional Neural Network (CNN)\n#loads,traffic,food processing\nA=['dataset_O/','dataset_traffic/','dataset/']\nMS1=['loaded','jammed','productive']\nMS2=['unloaded','change','gap']\ndisplay=1     #display images\nscenario=2    #reference to A,MS1,MS2\ndirectory=A[scenario] #transfer learning parameter (choice of images)\nCRLMN=1       # concept learning\nprint(\"Classifier frame directory\",directory) \n```", "```py\ndef CRLMM(Q,lr,e):    # [Line 180] \n```", "```py\n status=random.randint(0,1) \n```", "```py\n if(status==0):\n        #Add frame from video stream (connect to webcam)\n        s=identify(directory+'classify/img1.jpg',e)\n    if(status==1):\n        #Add frame from video stream (connect to webcam)\n        s=identify(directory+'classify/img2.jpg',e)\n    s1=int(s[0])\n    if (int(s1)==0):\n        print('Classified in class A')\n        print(MS1[scenario])\n        print('Seeking...')\n    if (int(s1)==1):\n        print('Classified in class B')\n        print(MS2[scenario])\n    return s1 \n```", "```py\nL=['A','B','C','D','E','F']    # [Line 37] \n```", "```py\n# R is The Reward Matrix for each state built on the physical graph    [Line 41]\n# Ri is a memory of this initial state: no rewards and undirected\nR = ql.matrix([[0,0,0,0,1,0],\n               [0,0,0,1,0,1],\n               [0,0,0,1,0,0],\n               [0,1,1,0,1,0],\n               [1,0,0,1,0,0],\n               [0,1,0,0,0,0]])\nRi = ql.matrix([[0,0,0,0,1,0],\n                [0,0,0,1,0,1],\n                [0,0,0,1,0,0],\n                [0,1,1,0,1,0],\n                [1,0,0,1,0,0],\n                [0,1,0,0,0,0]]) \n```", "```py\nQ = ql.matrix(ql.zeros([6,6]))    # [Line 58] \n```", "```py\nW=[0,0,0,0,0,0]    # [Line 40] \n```", "```py\n[[ 0\\. 0\\. 0\\. 0\\. 105.352 0\\. ]\n[ 0\\. 0\\. 0\\. 130.44 0\\. 201\\. ]\n[ 0\\. 0\\. 0\\. 130.44 0\\. 0\\. ]\n[ 0\\. 161.8 105.352 0\\. 105.352 0\\. ]\n[ 85.2816 0\\. 0\\. 130.44 0\\. 0\\. ]\n[ 0\\. 0\\. 0\\. 0\\. 0\\. 250\\. ]]\nNormed Q :\n[[ 0\\. 0\\. 0\\. 0\\. 42.1408 0\\. ]\n[ 0\\. 0\\. 0\\. 52.176 0\\. 80.4 ]\n[ 0\\. 0\\. 0\\. 52.176 0\\. 0\\. ]\n[ 0\\. 64.72 42.1408 0\\. 42.1408 0\\. ]\n[ 34.11264 0\\. 0\\. 52.176 0\\. 0\\. ]\n[ 0\\. 0\\. 0\\. 0\\. 0\\. 100\\. ]] \n```", "```py\nState of frame : 3 D\n0 A E 161.8\n1 B D 201.0\n2 C D 201.0\n3 D D 250.0\n4 E A 130.44\n4 E D 201.0\n5 F B 161.8 \n```", "```py\n #Graph structure    [Line 187]\n    RL=['','','','','','']\n    RN=[0,0,0,0,0,0]\n    print(\"State of frame :\",lr,L[lr])\n    for i in range(6):\n        maxw=0\n        for j in range(6):\n            W[j]+=logistic_sigmoid(Q[i,j])\n            if(Q[i,j]>maxw):\n                RL[i]=L[j]\n                RN[i]=Q[i,j]\n                maxw=Q[i,j]\n                print(i,L[i],RL[i],RN[i]) \n```", "```py\nloaded_model.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=['accuracy'])    # [Line 92] \n```", "```py\nQ :\n[[ 0\\. 0\\. 0\\. 0\\. 321.8 0\\. ]\n [ 0\\. 0\\. 0\\. 401\\. 0\\. 258.44]\n [ 0\\. 0\\. 0\\. 401\\. 0\\. 0\\. ]\n [ 0\\. 0\\. 0\\. 500\\. 0\\. 0\\. ]\n [ 258.44 0\\. 0\\. 401\\. 0\\. 0\\. ]\n [ 0\\. 321.8 0\\. 0\\. 0\\. 0\\. ]] \n```", "```py\n#Logistic Sigmoid function to squash the weights    [Line 118]\ndef logistic_sigmoid(w):\n    return 1 / (1 + math.exp(-w)) \n```", "```py\n for i in range(6):    # [Line 191]\n        maxw=0\n        for j in range(6):\n            W[j]+=logistic_sigmoid(Q[i,j]) \n```", "```py\nVertex Weights [3.5, 3.5, 3.0, 5.0, 3.5, 3.5] \n```", "```py\n# input_output_frequency : output every n frames/ retained memory    [Line 315]\noif=10\n#input_output_rate p% (memory retained)\noir=0.2\nfc=0 #frequency counter : memory output\nfor e in range(episodes):\n    print(\"episode:frame #\",e)\n    fc=fc+1\n    #memory management : lambda output\n    if(fc>=10):\n        for fci in range(6):\n            W[fci]=W[fci]*oir\n            fc=0\n            print(\"OUTPUT OPERATION - MEMORY UPDATED FOR \",L[fci],\n                  \" \",oir,\"% retained\") \n```", "```py\nOUTPUT OPERATION - MEMORY UPDATED FOR A 0.2 % retained\nOUTPUT OPERATION - MEMORY UPDATED FOR B 0.2 % retained\nOUTPUT OPERATION - MEMORY UPDATED FOR C 0.2 % retained\nOUTPUT OPERATION - MEMORY UPDATED FOR D 0.2 % retained\nOUTPUT OPERATION - MEMORY UPDATED FOR E 0.2 % retained\nOUTPUT OPERATION - MEMORY UPDATED FOR F 0.2 % retained \n```", "```py\n #first episode is random\n    if(e==0):\n        lr=random.randint(0,5) \n```", "```py\n crlmm=CRLMM(Q,lr,e)    # [Line 388] \n```", "```py\n if(e>0):\n        lr=0\n        minw=10000000\n        maxw=-1\n        #no G => Finding the largest gap (most loaded resource or a distance)\n        if(crlmm==0):\n            for wi in range(3):\n                op=random.randint(0,5)\n                if(W[op]<minw):\n                    lr=op;minw=W[op]\n        #G => Finding the smallest gap (a least loaded resource or a distance)\n        if(crlmm==1):\n            for wi in range(3):\n                op=random.randint(0,5)\n                if(W[op]>maxw):\n                    lr=op;maxw=W[op] \n```", "```py\n print(\"LR TARGET STATE MDP number and letter:\",lr,L[lr]) \n```", "```py\n #initial reward matrix set again\n    for ei in range(6):\n        for ej in range(6):\n            Q[ei,ej]=0\n            if(ei !=lr):\n                R[ei,ej]=Ri[ei,ej]\n            if(ei ==lr):\n                R[ei,ej]=0 #to target, not from \n```", "```py\n #no G\n    rew=100\n    #G\n    if(crlmm==1):\n        rew=50\n    R[lr,lr]=rew\n    print(\"Initial Reward matrix with vertex locations:\",R) \n```", "```py\n crlmm=CRLMM(Q,lr,e)    # [Line 388]\n    print(\"GAP =0 or GAP =1 status: \",crlmm) \n```", "```py\nimage dataset/classify/img1.jpg predict_probability: [[ 0.]] prediction: [[ 0.]]\nClassified in class A\nProductive\nSeeking...\nGAP =0 or GAP =1 status: 0 \n```", "```py\n MDP_GRAPH(lr,e)    # [Line 390]\n    print(\"Vertex Weights\",W) \n```", "```py\nVertex Weights [9.4, 11.100000000000001, 10.2, 12.0, 11.7, 10.0] \n```"]