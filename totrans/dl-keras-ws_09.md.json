["```py\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import pandas as pd\n    from tensorflow import random\n    ```", "```py\n    dataset_training = pd.read_csv('../GOOG_train.csv')\n    dataset_training.head()\n    ```", "```py\n    training_data = dataset_training[['Open']].values\n    training_data\n    ```", "```py\n    array([[ 555.647278],\n           [ 555.418152],\n           [ 554.42688 ],\n           ...,\n           [1017.150024],\n           [1049.619995],\n           [1050.959961]])\n    ```", "```py\n    from sklearn.preprocessing import MinMaxScaler\n    sc = MinMaxScaler(feature_range = (0, 1))\n    training_data_scaled = sc.fit_transform(training_data)\n    training_data_scaled\n    ```", "```py\n    array([[0.08017394],\n           [0.07987932],\n           [0.07860471],\n           ...,\n           [0.67359064],\n           [0.71534169],\n           [0.71706467]])\n    ```", "```py\n    X_train = []\n    y_train = []\n    for i in range(60, 1258):\n        X_train.append(training_data_scaled[i-60:i, 0])\n        y_train.append(training_data_scaled[i, 0])\n    X_train, y_train = np.array(X_train), \\\n                       np.array(y_train)\n    ```", "```py\n    X_train = np.reshape(X_train, (X_train.shape[0], \\\n                                   X_train.shape[1], 1))\n    X_train\n    ```", "```py\n    from keras.models import Sequential\n    from keras.layers import Dense, LSTM, Dropout\n    ```", "```py\n    seed = 1\n    np.random.seed(seed)\n    random.set_seed(seed)\n    model = Sequential()\n    ```", "```py\n    model.add(LSTM(units = 50, return_sequences = True, \\\n                   input_shape = (X_train.shape[1], 1)))\n    # Adding a second LSTM layer\n    model.add(LSTM(units = 50, return_sequences = True))\n    # Adding a third LSTM layer\n    model.add(LSTM(units = 50, return_sequences = True))\n    # Adding a fourth LSTM layer\n    model.add(LSTM(units = 50))\n    # Adding the output layer\n    model.add(Dense(units = 1))\n    ```", "```py\n    # Compiling the RNN\n    model.compile(optimizer = 'adam', loss = 'mean_squared_error')\n    # Fitting the RNN to the Training set\n    model.fit(X_train, y_train, epochs = 100, batch_size = 32)\n    ```", "```py\n    dataset_testing = pd.read_csv(\"../GOOG_test.csv\")\n    actual_stock_price = dataset_testing[['Open']].values\n    actual_stock_price\n    ```", "```py\n    total_data = pd.concat((dataset_training['Open'], \\\n                            dataset_testing['Open']), axis = 0)\n    ```", "```py\n    inputs = total_data[len(total_data) \\\n             - len(dataset_testing) - 60:].values\n    inputs = inputs.reshape(-1,1)\n    inputs = sc.transform(inputs)\n    X_test = []\n    for i in range(60, 81):\n        X_test.append(inputs[i-60:i, 0])\n    X_test = np.array(X_test)\n    X_test = np.reshape(X_test, (X_test.shape[0], \\\n                        X_test.shape[1], 1))\n    predicted_stock_price = model.predict(X_test)\n    predicted_stock_price = sc.inverse_transform(\\\n                            predicted_stock_price)\n    ```", "```py\n    # Visualizing the results\n    plt.plot(actual_stock_price, color = 'green', \\\n             label = 'Real Alphabet Stock Price',\\\n             ls='--')\n    plt.plot(predicted_stock_price, color = 'red', \\\n             label = 'Predicted Alphabet Stock Price',\\\n             ls='-')\n    plt.title('Predicted Stock Price')\n    plt.xlabel('Time in days')\n    plt.ylabel('Real Stock Price')\n    plt.legend()\n    plt.show()\n    ```", "```py\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import pandas as pd\n    from tensorflow import random\n    ```", "```py\n    dataset_training = pd.read_csv('../GOOG_train.csv')\n    dataset_training.head()\n    ```", "```py\n    training_data = dataset_training[['Open']].values\n    training_data\n    ```", "```py\n    from sklearn.preprocessing import MinMaxScaler\n    sc = MinMaxScaler(feature_range = (0, 1))\n    training_data_scaled = sc.fit_transform(training_data)\n    training_data_scaled\n    ```", "```py\n    X_train = []\n    y_train = []\n    for i in range(60, 1258):\n        X_train.append(training_data_scaled[i-60:i, 0])\n        y_train.append(training_data_scaled[i, 0])\n    X_train, y_train = np.array(X_train), np.array(y_train)\n    ```", "```py\n    X_train = np.reshape(X_train, (X_train.shape[0], \\\n                                   X_train.shape[1], 1))\n    ```", "```py\n    from keras.models import Sequential\n    from keras.layers import Dense, LSTM, Dropout\n    ```", "```py\n    seed = 1\n    np.random.seed(seed)\n    random.set_seed(seed)\n    model = Sequential()\n    ```", "```py\n    model.add(LSTM(units = 100, return_sequences = True, \\\n                   input_shape = (X_train.shape[1], 1)))\n    # Adding a second LSTM\n    model.add(LSTM(units = 100, return_sequences = True))\n    # Adding a third LSTM layer\n    model.add(LSTM(units = 100, return_sequences = True))\n    # Adding a fourth LSTM layer\n    model.add(LSTM(units = 100))\n    # Adding the output layer\n    model.add(Dense(units = 1))\n    ```", "```py\n    # Compiling the RNN\n    model.compile(optimizer = 'adam', loss = 'mean_squared_error')\n    # Fitting the RNN to the Training set\n    model.fit(X_train, y_train, epochs = 100, batch_size = 32)\n    ```", "```py\n    dataset_testing = pd.read_csv(\"../GOOG_test.csv\")\n    actual_stock_price = dataset_testing[['Open']].values\n    actual_stock_price\n    ```", "```py\n    total_data = pd.concat((dataset_training['Open'], \\\n                            dataset_testing['Open']), axis = 0)\n    ```", "```py\n    inputs = total_data[len(total_data) \\\n                        - len(dataset_testing) - 60:].values\n    inputs = inputs.reshape(-1,1)\n    inputs = sc.transform(inputs)\n    X_test = []\n    for i in range(60, 81):\n        X_test.append(inputs[i-60:i, 0])\n    X_test = np.array(X_test)\n    X_test = np.reshape(X_test, (X_test.shape[0], \\\n                        X_test.shape[1], 1))\n    predicted_stock_price = model.predict(X_test)\n    predicted_stock_price = sc.inverse_transform(\\\n                            predicted_stock_price)\n    ```", "```py\n    # Visualizing the results\n    plt.plot(actual_stock_price, color = 'green', \\\n             label = 'Real Alphabet Stock Price',ls='--')\n    plt.plot(predicted_stock_price, color = 'red', \\\n             label = 'Predicted Alphabet Stock Price',ls='-')\n    plt.title('Predicted Stock Price')\n    plt.xlabel('Time in days')\n    plt.ylabel('Real Stock Price')\n    plt.legend()\n    plt.show()\n    ```"]