["```py\ndef twoSpirals(N):\n  np.random.seed(1)\n  n = np.sqrt(np.random.rand(N,1)) * 780 * (2*np.pi)/360\n  x = -np.cos(n)*n\n  y = np.sin(n)*n\n  return (np.vstack((np.hstack((x,y)),np.hstack((-x,-y)))), \n          np.hstack((np.ones(N)*-1,np.ones(N))))\n\nX, y = twoSpirals(300)  #Produce 300 samples\n```", "```py\ndef sigmoid(z, grad=False):\n  if grad:\n    return z * (1\\. - z)\n  return 1\\. / (1\\. + np.exp(-z))\n```", "```py\nw1 = 2.0*np.random.random((2, 3))-1.0\nw2 = 2.0*np.random.random((3, 2))-1.0\n```", "```py\no1 = sigmoid(np.matmul(X, w1))\n```", "```py\no2 = sigmoid(np.matmul(o1, w2))\n```", "```py\nL = np.square(y-o2).sum()/(2*N) + lambda*(np.square(w1).sum()+np.square(w2).sum())/(2*N)\n```", "```py\ndL_do2 = -(y - o2)\ndo2_dz2 = sigmoid(o2, grad=True)\ndz2_dw2 = o1\ndL_dw2 = dz2_dw2.T.dot(dL_do2*do2_dz2) + lambda*np.square(w2).sum()\n```", "```py\ndL_dz2 = dL_do2 * do2_dz2\ndz2_do1 = w2\ndL_do1 = dL_dz2.dot(dz2_do1.T)\ndo1_dz1 = sigmoid(o1, grad=True)\ndz1_dw1 = X\ndL_dw1 = dz1_dw1.T.dot(dL_do1*do1_dz1) + lambda*np.square(w1).sum()\n```", "```py\nw1 += -alpha*dL_dw1\nw2 += -alpha*dL_dw2\n```", "```py\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\n\nmlp = Sequential()\nmlp.add(Dense(3, input_dim=2, activation='sigmoid'))\nmlp.add(Dense(2, activation='sigmoid'))\n\nmlp.compile(loss='mean_squared_error',\n            optimizer='sgd',\n            metrics=['accuracy'])\n\n# This assumes that you still have X, y from earlier\n# when we called X, y = twoSpirals(300)\nmlp.fit(X, y, epochs=1000, batch_size=60)\n```"]