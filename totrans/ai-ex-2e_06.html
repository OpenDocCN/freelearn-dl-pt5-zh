<html><head></head><body>
  <div id="_idContainer093">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-95" class="chapterTitle">Innovating AI with Google Translate</h1>
    <p class="normal">In this chapter, we will illustrate how to innovate existing AI through Google Translate. First, we will start by understanding the difference between inventions, innovations, disruption, high-priced products, and revolutions, and how we can create an impact on an AI innovation.</p>
    <p class="normal">Sometimes, a developer will confuse an invention with innovation, leading to a major failure in a key AI project. Some AI designers take a revolution to mean a disruption, leading to early sales and then nothing.</p>
    <p class="normal">Once we have defined the key concepts of innovation, we will use Google Translate to understand the linguistic principles that surround <strong class="bold">natural language processing </strong>(<strong class="bold">NLP</strong>).</p>
    <p class="normal">Google Translate entered the market in 2006 and was enhanced by neural networks in 2016, but still, it often produces bad answers. Is that good news or bad news? We will implement Google's API in a Python program to find out how to uncover false translations from one language to another.</p>
    <p class="normal">Once we have found Google Translate's limits, we will finally find out how to transcend those limits with our own adaptations, by exploring Google's API in a Python program, adding a <strong class="bold">k-nearest neighbors</strong> (<strong class="bold">KNN</strong>) algorithm, and measuring the results statistically.</p>
    <p class="normal">Contrary to media hype, artificial intelligence has only just begun to innovate human processes. A huge amount of work remains to be done. To achieve progress, everybody must get involved, as we'll discuss in this chapter. Even if Google, Amazon, Microsoft, IBM, and others offer a solution, this does not mean it cannot be improved by third parties as add-ons to existing solutions or new standalone products. After all, once Ford invented the Model T over a hundred years ago, this did not preclude the development of even better cars. On the contrary, look around you!</p>
    <p class="normal">To take advantage of the AI adventure, we will go from understanding disruption in AI to Google Translate, and then innovate.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="list">Understanding the key concepts of AI innovation before starting to implement Google Translate</li>
      <li class="list">The difference between inventions and innovations</li>
      <li class="list">The difference between revolutionary and disruptive AI</li>
      <li class="list">Google Translate API implementation in Python</li>
      <li class="list">Introducing linguistics as a prerequisite to building any <strong class="bold">natural language processing</strong> (<strong class="bold">NLP</strong>) algorithm</li>
      <li class="list">The KNN algorithm</li>
      <li class="list">How to customize Google Translate with a KNN in Python</li>
    </ul>
    <p class="normal">We will start by exploring the key concepts of AI innovation and disruption.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">All the Python programs and files in this chapter are available at <a href="https://github.com/PacktPublishing/Artificial-Intelligence-By-Example-Second-Edition/tree/master/CH0"><span class="url">https://github.com/PacktPublishing/Artificial-Intelligence-By-Example-Second-Edition/tree/master/CH06</span></a>.</p>
      <p class="Information-Box--PACKT-">There is also a Jupyter notebook named <code class="Code-In-Text--PACKT-">COLAB_Translate.ipynb</code> that contains all of the Python programs in one run. You can upload it directly to Google Colaboratory using your Google account: <a href="https://colab.research.google.com/"><span class="url">https://colab.research.google.com/</span></a>.</p>
    </div>
    <h1 id="_idParaDest-96" class="title">Understanding innovation and disruption in AI</h1>
    <p class="normal">The first <a id="_idIndexMarker228"/>question we must ask <a id="_idIndexMarker229"/>ourselves when starting a project <a id="_idIndexMarker230"/>such as <a id="_idIndexMarker231"/>a translation solution is to find out where we fit in. Is what we are going to do an invention or an innovation? Is our work disruptive or revolutionary? We will explore these concepts in this chapter to understand the broad pragmatic picture before going any further.</p>
    <h2 id="_idParaDest-97" class="title">Is AI disruptive?</h2>
    <p class="normal">The word "disruptive" is more<a id="_idIndexMarker232"/> often than<a id="_idIndexMarker233"/> not associated with artificial intelligence. Media hype tells us that AI robots will soon have replaced humans around the world. Although media hype made it much easier to obtain AI budgets, we need to know where we stand if we want to implement an AI solution. If we want to innovate, we need to find the cutting edge and build new ideas from there.</p>
    <p class="normal">Why not just plunge into the tools and see what happens? Is that a good idea or a risky one? Unlike corporations with huge budgets, a single human has limited resources. If you spend time learning in the wrong direction, it will take months to gather enough experience in another, better direction to reach your goal. For example, suppose you have trouble classifying large amounts of data, as we explored in <em class="italics">Chapter 4</em>, <em class="italics">Optimizing Your Solutions with K-means Clustering</em>. You will spend months on a project in your company and fail. It could cost you your job. Conversely, if you find the right model and learn the key concepts, your project can take off in a few days.</p>
    <p class="normal">Before diving into a <a id="_idIndexMarker234"/>project, find out where we stand in terms of innovation and disruption. This doesn't seem important at the start of a project, but it will mean a lot during the production and distribution phases. This section will clarify these concepts.</p>
    <p class="normal">Nothing is new under the sun—not even when considering AI. Most AI theory and mathematical tools have been around for decades, if not centuries. We often tend to think that since something appears new to us, it has just been invented or discovered. This mistake can prove<a id="_idIndexMarker235"/> fatal in many projects. If you know that a theory or function has been around for decades or centuries, you can do some deep research and use solutions found 100+ years ago to solve your present problems. If you do, you will save a lot of time using equations that have been proven and are reliable. If you do not, you might spend useless vital time reinventing equations that exist.</p>
    <p class="normal">Finding out what is new and what is not will make a major difference in your personal or professional AI projects.</p>
    <h3 id="_idParaDest-98" class="title">AI is based on mathematical theories that are not new</h3>
    <p class="normal">AI theory presently relies<a id="_idIndexMarker236"/> heavily on applied mathematics. In <em class="italics">Chapter 1</em>, <em class="italics">Getting Started with Next-Generation Artifcial Intelligence through Reinforcement Learning</em>, the <strong class="bold">Markov decision process</strong> (<strong class="bold">MDP</strong>), a <strong class="bold">reinforcement learning</strong> (<strong class="bold">RL</strong>) approach was described. Google <a id="_idIndexMarker237"/>has been successfully combining RL with neural networks in AlphaGo Zero.</p>
    <p class="normal">Andrey Markov was a Russian mathematician born in 1856 who invented the MDP. He successfully applied the algorithm to letter predictions in a word sequence in a given language, for example. Richard Bellman published an enhanced version of the MDP in 1957.</p>
    <p class="normal">Bellman also coined the <a id="_idIndexMarker238"/>expression "curse of dimensionality" and published books on mathematical tools widely used today in AI. It is now well known that dimensionality reduction can be performed to avoid facing thousands of dimensions (features, for example) in an algorithm.</p>
    <p class="normal">The logistic function (see <em class="italics">Chapter 2</em>, <em class="italics">Building a Reward Matrix – Designing Your Datasets</em>) can be traced back to Pierre François Verhulst (1844-1845), a Belgian mathematician. The logistic function uses <em class="italics">e</em>, the natural logarithm base, which is also named Euler's number. Leonhard Euler (1707-1783) is a Swiss mathematician who worked on this natural logarithm.</p>
    <p class="normal">Thomas Bayes (1701-1761) invented the theorem that bears his name: Bayes' Theorem. It is widely used in AI. We will be using it in <em class="italics">Chapter 7</em>, <em class="italics">Optimizing Blockchains with Naive Bayes</em>.</p>
    <p class="normal">Almost all of the applied <a id="_idIndexMarker239"/>mathematics in artificial intelligence, machine learning, and deep learning can be traced from 17th century to 20th century mathematicians. We must look elsewhere for 21st century AI innovations. We need to find what is truly new in AI, which is also what helped it expand so rapidly in the early 21st century.</p>
    <h3 id="_idParaDest-99" class="title">Neural networks are not new</h3>
    <p class="normal">Neural networks, as <a id="_idIndexMarker240"/>described by contemporary experts, date back to the 1940s and 1950s. Even <strong class="bold">convolutional neural networks</strong> (<strong class="bold">CNNs</strong>) date back to the 20th century. Yann LeCun, a French<a id="_idIndexMarker241"/> computer scientist, laid down the basics of a CNN (see <em class="italics">Chapter 9</em>, <em class="italics">Abstract Image Classifcation with Convolutional Neural Networks (CNNs)</em>) in the 1980s; he successfully applied them as we know them today in the 1990s.</p>
    <p class="normal">We must again look elsewhere for 21st century AI innovations.</p>
    <p class="normal">If neural networks are not new either, we must find the real new factors in our environment that produced the success of present-day AI.</p>
    <h2 id="_idParaDest-100" class="title">Looking at disruption – the factors that are making AI disruptive</h2>
    <p class="normal">Although the foundations of AI find their roots long before computers existed or were widespread, it is only recently that we have seen AI truly begin to cause waves within our society. In the following sections, we'll look at factors that have come together to make AI a powerful force of disruption in recent years.</p>
    <h3 id="_idParaDest-101" class="title">Cloud server power, data volumes, and web sharing of the early 21st century</h3>
    <p class="normal">It's important to understand what has driven the emergency<a id="_idIndexMarker242"/> of AI in recent years.</p>
    <p class="normal">Data volumes drive the emergence of AI in the 21st century. Processing data, classifying data, and making predictions and decisions would be impossible without AI driving the entire computer science market.</p>
    <p class="normal">If you leave the fantasy surrounding AI behind you and bear this key necessity for AI in mind, you will perfectly understand why AI has emerged and is here to stay.</p>
    <p class="normal">The first sign of AI's<a id="_idIndexMarker243"/> innovative disruption appeared between the years 2000 and 2010. Before then, the internet existed, and servers existed. But, starting from around 2005, cloud servers were made widely available. With that kind of computing power, developers around the world could try using the highly greedy resources required by machine learning and deep learning. They could finally solve otherwise impossible big data problems using AI.</p>
    <p class="normal">At the same time, as powerful servers became available, the internet provided the largest library of knowledge in the history of humanity.</p>
    <p class="normal">On top of that, social networking became widely used. Sharing discoveries and source code became commonplace. The World Wide Web (WWW) encouraged open source software, boosting local research and development.</p>
    <p class="normal">The era of artificial intelligence became possible for local experts starting from the middle of the first decade of the 21st century.</p>
    <p class="normal">What makes AI appear as an innovation today is the conjunction of more powerful machines and the availability of intellectual resources.</p>
    <h3 id="_idParaDest-102" class="title">Public awareness</h3>
    <p class="normal">Public awareness of AI<a id="_idIndexMarker244"/> remained dim for several years after the cloud architectural revolution occurred from around 1995 to 2005.</p>
    <p class="normal">AI hit us hard by around 2015 when we all woke up realizing that AI could massively replace humans and create job displacement at levels never before seen in human history.</p>
    <p class="normal">Worse, we realized that machines could beat us in fields we took pride in, such as chess (<em class="italics">Chapter 3</em>, <em class="italics">Machine Intelligence – Evaluation Functions and Numerical Convergence</em>), the game of Go, and video games. We see manufacturing jobs increasingly performed by robots, office jobs being done by bots, and more fields that are appearing every day.</p>
    <p class="normal">For the first time in human history, the human species can be surpassed by a new "species": smart bots. As developers, we thought we were safe until Google presented AutoML, a solution that could create machine learning solutions better than humans. At the same time, ready-to-use machine learning platforms have spread that can reduce and even replace AI software development.</p>
    <p class="normal">Artificial intelligence inspires both awe and fear. How far will machines go? Will we simply experience job displacement, or will it go as far as species replacement?</p>
    <p class="normal">Could this be an opportunity for many? Who knows? In any case, this chapter provides some guidance to help you to think in a way that drives you to be constantly innovating and being useful. In the age of Big Data, where we are often faced with huge datasets, AI is here to stay; we won't be able to cope without it. Let's make the most of it!</p>
    <p class="normal">Before we begin to <a id="_idIndexMarker245"/>look into the incredible opportunities provided by AI, let's clarify in our minds what exactly the differences are, first between <em class="italics">invention</em> and <em class="italics">innovation</em>, and then <em class="italics">revolution</em> versus <em class="italics">disruption</em>. It is important to understand the impact that what we are developing and implementing will have on the AI market.</p>
    <h2 id="_idParaDest-103" class="title">Inventions versus innovations</h2>
    <p class="normal">Some AI programs, especially deep <a id="_idIndexMarker246"/>learning algorithms, remained inventions and not innovations until Google and other major players used them on a large scale.</p>
    <p class="normal">If you have invented a better algorithm than Google for some applications, it remains an invention until it actually <em class="italics">changes</em> something in your corporation or on the web.</p>
    <p class="normal">Suppose you find a quicker way to recognize an image through an optimized number of neurons and a new activation function. If nobody uses it, then that invention remains a personal theoretical finding no matter how good it appears. </p>
    <p class="normal">When others begin to use this new algorithm, then it becomes an innovation. An invention becomes an innovation only when it changes a process within a company or by a sufficient number of private users.</p>
    <h2 id="_idParaDest-104" class="title">Revolutionary versus disruptive solutions</h2>
    <p class="normal">Suppose <a id="_idIndexMarker247"/>a new image recognition <a id="_idIndexMarker248"/>algorithm becomes an innovation in a significant corporation. This new algorithm has gone from being an <strong class="bold">invention</strong> (not used) to an <strong class="bold">innovation</strong> (a solution making a difference).</p>
    <p class="normal">The corporation now widely uses the algorithm. Every subsidiary has access to it. For this corporation, the new image recognition algorithm has attained a revolutionary status. Corporate sales have gone up, and profit margins have as well.</p>
    <p class="normal">But maybe this corporation does not dominate the market, and nobody has followed its example. The innovation remains revolutionary but has not become disruptive.</p>
    <p class="normal">Then, let's say the person who created the algorithm decides to leave the company and start a business with the algorithm. It appears on GitHub as an open source program. Everybody wants<a id="_idIndexMarker249"/> it and the number of<a id="_idIndexMarker250"/> downloads increases daily until 1,000,000+ users have begun to implement it. Some very low-priced add-ons are provided on the company website. Within a year, it becomes a new way of recognizing images. All companies must follow suit or lag behind. The solution has become <strong class="bold">disruptive</strong> because it has changed its market on a global scale.</p>
    <h2 id="_idParaDest-105" class="title">Where to start?</h2>
    <p class="normal">We have now explored the basic concepts of creating AI. The first step in a translation project using Google Translate is to take the algorithm as far as possible using Google's API. As we will see in the next section, we will explore the limits of Google Translate. Once the limit is found, creativity kicks in when we customize Google Translate using AI.</p>
    <p class="normal">We will discover that even if a solution exists, it has limits and can be improved, customized, packaged, and sold. <em class="italics">If there is a limit, there is a market</em>.</p>
    <p class="normal">Never criticize the flaws you find in an AI solution; they are gold mines!</p>
    <p class="normal"><em class="italics">Where there is a limit, there is an opportunity</em>.</p>
    <p class="normal">Let's go to the cutting edge and then over the border into uncharted territory using Google Translate to illustrate this.</p>
    <h1 id="_idParaDest-106" class="title">Discover a world of opportunities with Google Translate</h1>
    <p class="normal">Starting with <a id="_idIndexMarker251"/>Google Translate to explore NLP is a good way to prepare to use NLP in web solutions. Any disruptive web-based solution must be able to run in at least a few languages. You will need to master NLP in several languages to implement a chatbot, a translation solution, and online information sites such as Wikipedia.</p>
    <p class="normal">Google provides many resources to use, explore, or improve Google Translate. Getting a Python code to run and then assess the quality of the results will prove vital before implementing it for crucial translations in a company. Let's get Google Translate running.</p>
    <h2 id="_idParaDest-107" class="title">Getting started</h2>
    <p class="normal">Google's developers' API client library page<a id="_idIndexMarker252"/> is as follows: <a href="https://developers.google.com/api-client-library/"><span class="url">https://developers.google.com/api-client-library/</span></a>. On this page, you will see libraries for many languages: Java, PHP, .NET, JavaScript, Objective-C, Dart, Ruby and more.</p>
    <p class="normal">Then, go to the Python resources and follow the instructions to sign up, create a project in the Google API Console, and install the library.</p>
    <p class="normal">If you encounter problems doing this part or do not wish to install anything yet, this chapter is self-contained. The source code is described in the chapter.</p>
    <p class="normal">You are now ready to go, irrespective of whether you installed the tools.</p>
    <h2 id="_idParaDest-108" class="title">The program</h2>
    <p class="normal">The goal of this section is to implement Google Translate<a id="_idIndexMarker253"/> functionality. You can implement and run the program or first simply read the self-contained section.</p>
    <h3 id="_idParaDest-109" class="title">The header</h3>
    <p class="normal">The standard<a id="_idIndexMarker254"/> Google header provided by Google should be enough to get the API to work, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs angelscript"><span class="hljs-keyword">from</span> googleapiclient.discovery <span class="hljs-keyword">import</span> build
</code></pre>
    <p class="normal">Considering the many languages Google manages, special characters are a major problem to handle. Many forums and example programs on the web struggle with the <code class="Code-In-Text--PACKT-">UTF-8</code> header when using Google Translate. Many solutions are suggested, such as the following source code header.</p>
    <pre class="programlisting"><code class="hljs vala"><span class="hljs-meta"># -*- coding: utf-8 -*-</span>
</code></pre>
    <p class="normal">Then, when Google Translate returns the result, more problems occur, and many develop their own functions. They work fine, but I was looking for a straightforward one-line solution. The goal here was not to have many lines of code but focus on the limit of Google Translate to discover the cutting-edge interpreting languages in AI.</p>
    <p class="normal">So, I did not use the <code class="Code-In-Text--PACKT-">UTF-8</code> header, but implemented it using the HTML library.</p>
    <pre class="programlisting"><code class="hljs elm"><span class="hljs-keyword">import</span> html
</code></pre>
    <p class="normal">When confronted with a result, the following one-line HTML parser code did the job.</p>
    <pre class="programlisting"><code class="hljs lisp">print(<span class="hljs-string">"result:"</span>, html.unescape(<span class="hljs-name">result</span>))
</code></pre>
    <p class="normal">It works well because Google will return an HTML string or a text string depending on what option you implement. This means that the HTML module can do the job.</p>
    <h3 id="_idParaDest-110" class="title">Implementing Google's translation service</h3>
    <p class="normal">Google's translation service<a id="_idIndexMarker255"/> needs at least three values to return a result:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">developerKey</code>: This is the API key obtained at the end of the getting-started process described previously.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">q="text to translate"</code>: In my code, I used <code class="Code-In-Text--PACKT-">source</code>.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">target="abbreviation of the translated text"</code>: <code class="Code-In-Text--PACKT-">en</code> for English, <code class="Code-In-Text--PACKT-">fr</code> for French, and so on.</li>
    </ul>
    <p class="normal">More options are available, as described in the following sections.</p>
    <p class="normal">With this in mind, the translation function will work as follows:</p>
    <pre class="programlisting"><code class="hljs routeros">def g_translate(source,targetl):
   <span class="hljs-built_in"> service </span>= build(<span class="hljs-string">'translate'</span>, <span class="hljs-string">'v2'</span>,<span class="hljs-attribute">developerKey</span>=<span class="hljs-string">'your Key'</span>)
    request = service.translations().list(<span class="hljs-attribute">q</span>=source,
        <span class="hljs-attribute">target</span>=targetl)
    response = request.execute()
    return response[<span class="hljs-string">'translations'</span>][0][<span class="hljs-string">'translatedText'</span>]
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Google_translate.py</code> program, <code class="Code-In-Text--PACKT-">q</code> and <code class="Code-In-Text--PACKT-">target</code> will be sent to the function to obtain a parsed result:</p>
    <pre class="programlisting"><code class="hljs lisp">source=<span class="hljs-string">"your text"</span>
targetl=<span class="hljs-string">"abbreviation of the target language"</span>
result = g_translate(<span class="hljs-name">source</span>,targetl)
print(<span class="hljs-name">result</span>)
</code></pre>
    <p class="normal">To sum up the program, let's translate Google Translate into French, which contains accents parsed by the HTML parser:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-keyword">from</span> googleapiclient.discovery import build
import html
def g_translate(source,targetl):
   <span class="hljs-built_in"> service </span>= build(<span class="hljs-string">'translate'</span>, <span class="hljs-string">'v2'</span>,<span class="hljs-attribute">developerKey</span>=<span class="hljs-string">'your key'</span>)
    request = service.translations().list(<span class="hljs-attribute">q</span>=source,
        <span class="hljs-attribute">target</span>=targetl)
    response = request.execute()
    return response[<span class="hljs-string">'translations'</span>][0][<span class="hljs-string">'translatedText'</span>]
<span class="hljs-attribute">source</span>=<span class="hljs-string">'Google Translate is great!'</span>
<span class="hljs-attribute">targetl</span>=<span class="hljs-string">"fr"</span>
result = g_translate(source,targetl)
<span class="hljs-builtin-name">print</span>(<span class="hljs-string">"result:"</span>, html.unescape(result))
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">Google_Translate.py</code> works fine. The result will come out with the correct answer and the parsed accent:</p>
    <pre class="programlisting"><code class="hljs stata">Google <span class="hljs-keyword">Translate</span> <span class="hljs-keyword">est</span> <span class="hljs-keyword">g</span>énial!
</code></pre>
    <p class="normal">At this point, Google Translate satisfies a black box exploration approach. It is disruptive, has changed the world, and can replace translators in many corporations for all corporate needs.</p>
    <p class="normal">In fact, we could <a id="_idIndexMarker256"/>end the chapter here, go to our favorite social network, and build some hype on our translation project.</p>
    <p class="normal">Happy ending?</p>
    <p class="normal">Well, not yet!</p>
    <p class="normal">We need to explore Google Translate from a linguist's perspective.</p>
    <h2 id="_idParaDest-111" class="title">Google Translate from a linguist's perspective</h2>
    <p class="normal">A linguist's approach to the <a id="_idIndexMarker257"/>program will involve a deeper, white box sort of exploration. The method will reveal many areas to improve.</p>
    <p class="normal">By the time this book is published, perhaps Google will have improved the examples in this chapter. But don't worry; in this case, you will quickly find hundreds of other examples that are incorrect. The journey has just begun!</p>
    <h3 id="_idParaDest-112" class="title">Playing with the tool</h3>
    <p class="normal">Playing with <a id="_idIndexMarker258"/>a tool with random examples can lead to surprising results. This exploratory source code is saved as <code class="Code-In-Text--PACKT-">Google_translate_a_few_test_expressions.py</code>.</p>
    <p class="normal">The program simulates a dialog created by a person named Usty as follows:</p>
    <pre class="programlisting"><code class="hljs ada">source=<span class="hljs-symbol">'Hello.</span> My name <span class="hljs-keyword">is</span> Usty!'
 &gt;&gt;&gt;result:Bonjour. Je m<span class="hljs-symbol">'appelle</span> Usty!
source=<span class="hljs-symbol">'The</span> weather <span class="hljs-keyword">is</span> nice today'
 &gt;&gt;&gt;result: Le temps est beau aujourd<span class="hljs-symbol">'hui</span>
source=<span class="hljs-symbol">'Ce</span> professor me chercher des poux.'
 &gt;&gt;&gt;result: This professor <span class="hljs-keyword">is</span> looking <span class="hljs-keyword">for</span> lice!
</code></pre>
    <p class="normal">The first two examples look fine in French, although the second translation is a bit strange. But in the third test, the expression <em class="italics">chercher des poux</em> means <em class="italics">looking for trouble</em> in English, and <a id="_idIndexMarker259"/>not looking for lice, as translated into French.</p>
    <p class="normal">A linguistic assessment of Google Translate will now be made.</p>
    <h3 id="_idParaDest-113" class="title">Linguistic assessment of Google Translate</h3>
    <p class="normal">Assessing Google<a id="_idIndexMarker260"/> Translate correctly will lead directly to <a id="_idIndexMarker261"/>its limits.</p>
    <p class="normal">Limits are the boundaries researchers crave! We are frontiersmen!</p>
    <p class="normal">An expert-level assessment will lead the project team to the frontier and beyond. To do this, we will first explore some linguistic methods.</p>
    <h4 class="title">Lexical field theory</h4>
    <p class="normal">Lexical fields describe word fields. A word only acquires its full meaning when interpreted within a context. This context often goes beyond a few other words or even a sentence.</p>
    <p class="normal"><em class="italics">Chercher des poux</em> translated as such means <em class="italics">look for lice</em>. But in French, it can mean <em class="italics">looking for trouble</em> or literally <em class="italics">looking for lice</em>. The result that Google Translate comes up with contains three basic problems.</p>
    <pre class="programlisting"><code class="hljs ruby">source=<span class="hljs-string">'chercher des poux'</span>
<span class="hljs-meta">&gt;&gt;</span><span class="hljs-symbol">result:</span> look for lice
</code></pre>
    <p class="normal"><strong class="bold">Problem 1 – the lexical field</strong>: There is no <a id="_idIndexMarker262"/>way of knowing whether this means looking for lice or looking for trouble without a context.</p>
    <p class="normal"><strong class="bold">Problem 2 – metaphors or idiomatic expressions</strong>: Suppose you have to translate <em class="italics">this is giving you a headache</em>. There is no way of knowing whether it is a physical problem or a metaphor meaning <em class="italics">this is driving you crazy</em>. These two idiomatic expressions happen to have the same metaphors when translated into French. But the <em class="italics">lice</em> metaphor in French means nothing in English.</p>
    <p class="normal"><strong class="bold">Problem 3</strong>: <em class="italics">chercher</em> is an infinitive in French, and the result should have been <em class="italics">looking</em> for lice in English. But entering <em class="italics">chercher des limites est intéressant</em> provides the right verb form, which is <em class="italics">looking for</em>:</p>
    <pre class="programlisting"><code class="hljs vim"><span class="hljs-keyword">source</span>=<span class="hljs-string">'Chercher des limites est intéressant.'</span>
&gt;&gt;&gt;resul<span class="hljs-variable">t:Looking</span> <span class="hljs-keyword">for</span> boundaries <span class="hljs-keyword">is</span> interesting.
</code></pre>
    <p class="normal">The answer is correct because <em class="italics">is</em> splits the sentence into two, making it easier for Google Translate to identify <em class="italics">chercher</em> as the first part of a sentence, thus using <em class="italics">looking</em> in English.</p>
    <p class="normal">Lexical fields vary from language to language, but so does jargon.</p>
    <h4 class="title">Jargon</h4>
    <p class="normal">Jargon<a id="_idIndexMarker263"/> arises when fields specialize. In AI, the expression <em class="italics">hidden neurons</em> is jargon. This expression means nothing to a lawyer, for example. A lawyer may think you have hidden intelligence on the subject somewhere or are hiding money in a cryptocurrency named hidden neuron.</p>
    <p class="normal">In the same way, if somebody asks an AI expert to explain the exact meaning of <em class="italics">filing a motion</em>, that would prove difficult.</p>
    <p class="normal">In a corporate legal environment, beyond using Google Translate as a dictionary, translating sentences might be risky if only a random number of results prove to be correct.</p>
    <p class="normal">If we add the jargon variations to the lexical variations from one language to another, we can see that word-to-word translation does not work when a word is in a context. Translating is thus more than just finding the most similar words in the language we are translating to.</p>
    <h4 class="title">Translating is not just translating but interpreting</h4>
    <p class="normal">Sometimes, translating<a id="_idIndexMarker264"/> requires interpreting, as shown with the following sentence taken from a standard description of French commercial law:</p>
    <pre class="programlisting"><code class="hljs applescript">source='Une SAS ne dispense pas de suivre les recommandations en vigueur autour des pratiques commerciales.'
&gt;&gt;&gt;<span class="hljs-literal">result</span>:An SAS <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> exempt <span class="hljs-keyword">from</span> following <span class="hljs-keyword">the</span> recommendations <span class="hljs-keyword">in</span> force <span class="hljs-keyword">around</span> commercial practices.
</code></pre>
    <p class="normal">The French sentence refers to a type of company; SAS is similar to company types like inc., ltd., and so on. In English, SAS means Special Air Service. Then comes the grammar, which does not sound right.</p>
    <p class="normal">A translator would write better English and also specify what an SAS is:</p>
    <p class="normal"><em class="italics">An SAS (a type of company in France) must follow the recommendations that cover commercial practices.</em></p>
    <p class="normal">Translating often means interpreting, and not simply translating words.</p>
    <p class="normal">In this case, a legal translator may interpret the text in a contract and go as far as writing:</p>
    <p class="normal"><em class="italics">The COMPANY must respect the legal obligation to treat all customers fairly.</em></p>
    <p class="normal">The legal translator will suggest that <em class="italics">COMPANY</em> be defined at the beginning of the contract to avoid confusion, such as the one Google Translate just made.</p>
    <p class="normal">When reading about NLP, chatbots, and translation, everything seems easy. However, working on Google Translate can easily turn into a nightmare!</p>
    <p class="normal">Let's take one last example:</p>
    <pre class="programlisting"><code class="hljs ada">The project team <span class="hljs-keyword">is</span> <span class="hljs-keyword">all</span> ears
</code></pre>
    <p class="normal">Google Translate provides the output in French:</p>
    <pre class="programlisting"><code class="hljs stata">source:<span class="hljs-string">"The project team is all ears"</span>.
&gt;&gt;&gt;result: <span class="hljs-keyword">L</span>'équipe <span class="hljs-keyword">de</span> projet <span class="hljs-keyword">est</span> tout <span class="hljs-keyword">ou</span>ï<span class="hljs-keyword">e</span>.
</code></pre>
    <p class="normal">In French, as in English, it is better to say <em class="italics">project team</em> and not use <em class="italics">of</em> to say the <em class="italics">team of the project</em>. In French, we have <em class="italics">équipe projet</em> (équipe (team) appears before project).</p>
    <p class="normal">From our examples so far, we can see that Google Translate is:</p>
    <ul>
      <li class="list">Sometimes correct</li>
      <li class="list">Sometimes wrong</li>
      <li class="list">Sometimes partly correct and partly wrong</li>
    </ul>
    <p class="normal">The problem now is how to know which category a translation is in.</p>
    <h4 class="title">How to know whether a translation is correct</h4>
    <p class="normal">How can you check<a id="_idIndexMarker265"/> a translation if you do not know the language?</p>
    <p class="normal">Be careful. If Google Translate provides randomly correct answers in another language, then you have no way of knowing whether the translation is reliable or not.</p>
    <p class="normal">If you can't be confident that Google Translate is going to be correct, you may find yourself in difficult situations; even sending the opposite of what you mean to somebody important to you. You may misunderstand a sentence you are trying to understand.</p>
    <p class="normal">In a transportation company, for example, you could write an email stating that the coach stopped and people were complaining:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">source</span>=<span class="hljs-string">'The coach stopped and everybody was complaining.'</span>
</code></pre>
    <p class="normal">Google Translate, for lexical field reasons, got it wrong and translated <em class="italics">coach</em> as a sports trainer in French, which would give a completely different meaning to the sentence:</p>
    <pre class="programlisting"><code class="hljs vim">resul<span class="hljs-variable">t:</span> L<span class="hljs-string">'entraîneur s'</span>est arrêté et tout <span class="hljs-keyword">le</span> monde <span class="hljs-keyword">se</span> plaignait..
</code></pre>
    <p class="normal">Now, the situation can get worse. To help Google Translate, let's add some context.</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">source</span>=<span class="hljs-string">'The coach broke down and stopped and everybody was complaining.'</span>
</code></pre>
    <p class="normal">This answer is worse. Google Translate translates <em class="italics">broke down</em> correctly with the French expression <em class="italics">en panne</em> but still translates <em class="italics">coach</em> as <em class="italics">entraineur</em> (trainer) in French, meaning the <em class="italics">trainer</em> broke down, not the <em class="italics">coach</em> (bus).</p>
    <pre class="programlisting"><code class="hljs stata">result: <span class="hljs-keyword">L</span>'entraîneur <span class="hljs-keyword">est</span> tombé <span class="hljs-keyword">en</span> panne et s'<span class="hljs-keyword">est</span> arrêté et tout le monde <span class="hljs-keyword">se</span> plaignait.
</code></pre>
    <p class="normal">Google will no doubt continue to improve the program as it has done since 2006. For now, however, a human translator will find hundreds of expressions Google Translate cannot deal with yet.</p>
    <p class="normal">Understanding a <a id="_idIndexMarker266"/>sentence in your native language can prove difficult when a word or an expression has several meanings. Adding a translation function to the issue makes it even more difficult to provide a reliable answer.</p>
    <p class="normal">And that is where we reach the frontier, just beyond the cutting edge, as we have established the limits of Google Translate.</p>
    <p class="normal">In the next section, we'll look at some ways we could improve standard Google Translate results. Although no silver bullet exists to verify a translation, we will explore methods to improve the process. We will find a way to improve Google Translate and implement it.</p>
    <h1 id="_idParaDest-114" class="title">AI as a new frontier</h1>
    <p class="normal">Google has<a id="_idIndexMarker267"/> a great, but limited, translation program. Use the flaws to innovate! AI research and development has just scratched the surface of the innovations to come.</p>
    <p class="normal">First, implement an AI solution. Then, use it for what it is. But don't accept its limits. Don't be negative about it. Innovate! Imagine ideas or listen to other ideas you like and build solutions in a team! Google might even publish your solutions!</p>
    <p class="normal">Improving Google Translate for any translation is impossible. A realistic approach is to focus on customizing Google Translate for a given domain, such as the transportation company in this example. In the next section, we will focus on ways to customize Google Translate.</p>
    <h2 id="_idParaDest-115" class="title">Lexical field and polysemy</h2>
    <p class="normal"><code class="Code-In-Text--PACKT-">Google_Translate_Customized.py</code> will provide ideas on how to improve Google Translate in a specific area. This section focuses on the transportation vocabulary error Google Translate made. Once again, Google may rapidly correct this error, but the method can be applied to the many remaining errors.</p>
    <p class="normal">A <strong class="bold">lexical field</strong> contains <a id="_idIndexMarker268"/>words that form sets and subsets. They differ from one language to another. A language itself forms a set and contains subsets of lexical fields.</p>
    <p class="normal">Colder countries have more words describing water in its frozen form than tropical countries where snow hardly ever falls. A lexical field of cold could be a subset of <em class="italics">C</em>:</p>
    <p class="normal"><em class="italics">C</em> = {<em class="italics">ice</em>, <em class="italics">hail</em>, <em class="italics">snowflakes</em>, <em class="italics">snowman</em>, <em class="italics">slushy</em>, <em class="italics">powder</em>, <em class="italics">flake</em>, <em class="italics">snowball</em>, <em class="italics">blizzard</em>, <em class="italics">melting</em>, <em class="italics">crunch</em> … <em class="italics">n</em>}</p>
    <p class="normal">The curse of dimensionality applies here. Words contain an incredible number of dimensions and definitions. To translate certain expressions, Google Translate suppresses their dimensions and reduces them.</p>
    <p class="normal">Google Translate often uses n-grams to translate. An n-gram is a fixed-length sequence of tokens. Tokens can be a word, a character, or even a numerical representation of words and characters.</p>
    <p class="normal">The probability that token <em class="italics">n</em> means something is calculated given the preceding/following <em class="italics">n</em> – <em class="italics">x</em> or <em class="italics">n</em> + <em class="italics">x</em> tokens. <em class="italics">x</em> is a variable depending on the algorithm applied.</p>
    <p class="normal">For example, <em class="italics">slushy</em> has a special meaning in the expression <em class="italics">slushy snow</em>. The snow is partly melting, it's watery and making a <em class="italics">slushing</em> sound when we walk through it. Melting is only one component of the meaning of <em class="italics">slush</em>.</p>
    <p class="normal">Google Translate, at this point, will only<a id="_idIndexMarker269"/> translate <em class="italics">slushy snow</em> in French by:</p>
    <p class="center"><em class="italics">neige</em> (snow) <em class="italics">fondante</em> (melting)</p>
    <p class="normal">Google Translate will also translate <em class="italics">melting snow</em> by:</p>
    <p class="center"><em class="italics">neige</em> (snow) <em class="italics">fondante</em> (melting)</p>
    <p class="normal">To translate <em class="italics">slushy</em> into French, you have to use a phrase. To find that phrase, you need some imagination or have some parsed (searched) novels or other forms of speech representations. That takes time and resources. It will most probably take years before Google Translate reaches an acceptable native level in all the languages publicized.</p>
    <p class="normal">Another dimension to take into account is polysemy.</p>
    <p class="normal">Polysemy <a id="_idIndexMarker270"/>means a word can have several very different meanings in a language. The equivalent word in another language may simply have one meaning or other, very different meanings.</p>
    <p class="normal">"Go + over" in English can mean <em class="italics">go over a bridge</em> or <em class="italics">go over some notes</em>. At this point (hopefully it will improve by the time you read this book), it is translated in both cases in French by <em class="italics">aller sur</em>. This means to go on (not over), which is incorrect in both cases. Prepositions in English constitute a field in themselves, generating many meanings with the same word. The verb <em class="italics">go</em> can have a wide list of meanings: <em class="italics">go up</em> (upstairs), <em class="italics">go up</em> (stock market), <em class="italics">go down</em> (downstairs), <em class="italics">go down</em> (fall apart), and many more possibilities besides.</p>
    <p class="normal">The prototype customized program starts with defining <code class="Code-In-Text--PACKT-">X</code>. A small dataset to translate that will be more than enough to get things going:</p>
    <pre class="programlisting"><code class="hljs vbnet">X=[<span class="hljs-comment">'Eating fatty food can be unhealthy.',</span>
   <span class="hljs-comment">'This was a catch-22 situation.',</span>
   <span class="hljs-comment">'She would not lend me her tote bag',</span>
   <span class="hljs-comment">'He had a chip on his shoulder',</span>
   <span class="hljs-comment">'The market was bearish yesterday',</span>
   <span class="hljs-comment">'That was definitely wrong',</span>
   <span class="hljs-comment">'The project was compromised but he pulled a rabit out of his hat',</span>
   <span class="hljs-comment">'So just let the chips fall where they may',</span>
   <span class="hljs-comment">'She went the extra mile to satisfy the customer',</span>
   <span class="hljs-comment">'She bailed out when it became unbearable',</span>
   <span class="hljs-comment">'The term person includes one or more individuals, labor unions, partnerships, associations, corporations, legal representatives, mutual companies, joint-stock companies, trusts, unincorporated organizations, trustees, trustees in bankruptcy, or receivers.',</span>
   <span class="hljs-comment">'The coach broke down, stopped and everybody was complaining']</span>
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">If you find spelling mistakes or minor mistakes, do not correct them during the training phase. Some amount of noise is required to reproduce human and machine errors to avoid overfitting.</p>
    </div>
    <p class="normal">Google Translate will automatically translate these sentences.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">X1</code>, as implemented in the following code, defines some keywords statistically related to the sentences; it applies the n-gram probability theory described previously.</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">X1</span>=[<span class="hljs-string">'grasse'</span>,
    <span class="hljs-string">'insoluble'</span>,
    <span class="hljs-string">'sac'</span>,
    <span class="hljs-string">'aggressif'</span>,
    <span class="hljs-string">'marché'</span>,
    <span class="hljs-string">'certainement'</span>,
    <span class="hljs-string">'chapeau'</span>,
    <span class="hljs-string">'advienne'</span>,
    <span class="hljs-string">'supplémentaire'</span>,
    <span class="hljs-string">'parti'</span>,
    <span class="hljs-string">'personne'</span>,
    <span class="hljs-string">'bus'</span>]
</code></pre>
    <p class="normal">Each line in <code class="Code-In-Text--PACKT-">X1</code> goes with the corresponding line in <code class="Code-In-Text--PACKT-">X</code>. As explained, this only remains a probability and may not be correct.</p>
    <p class="normal"><em class="italics">We are not seeking perfection at this point but an improvement.</em></p>
    <p class="normal">Let's explore how we can improve Google Translate by customizing translations by implementing a KNN in a Python program.</p>
    <h2 id="_idParaDest-116" class="title">Exploring the frontier – customizing Google Translate with a Python program</h2>
    <p class="normal">Now it's time to add <a id="_idIndexMarker271"/>some customized novelties. The <a id="_idIndexMarker272"/>use of the vectors in this section will be explained in the next section, again through the source code that uses them.</p>
    <p class="normal">A trigger vector will force the program to try an alternate method to translate a mistranslated sentence. When the sentence has been identified, and if its value in <code class="Code-In-Text--PACKT-">X2</code> is equal to <code class="Code-In-Text--PACKT-">1</code>, it triggers a deeper translation function, as implemented here:</p>
    <pre class="programlisting"><code class="hljs angelscript">X2=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">0</code> and <code class="Code-In-Text--PACKT-">1</code> are flags. Each value represents a line in <code class="Code-In-Text--PACKT-">X</code>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-"><strong class="bold">Note for developers</strong>: To use this method correctly, all the values of this vector should be set to <code class="Code-In-Text--PACKT-">1</code>. That will automatically trigger several alternate methods to translate Google Translate errors. A lot of work remains to be done here! </p>
    </div>
    <p class="normal">The example is taken from a transportation business. A transportation phrase dictionary should be built. In this case, a general <code class="Code-In-Text--PACKT-">phrase_translation</code> dictionary has been implemented with one expression, as shown in the following array.</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">phrase_translation</span>=[<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">'Il est agressif'</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>]
</code></pre>
    <p class="normal">What remains to be done in order to fill up this dictionary?</p>
    <ul>
      <li class="list">Scan all the documents of the company—emails, letters, contracts, and every form of written documents.</li>
      <li class="list">Store the embedded words and sentences.</li>
      <li class="list">Train the team to use the program to improve it by providing feedback (the right answer) in a learning interface when the system returns incorrect answers.</li>
    </ul>
    <p class="normal">What Google <a id="_idIndexMarker273"/>Translate cannot do on a <a id="_idIndexMarker274"/>global scale, you can implement at a local scale to improve the system significantly.</p>
    <p class="normal">Now that we have defined a method, we will dig into the KNN algorithm.</p>
    <h2 id="_idParaDest-117" class="title">k-nearest neighbor algorithm</h2>
    <p class="normal">No matter how you<a id="_idIndexMarker275"/> address a linguistic problem, it will always boil down to the concept of <strong class="bold">context</strong>. When somebody does not understand somebody else, they say: "you took my words out of their context<a id="_idIndexMarker276"/>," or "that is not what I meant; let me explain."</p>
    <p class="normal">As explained before, in many cases, you cannot translate a word or expression without a lexical field. The difficulty remains proportional to the polysemy property, as the program will show.</p>
    <p class="normal">Using the KNN algorithm as a classification method can prove extremely useful. Any language interpretation (translation or chatbot) will have to use a context-oriented algorithm.</p>
    <p class="normal">By finding the words closest (neighbors) to each other, KNN will create the lexical fields required to interpret a language. Even better, when provided with the proper datasets, it will solve the polysemy problem, as shown in the upcoming sections.</p>
    <h3 id="_idParaDest-118" class="title">Implementing the KNN algorithm</h3>
    <p class="normal">Generally, a word requires <a id="_idIndexMarker277"/>a context to mean something. Looking for "neighbors" close by provides an efficient way to determine where the word belongs.</p>
    <p class="normal">KNN is supervised because it uses the labels of the data provided to train its algorithm. KNN, in this case, is used for classification purposes. For a given point <em class="italics">p</em>, KNN will calculate the distances to all other points. Then, <em class="italics">k</em> represents the k-nearest neighbors to take into account.</p>
    <p class="normal">Let's clear this up by means of an example. In English, the word "coach" can mean a trainer on a football field, a bus, or a railroad passenger car. In a transportation company, "coach" will mostly be a bus that should not be confused with a trainer:</p>
    <ul>
      <li class="list"><strong class="bold">Step 1</strong>: Parsing (examining in a detailed manner) texts with "coach" as a bus and "coach" as a trainer. Thus, the program is searching for three target words: trainer, bus, and coach.</li>
      <li class="list"><strong class="bold">Step 2</strong>: Finding some words that appear close to the target words we are searching for. As recommended, do the following:<ul>
          <li class="Bullet-Within-Bullet--PACKT-">Parse all the company documents you can use with a standard program.</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">Use a Python function such as <code class="Code-In-Text--PACKT-">if(n-gram in the source)</code> then store the data.</li>
        </ul>
      </li>
    </ul>
    <p class="normal">In this case, the <code class="Code-In-Text--PACKT-">V1.csv</code> file shown in the following output excerpt provided with the source code contains the result of such a parsing function:</p>
    <pre class="programlisting"><code class="hljs lsl">broke,road,stopped,shouted,class
<span class="hljs-number">1</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">9</span>,trainer
<span class="hljs-number">1</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">5.4</span>,<span class="hljs-number">9</span>,trainer
<span class="hljs-number">1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.3</span>,<span class="hljs-number">9</span>,trainer
...
<span class="hljs-number">6.4</span>,<span class="hljs-number">6.2</span>,<span class="hljs-number">9.5</span>,<span class="hljs-number">1.5</span>,bus
<span class="hljs-number">2</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,bus
<span class="hljs-number">6.4</span>,<span class="hljs-number">6.2</span>,<span class="hljs-number">9.5</span>,<span class="hljs-number">1.5</span>,bus
...
<span class="hljs-number">3.3</span>,<span class="hljs-number">7.3</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.5</span>,coach
<span class="hljs-number">4.7</span>,<span class="hljs-number">5.7</span>,<span class="hljs-number">3.1</span>,<span class="hljs-number">3.7</span>,coach
<span class="hljs-number">2.0</span>,<span class="hljs-number">6.0</span>,<span class="hljs-number">2.7</span>,<span class="hljs-number">3.1</span>,coach
</code></pre>
    <p class="normal">Generating<a id="_idIndexMarker278"/> files such as <code class="Code-In-Text--PACKT-">V1.csv</code> is not in the scope of this chapter or book. However, you can start, among other sites, by exploring scikit-learn's text document functionality at the following link:</p>
    <p class="normal"><a href="https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html"><span class="url">https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html</span></a></p>
    <p class="normal">The program parsed emails, documents, and contracts. Each line represents the result of parsing one document. The numbers represent the occurrences (number of times the word was present). The numbers have been "squashed" (divided again and again) to remain small and manageable. For more on how to work with text data, please click on the scikit-learn link in the previous paragraph.</p>
    <p class="normal">Progressively, the words that came out with "trainer" were "shouted" more than "stopped." For a bus, "broke" (broken down as in breaking down), "road," and "stopped" appeared more than "shout."</p>
    <p class="normal">"Coach" appeared on an average of "shouted," "stopped," "road," and "broke" because it could be either a trainer or a bus, hence the problem we face when translating this word. The polysemy (several meanings) of "coach" can lead to poor translations.</p>
    <p class="normal">The <a id="_idIndexMarker279"/>KNN algorithm loaded the <code class="Code-In-Text--PACKT-">V1.csv</code> file that contains the data to be trained and finds the following result:</p>
    <figure class="mediaobject"><img src="../Images/B15438_06_01.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_08_01-1.png"/></figure>
    <p class="packt_figref">Figure 6.1: Result from the KNN algorithm</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">knn_polysemy.py</code> program determined the following:</p>
    <ul>
      <li class="list">The verb "broke" in blue has a better chance of applying to a bus (<em class="italics">x</em> axis value &gt; 6) than to a trainer (<em class="italics">x</em> axis value &lt; 4). However, "coach" remains above "trainer" and below "bus" because it can be both.</li>
      <li class="list">The word "road" follows the same logic as the blue chart.</li>
      <li class="list">The verb "stopped" can apply to a trainer and more to a bus. "Coach" remains undecided again.</li>
      <li class="list">The verb "shouted" applies clearly to a trainer more than a bus. "Coach" remains undecided again.</li>
    </ul>
    <p class="normal">Note that the coordinates of each point in these charts are as follows:</p>
    <ul>
      <li class="list"><strong class="bold">y axis</strong>: bus = 1, coach = 2, and trainer = 3.</li>
      <li class="list"><strong class="bold">x axis</strong>: The value represents the "squashed" occurrence (the number of times the word appeared) values.</li>
    </ul>
    <p class="normal">This is the result of the search for those words in many sources.</p>
    <p class="normal">When a new point, a data point named <em class="italics">P</em><sub style="font-style: italic;">n</sub> is introduced into the system, it will find its nearest neighbor(s) depending on the value of <em class="italics">k</em>.</p>
    <p class="normal">The <a id="_idIndexMarker280"/>KNN algorithm will calculate the Euclidean distance between <em class="italics">P</em><sub style="font-style: italic;">n</sub> and all the other points from <em class="italics">P</em><sub>1</sub> to <em class="italics">P</em><sub style="font-style: italic;">n</sub><sub> – 1</sub> using the Euclidean distance formula. The <em class="italics">k</em> in KNN represents the number of "nearest neighbors" the algorithm will take into account for classification purposes. The Euclidean distance (<em class="italics">d</em><sub>1</sub>) between two given points, for example, between <em class="italics">P</em><sub style="font-style: italic;">n</sub>(<em class="italics">x</em><sub>1</sub>, <em class="italics">y</em><sub>1</sub>) and <em class="italics">P</em><sub>1</sub>(<em class="italics">x</em><sub>2</sub>, <em class="italics">y</em><sub>2</sub>), is:</p>
    <figure class="mediaobject"><img src="../Images/B15438_06_001.png" alt=""/></figure>
    <p class="normal">Considering the number of distances to calculate, a function such as the one provided by <code class="Code-In-Text--PACKT-">sklearn.neighbors</code> proves necessary.</p>
    <h3 id="_idParaDest-119" class="title">The knn_polysemy.py program</h3>
    <p class="normal">The <a id="_idIndexMarker281"/>program imports the <code class="Code-In-Text--PACKT-">V1.csv</code> file described previously, prints a few lines, and prepares the labels in the correct arrays in their respective <em class="italics">x</em> axis and <em class="italics">y</em> axis, as shown in this source code example:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-comment"># Import data</span>
df = pd.read_csv(<span class="hljs-string">'V1.csv'</span>)
<span class="hljs-built_in">print</span> (df.head())
<span class="hljs-comment"># KNN Classification labels</span>
X = df.loc[:,<span class="hljs-string">'broke'</span>:<span class="hljs-string">'shouted'</span>]
Y = df.loc[:,<span class="hljs-string">'class'</span>]
</code></pre>
    <p class="normal">Then the model is trained, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs makefile"><span class="hljs-comment"># Trains the model</span>
knn = KNeighborsClassifier()
knn.fit(X,Y)
</code></pre>
    <p class="normal">Once the model is trained, a prediction is requested and is provided by the following code:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-comment"># Requesting a prediction</span>
<span class="hljs-comment">#broke and stopped are</span>
<span class="hljs-comment">#activated to see the best choice of words to fit these features.</span>
<span class="hljs-comment"># brock and stopped were found in the sentence to be interpreted.</span>
<span class="hljs-comment"># In X_DL as in X, the labels are : broke, road, stopped,shouted.</span>
X_DL = [[9,0,9,0]]
prediction = knn.predict(X_DL)
<span class="hljs-builtin-name">print</span> (<span class="hljs-string">"The prediction is:"</span>,str(prediction).strip(<span class="hljs-string">'[]'</span>))
</code></pre>
    <p class="normal">This is the result displayed:</p>
    <pre class="programlisting"><code class="hljs actionscript">The prediction <span class="hljs-keyword">is</span>: <span class="hljs-string">'bus'</span>
</code></pre>
    <p class="normal">The initial <a id="_idIndexMarker282"/>data is plotted for visualization purposes, as implemented in the following code:</p>
    <pre class="programlisting"><code class="hljs routeros"><span class="hljs-comment">#Uses the same V1.csv because the parsing has</span>
<span class="hljs-comment"># been checked and is reliable as "dataset lexical rule base".</span>
df = pd.read_csv(<span class="hljs-string">'V1.csv'</span>)
<span class="hljs-comment"># Plotting the relation of each feature with each class</span>
figure,(sub1,sub2,sub3,sub4) = plt.subplots(
    4,<span class="hljs-attribute">sharex</span>=<span class="hljs-literal">True</span>,sharey=True)
plt.suptitle(<span class="hljs-string">'k-nearest neighbors'</span>)
plt.xlabel(<span class="hljs-string">'Feature'</span>)
plt.ylabel(<span class="hljs-string">'Class'</span>)
X = df.loc[:,<span class="hljs-string">'broke'</span>]
Y = df.loc[:,<span class="hljs-string">'class'</span>]
sub1.scatter(X, Y,<span class="hljs-attribute">color</span>=<span class="hljs-string">'blue'</span>,label='broke')
sub1.legend(<span class="hljs-attribute">loc</span>=4, prop={<span class="hljs-string">'size'</span>: 5})
sub1.set_title(<span class="hljs-string">'Polysemy'</span>)
X = df.loc[:,<span class="hljs-string">'road'</span>]
Y = df.loc[:,<span class="hljs-string">'class'</span>]
sub2.scatter(X, Y,<span class="hljs-attribute">color</span>=<span class="hljs-string">'green'</span>,label='road')
sub2.legend(<span class="hljs-attribute">loc</span>=4, prop={<span class="hljs-string">'size'</span>: 5})
X = df.loc[:,<span class="hljs-string">'stopped'</span>]
Y = df.loc[:,<span class="hljs-string">'class'</span>]
sub3.scatter(X, Y,<span class="hljs-attribute">color</span>=<span class="hljs-string">'red'</span>,label='stopped')
sub3.legend(<span class="hljs-attribute">loc</span>=4, prop={<span class="hljs-string">'size'</span>: 5})
X = df.loc[:,<span class="hljs-string">'shouted'</span>]
Y = df.loc[:,<span class="hljs-string">'class'</span>]
sub4.scatter(X, Y,<span class="hljs-attribute">color</span>=<span class="hljs-string">'black'</span>,label='shouted')
sub4.legend(<span class="hljs-attribute">loc</span>=4, prop={<span class="hljs-string">'size'</span>: 5})
figure.subplots_adjust(<span class="hljs-attribute">hspace</span>=0)
plt.show()
</code></pre>
    <p class="normal">A compressed version of this program has been introduced in <code class="Code-In-Text--PACKT-">Google_Translate_Customized.py</code>, as shown here:</p>
    <pre class="programlisting"><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knn</span><span class="hljs-params">(polysemy,vpolysemy,<span class="hljs-keyword">begin</span>,<span class="hljs-keyword">end</span>)</span></span>:
    df = pd.read_csv(polysemy+<span class="hljs-string">'.csv'</span>)
    X = df.loc[<span class="hljs-symbol">:</span>,<span class="hljs-string">'broke'</span><span class="hljs-symbol">:<span class="hljs-string">'shouted'</span></span>]
    Y = df.loc[<span class="hljs-symbol">:</span>,<span class="hljs-string">'class'</span>]
    knn = KNeighborsClassifier()
    knn.fit(X,Y)
    prediction = knn.predict(vpolysemy)
    <span class="hljs-keyword">return</span> prediction
</code></pre>
    <p class="normal">The description is as follows:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">polysemy</code> is the name of the file to read because it can be any file.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">vpolysemy</code> is the vector that needs to be predicted.</li>
      <li class="list">In future, in the to-do list, <code class="Code-In-Text--PACKT-">begin</code> should replace <code class="Code-In-Text--PACKT-">broke</code> and <code class="Code-In-Text--PACKT-">end</code> should replace <code class="Code-In-Text--PACKT-">shouted</code> so that the function can predict the values of any vector.</li>
      <li class="list">The KNN classifier is called and the prediction returned.</li>
    </ul>
    <p class="normal">Now that we<a id="_idIndexMarker283"/> have prepared the KNN classifier function, we can customize Google Translate.</p>
    <h3 id="_idParaDest-120" class="title">Implementing the KNN function in Google_Translate_Customized.py</h3>
    <p class="normal">This program <a id="_idIndexMarker284"/>requires more<a id="_idIndexMarker285"/> time and research because of the concepts of linguistics involved. The best way to grasp the algorithm is to run it in order.</p>
    <p class="normal">Google Translate offers various translation methods. We will focus on two of them in the following code:</p>
    <pre class="programlisting"><code class="hljs leaf"><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">('<span class="hljs-variable">Phrase</span>-<span class="hljs-variable">Based</span> <span class="hljs-variable">Machine</span> <span class="hljs-variable">Translation</span>(<span class="hljs-variable">PBMT</span>)</span></span>model:base'): #m='base'
print('Neural Machine Translation model:nmt')
</code></pre>
    <p class="normal">These are explained as follows:</p>
    <ul>
      <li class="list"><strong class="bold">Phrase-based machine translation (PBMT)</strong>: This translates the whole sequence of <a id="_idIndexMarker286"/>words. The phrase, or rather phraseme (multi-word expression), is not always quite a sentence.</li>
      <li class="list"><strong class="bold">Neural machine translation (NMT)</strong>: This uses neural networks such as a <strong class="bold">recurrent neural network</strong> (<strong class="bold">RNN</strong>), which will be detailed later in this book. This method goes <a id="_idIndexMarker287"/>beyond the phraseme and takes <a id="_idIndexMarker288"/>the whole sentence into account. In terms of the dataset presented in this chapter, this neural network method provides slightly better results.</li>
    </ul>
    <p class="normal">Both methods and Google's other approaches are interesting, but Google Translate still requires additional customized algorithms to reach an acceptable level of quality in many cases. In this chapter, we are exploring one approach with a KNN, but you can use others as long as they work. </p>
    <p class="normal">As you have seen so far, the subject is extremely complex if you take the lexical fields and structures of the many languages, their regional variations, and jargon into account.</p>
    <h4 class="title">Step 1 – translating the X dataset line by line from English into French</h4>
    <p class="normal">The following code <a id="_idIndexMarker289"/>calls the translation function:</p>
    <pre class="programlisting"><code class="hljs sas">for xi <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>l<span class="hljs-meta">en(</span><span class="hljs-meta">X</span>)):
    source=<span class="hljs-meta">X</span>[xi]
    targetl=<span class="hljs-string">"fr"</span>;m=<span class="hljs-string">'nmt'</span>
    result = g<span class="hljs-meta">_translate(</span>source,targetl,m)
</code></pre>
    <p class="normal">The code is explained as follows:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">xi</code> is the line number in <code class="Code-In-Text--PACKT-">X</code>.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">source</code> is the <code class="Code-In-Text--PACKT-">xi</code> line in <code class="Code-In-Text--PACKT-">X</code>.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">targetl</code> is the target language, in this case, <code class="Code-In-Text--PACKT-">fr</code> (French).</li>
      <li class="list"><code class="Code-In-Text--PACKT-">m</code> is the method (PBMT or NMT), as described previously. In this case, <code class="Code-In-Text--PACKT-">nmt</code> is applied.</li>
      <li class="list">Then, the Google Translate function is called as described earlier in this chapter. The result is stored in the <code class="Code-In-Text--PACKT-">result</code> variable.</li>
    </ul>
    <h4 class="title">Step 2 – backtranslation</h4>
    <p class="normal">How can somebody know <a id="_idIndexMarker290"/>the correctness of a translation from language <em class="italics">L</em><sub>1</sub> to language <em class="italics">L</em><sub>2</sub> if <em class="italics">L</em><sub>1</sub> is the person's native language, and <em class="italics">L</em><sub>2</sub> is a language the person does not understand at all?</p>
    <p class="normal">This is one of the reasons, among others, that translators often use backtranslation to check translations:</p>
    <p class="center"><em class="italics">Translation</em> = <em class="italics">Initial translation from L</em><sub>1</sub><em class="italics"> to L</em><sub>2</sub></p>
    <p class="center"><em class="italics">Backtranslation</em> = <em class="italics">Translation back from L</em><sub>2</sub><em class="italics"> to L</em><sub>1</sub></p>
    <p class="normal">If the initial text is not obtained, then there is probably a problem. In this case, the length of the initial sentence <em class="italics">L</em><sub>1</sub> can be compared to the length of the same sentence translated back to <em class="italics">L</em><sub>1</sub>. The following code calls backtranslation:</p>
    <pre class="programlisting"><code class="hljs lisp">    back_translate=result
    back_translate = g_translate(<span class="hljs-name">back_translate</span>,targetl,m)
    print(<span class="hljs-string">"source:"</span>,source,<span class="hljs-string">":"</span>,len(<span class="hljs-name">source</span>))
    print(<span class="hljs-string">"result:"</span>,result)
    print(<span class="hljs-string">"target:"</span>,back_translate,<span class="hljs-string">":"</span>,len(<span class="hljs-name">back_translate</span>))
</code></pre>
    <p class="normal">Length comparison can be used to improve the algorithm:</p>
    <p class="center"><em class="italics">Length of the initial n-gram</em> = <em class="italics">Length of the backtranslation</em></p>
    <p class="normal">If it's equal, then<a id="_idIndexMarker291"/> the translation may be correct. If not, it could be incorrect. Of course, more methods must be applied during each translation. However, a method that leads to improvement is already a good step. In this case, the source (initial sentence) is compared to the backtranslation in the following code:</p>
    <pre class="programlisting"><code class="hljs isbl">    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">source</span> == <span class="hljs-variable">back_translate</span>):
        <span class="hljs-title">print</span>(<span class="hljs-string">"true"</span>)</span>
        <span class="hljs-function"><span class="hljs-title">if</span>((<span class="hljs-variable">term</span> <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">words</span>)<span class="hljs-variable"><span class="hljs-keyword">and</span></span> (<span class="hljs-variable">xi</span><span class="hljs-variable">!</span>=<span class="hljs-number">4</span>)):
            <span class="hljs-variable">t</span>+=<span class="hljs-number">1</span>
    <span class="hljs-variable"><span class="hljs-keyword">else</span></span>:
    <span class="hljs-variable">f</span>+=<span class="hljs-number">1</span>;<span class="hljs-title">print</span>(<span class="hljs-string">"false"</span>)</span>
</code></pre>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">t</code> is a <code class="Code-In-Text--PACKT-">True</code> counter.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">f</code> is a <code class="Code-In-Text--PACKT-">False</code> counter.</li>
    </ul>
    <p class="normal">The first line of <code class="Code-In-Text--PACKT-">X</code> runs as follows:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-attr">source: Eating fatty food can be unhealthy. :</span> <span class="hljs-number">35</span>
<span class="hljs-attr">result:</span> <span class="hljs-string">Manger</span> <span class="hljs-string">de</span> <span class="hljs-string">la</span> <span class="hljs-string">nourriture</span> <span class="hljs-string">grasse</span> <span class="hljs-string">peut</span> <span class="hljs-string">être</span> <span class="hljs-string">malsain.</span>
<span class="hljs-attr">target: Eating fat food can be unhealthy. :</span> <span class="hljs-number">33</span>
<span class="hljs-literal">false</span>
</code></pre>
    <p class="normal"><em class="italics">Eating fatty food</em> is backtranslated as <em class="italics">eating fat food</em>, which is slightly wrong. Something may be wrong.</p>
    <p class="normal">The French sentence sounds wrong, too. Fatty food cannot be translated as such. Usually, the common sentence is <em class="italics">manger gras</em>, meaning <em class="italics">eating</em> (manger) <em class="italics">fatty</em> (gras), which cannot be translated into English as such.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">X</code> array referred to in this section starts at line 8:</p>
      <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">X</span>=[<span class="hljs-string">'Eating fatty food can be unhealthy.'</span>,
   <span class="hljs-string">'This was a catch-22 situation.'</span>,
   <span class="hljs-string">'She would not lend me her tote bag'</span>,
   <span class="hljs-string">'He had a chip on his shoulder'</span>,
....]
</code></pre>
    </div>
    <p class="normal">Several phrases come back with a false translation, for example, <code class="Code-In-Text--PACKT-">X[4]</code>, <code class="Code-In-Text--PACKT-">'He had a chip on his shoulder'</code>. I programmed a phrase-based translation using a trigger in the <code class="Code-In-Text--PACKT-">False</code> condition in the following code.</p>
    <pre class="programlisting"><code class="hljs routeros">    <span class="hljs-keyword">else</span>:
        f+=1;<span class="hljs-builtin-name">print</span>(<span class="hljs-string">"false"</span>)
    <span class="hljs-keyword">if</span>(X2[xi]&gt;0):
        <span class="hljs-attribute">DT</span>=deeper_translate(source,xi)
        dt+=1
</code></pre>
    <p class="normal">Since I did not write a<a id="_idIndexMarker292"/> complete application for this book, but just some examples that can be extended in the future, I used <code class="Code-In-Text--PACKT-">X2</code> as a trigger. If <code class="Code-In-Text--PACKT-">X2[x1]&gt;0</code>, then the <code class="Code-In-Text--PACKT-">deeper_translate</code> function is activated.</p>
    <h4 class="title">Step 3 – deeper translation with phrase-based translations</h4>
    <p class="normal"><code class="Code-In-Text--PACKT-">deeper_translate</code> has two arguments:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">source</code>: The initial sentence to translate</li>
      <li class="list"><code class="Code-In-Text--PACKT-">x1</code>: The target sentence</li>
    </ul>
    <p class="normal">In this case, the problem<a id="_idIndexMarker293"/> to solve is an idiomatic expression that exists in English but does not exist in French:</p>
    <pre class="programlisting"><code class="hljs livecodeserver">source: He had <span class="hljs-keyword">a</span> chip <span class="hljs-keyword">on</span> <span class="hljs-title">his</span> <span class="hljs-title">shoulder</span> : <span class="hljs-title">29</span>
<span class="hljs-built_in">result</span>: Il avait une puce sur son épaule
target: He had <span class="hljs-keyword">a</span> chip <span class="hljs-keyword">on</span> <span class="hljs-title">his</span> <span class="hljs-title">shoulder</span> : <span class="hljs-title">29</span>
<span class="hljs-literal">false</span>
</code></pre>
    <p class="normal">To have <em class="italics">a chip on the shoulder</em> means to have an issue with something or somebody. It expresses some form of tension.</p>
    <p class="normal">Google translated <em class="italics">chip</em> by assuming computer chip, or <em class="italics">puce</em> in French, which means both <em class="italics">computer chip</em> and <em class="italics">flea</em>. The translation is meaningless.</p>
    <p class="normal"><em class="italics">Chip</em> enters three categories and should be labeled as such:</p>
    <ul>
      <li class="list">Idiomatic expression</li>
      <li class="list">Jargon</li>
      <li class="list">Polysemy</li>
    </ul>
    <p class="normal">At this point, the following function I created simulates the phrase-based solution to implement deeper translations.</p>
    <pre class="programlisting"><code class="hljs routeros">def deeper_translate(source,index):
    <span class="hljs-attribute">dt</span>=source
    <span class="hljs-attribute">deeper_response</span>=phrase_translation[index]
    <span class="hljs-keyword">if</span>(len(deeper_response)&lt;=0):
        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">"deeper translation program result:"</span>,
            deeper_response,<span class="hljs-string">":Now true"</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">deeper_translate</code> function looks for the translated sentence containing <em class="italics">chip</em> in the following <code class="Code-In-Text--PACKT-">phrase_translation</code> array (list, vector, or whatever is necessary).</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">phrase_translation</span>=[<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">'Il est agressif'</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>]
</code></pre>
    <p class="normal">The final result comes <a id="_idIndexMarker294"/>out with a translation, backtranslation, term search, and phrase translation. The following is the result produced, with comments added here before each line:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-attr">Initial sentence:</span>
<span class="hljs-attr">source: He had a chip on his shoulder :</span> <span class="hljs-number">29</span>
<span class="hljs-attr">Wrong answer:</span>
<span class="hljs-attr">result:</span> <span class="hljs-string">Il</span> <span class="hljs-string">avait</span> <span class="hljs-string">une</span> <span class="hljs-string">puce</span> <span class="hljs-string">sur</span> <span class="hljs-string">son</span> <span class="hljs-string">épaule</span>
<span class="hljs-attr">The back-translation works:</span>
<span class="hljs-attr">target: He had a chip on his shoulder :</span> <span class="hljs-number">29</span>
<span class="hljs-attr">term:</span> <span class="hljs-string">aggressif</span>
<span class="hljs-literal">false</span>
<span class="hljs-attr">deeper translation program result:</span> <span class="hljs-string">Il</span> <span class="hljs-string">est</span> <span class="hljs-string">agressif</span>
</code></pre>
    <p class="normal">The question is, where did <code class="Code-In-Text--PACKT-">term</code> come from?</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">term</code> comes from <code class="Code-In-Text--PACKT-">X1</code>, a list of keywords that should be in the translation. <code class="Code-In-Text--PACKT-">X1</code> has been entered manually, but it should be a list of possibilities resulting from an automatic search conducted on the words in the sentence viewed as classes. This means that the sentence to be translated should have several levels of meaning, not just the literal one that is being calculated.</p>
    <p class="normal">The actual <code class="Code-In-Text--PACKT-">True</code>/<code class="Code-In-Text--PACKT-">False</code> conditions contain the following deeper translation-level words to check:</p>
    <pre class="programlisting"><code class="hljs gauss">    <span class="hljs-keyword">if</span>(source == back_translate):
        <span class="hljs-keyword">print</span>(<span class="hljs-string">"true"</span>)
        <span class="hljs-keyword">if</span>((term not in words) <span class="hljs-keyword">and</span> (xi!=<span class="hljs-number">4</span>)):
            t+=<span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        f+=<span class="hljs-number">1</span>;<span class="hljs-keyword">print</span>(<span class="hljs-string">"false"</span>)
        <span class="hljs-keyword">if</span>(X2[xi]&gt;<span class="hljs-number">0</span>):
            DT=<span class="hljs-built_in">deeper_translate</span>(source,xi)
            dt+=<span class="hljs-number">1</span>
</code></pre>
    <p class="normal">In the present state of the prototype, only example four activates a phrase-based translation. Otherwise, <code class="Code-In-Text--PACKT-">True</code> is accepted. If <code class="Code-In-Text--PACKT-">False</code> is the case, the deeper translation is only activated for two cases in this sample code. The flag is in <code class="Code-In-Text--PACKT-">X2</code> (<code class="Code-In-Text--PACKT-">0</code> or <code class="Code-In-Text--PACKT-">1</code>).</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">deeper_translate</code> is called for either the phrase-based translation (described previously) or the KNN routine, which is activated if the phrase-based translation did not work.</p>
    <p class="normal">If the translation did not work, an n-gram is prepared for the KNN algorithm, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs angelscript">    <span class="hljs-keyword">if</span>(len(deeper_response)&lt;=<span class="hljs-number">0</span>):
        v1=<span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):
            ngram=V1[i]
            <span class="hljs-keyword">if</span>(ngram <span class="hljs-keyword">in</span> source):
                vpolysemy[<span class="hljs-number">0</span>][i]=<span class="hljs-number">9</span>
                v1=<span class="hljs-number">1</span>
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">V1[i]</code> contains the keywords (n-grams) described in the preceding KNN algorithm for the transport lexical field, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">V1</span>=[<span class="hljs-string">'broke'</span>,<span class="hljs-string">'road'</span>,<span class="hljs-string">'stopped'</span>,<span class="hljs-string">'shouted'</span>,<span class="hljs-string">'coach'</span>,<span class="hljs-string">'bus'</span>,<span class="hljs-string">'car'</span>,
    <span class="hljs-string">'truck'</span>,<span class="hljs-string">'break'</span>,<span class="hljs-string">'broke'</span>,<span class="hljs-string">'roads'</span>,<span class="hljs-string">'stop'</span>]
</code></pre>
    <p class="normal">The<a id="_idIndexMarker295"/> source (sentence to translate) is parsed for each n-gram. If the n-gram is found, the polysemy vector is activated for that n-gram. The initial values are set to <code class="Code-In-Text--PACKT-">0</code>, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs lua">vpolysemy=<span class="hljs-string">[[0,0,0,0]]</span>
</code></pre>
    <p class="normal">The variable <code class="Code-In-Text--PACKT-">v1</code> is activated, which informs the program that <code class="Code-In-Text--PACKT-">V1.csv</code> must be read for this case. An unlimited number of KNN references should be automatically created, as described previously in the KNN section.</p>
    <p class="normal">In this case, only <code class="Code-In-Text--PACKT-">v1</code> is activated. But after several months of working on the project for the company to customize their local needs, many other files should be created.</p>
    <p class="normal">In this case, when <code class="Code-In-Text--PACKT-">v1</code> is activated, it fills out the variables as follows.</p>
    <pre class="programlisting"><code class="hljs routeros">    <span class="hljs-keyword">if</span>(v1&gt;0):
        <span class="hljs-attribute">polysemy</span>=<span class="hljs-string">'V1'</span>
        <span class="hljs-attribute">begin</span>=str(V1[0]).strip(<span class="hljs-string">'[]'</span>);<span class="hljs-attribute">end</span>=str(V1[3]).strip(<span class="hljs-string">'[]'</span>)
        <span class="hljs-attribute">sememe</span>=knn(polysemy,vpolysemy,begin,end)
</code></pre>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">polysemy</code> indicates the KNN file to open.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">begin</code> is the first label of the <code class="Code-In-Text--PACKT-">V1</code> vector and <code class="Code-In-Text--PACKT-">end</code> is the last label of the <code class="Code-In-Text--PACKT-">V1</code> vector.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">sememe</code> is the prediction we expect.</li>
    </ul>
    <p class="normal">Now, a condensed version of the KNN algorithm is called, as described previously for <code class="Code-In-Text--PACKT-">knn_polysemy.py</code>, in the following code:</p>
    <pre class="programlisting"><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knn</span><span class="hljs-params">(polysemy,vpolysemy,<span class="hljs-keyword">begin</span>,<span class="hljs-keyword">end</span>)</span></span>:
    df = pd.read_csv(polysemy+<span class="hljs-string">'.csv'</span>)
    X = df.loc[<span class="hljs-symbol">:</span>,<span class="hljs-symbol">begin:</span><span class="hljs-keyword">end</span>]
    Y = df.loc[<span class="hljs-symbol">:</span>,<span class="hljs-string">'class'</span>]
    knn = KNeighborsClassifier()
    knn.fit(X,Y)
    prediction = knn.predict(vpolysemy)
    <span class="hljs-keyword">return</span> prediction
</code></pre>
    <p class="normal">The example, in this case, is the polysemy feature of <em class="italics">a coach</em>, as explained in the KNN section. The output will be produced as follows:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-attr">Source:</span> <span class="hljs-string">The</span> <span class="hljs-string">coach</span> <span class="hljs-string">broke</span> <span class="hljs-string">down,</span> <span class="hljs-attr">stopped and everybody was complaining :</span> <span class="hljs-number">59</span>
<span class="hljs-attr">result:</span> <span class="hljs-string">L'entraîneur</span> <span class="hljs-string">est</span> <span class="hljs-string">tombé</span> <span class="hljs-string">en</span> <span class="hljs-string">panne,</span> <span class="hljs-string">s'est</span> <span class="hljs-string">arrêté</span> <span class="hljs-string">et</span> <span class="hljs-string">tout</span> <span class="hljs-string">le</span> <span class="hljs-string">monde</span> <span class="hljs-string">se</span> <span class="hljs-string">plaignait</span>
<span class="hljs-attr">target:</span> <span class="hljs-string">The</span> <span class="hljs-string">coach</span> <span class="hljs-string">broke</span> <span class="hljs-string">down,</span> <span class="hljs-string">stopped,</span> <span class="hljs-attr">and everyone was complaining :</span> <span class="hljs-number">59</span>
<span class="hljs-attr">term:</span> <span class="hljs-string">bus</span>
<span class="hljs-literal">false</span>
</code></pre>
    <p class="normal">The translation is false because Google Translate returns <em class="italics">trainer</em> instead of <em class="italics">bus</em>.</p>
    <p class="normal">The term <em class="italics">bus</em> is identical in English and French.</p>
    <p class="normal">The KNN routine <a id="_idIndexMarker296"/>returned <em class="italics">bus</em> in English as the correct word to use when <em class="italics">broke down</em> and <em class="italics">stopped</em> were found, as shown in the KNN section.</p>
    <p class="normal">The goal of the rest of the source code in the <code class="Code-In-Text--PACKT-">deeper_translate</code> function is to replace <em class="italics">coach</em>—the word increasing the polysemy feature to translate—with a better word (limited polysemy) to translate: <code class="Code-In-Text--PACKT-">sememe</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">sememe</code> variable is initialized by the KNN function in the following code:</p>
    <pre class="programlisting"><code class="hljs sas">            sememe=k<span class="hljs-meta">nn(</span>polysemy,vpolysemy,begin,<span class="hljs-meta">end</span>)
            for i <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>2):
                <span class="hljs-meta">if</span>(V1_class[i] <span class="hljs-meta">in</span> source):
                    <span class="hljs-meta">replace</span>=str(V1_class[i]).strip(<span class="hljs-string">'[]'</span>)
                    sememe=str(sememe).strip(<span class="hljs-string">'[]'</span>)
                    dtsource = source.<span class="hljs-meta">replace</span>(<span class="hljs-meta">replace</span>,sememe)
                    targetl=<span class="hljs-string">"fr"</span>;m=<span class="hljs-string">'base'</span>
                    result = g<span class="hljs-meta">_translate(</span>dtsource,targetl,m)
                    p<span class="hljs-meta">rint(</span><span class="hljs-string">'polysemy narrowed result:'</span>,result,
                        <span class="hljs-string">":Now true"</span>)
</code></pre>
    <p class="normal">The function replaces <em class="italics">coach</em> by <em class="italics">bus</em> found by the KNN algorithm in the English sentence and then asks Google Translate to try again. The correct answer is returned.</p>
    <p class="normal">Instead of trying to translate a word with too many meanings (polysemy), the <code class="Code-In-Text--PACKT-">deeper_translate</code> function first replaces the word with a better word (less polysemy). Better results will often be attained.</p>
    <h5 class="title">Step 3.1 – adding a frequentist error probability function</h5>
    <p class="normal">A frequentist error probability <a id="_idIndexMarker297"/>function is added to measure performance, as shown in the following code:</p>
    <pre class="programlisting"><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">frequency_p</span><span class="hljs-params">(tnumber,cnumber)</span></span>:
    ff=cnumber/tnumber <span class="hljs-comment">#frequentist interpretation and probability</span>
    <span class="hljs-keyword">return</span> ff
</code></pre>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">cnumber</code> is the number of false answers returned by Google Translate.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">tnumber</code> is the number of sentences translated.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">ff</code> gives a straightforward error (translation) probability, ETP.</li>
    </ul>
    <p class="normal">The function is called when a translation is false, or <code class="Code-In-Text--PACKT-">f&gt;0</code>, as implemented in the following code:</p>
    <pre class="programlisting"><code class="hljs routeros">    <span class="hljs-keyword">if</span>(f&gt;0):
        <span class="hljs-attribute">B1</span>=frequency_p(xi+1,f) #<span class="hljs-builtin-name">error</span> detection probability before deep translation
        <span class="hljs-attribute">B2</span>=frequency_p(xi+1,f-dt) #<span class="hljs-builtin-name">error</span> detection probability after deep translation
    <span class="hljs-keyword">if</span>(f&gt;0):
        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">"ETP before DT"</span>,round(B1,2),
            <span class="hljs-string">"ETP with DT"</span>,round(B2,2))
    <span class="hljs-keyword">else</span>:
        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'Insufficient data in probability distribution'</span>)
</code></pre>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">B1</code> is the error (translation) probability (ETP) before the <code class="Code-In-Text--PACKT-">deeper_translate</code> function is called.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">B2</code> is the ETP after the <code class="Code-In-Text--PACKT-">deeper_translate</code> function is called.</li>
    </ul>
    <p class="normal">At the end of the program, a summary is displayed, as shown in the following output:</p>
    <pre class="programlisting"><code class="hljs sas">p<span class="hljs-meta">rint(</span><span class="hljs-string">"------Summary------"</span>)
p<span class="hljs-meta">rint(</span><span class="hljs-string">'Neural Machine Translation model:nmt'</span>)
p<span class="hljs-meta">rint(</span><span class="hljs-string">'Google Translate:'</span>,<span class="hljs-string">"True:"</span>,t,<span class="hljs-string">"False:"</span>,f,<span class="hljs-string">'ETP'</span><span class="hljs-meta">,round(</span>f/l<span class="hljs-meta">en(</span><span class="hljs-meta">X</span>),2))
p<span class="hljs-meta">rint(</span><span class="hljs-string">'Customized Google Translate:'</span>,<span class="hljs-string">"True:"</span>,t,<span class="hljs-string">"False:"</span>,f-dt,<span class="hljs-string">'ETP'</span><span class="hljs-meta">,round(</span>(f-dt)/l<span class="hljs-meta">en(</span><span class="hljs-meta">X</span>),2))
a=2.5;at=t+a;af=f-a #subjective acceptance of an approximate result
p<span class="hljs-meta">rint(</span><span class="hljs-string">'Google Translate acceptable:'</span>,<span class="hljs-string">"True:"</span>,at,<span class="hljs-string">"False:"</span>,af,<span class="hljs-string">'ETP'</span><span class="hljs-meta">,round(</span>af/l<span class="hljs-meta">en(</span><span class="hljs-meta">X</span>),2))
#The <span class="hljs-meta">error</span> rate should decrease <span class="hljs-meta">and</span> be stabilized <span class="hljs-meta">as</span> the KNN knowledge base increases
p<span class="hljs-meta">rint(</span><span class="hljs-string">'Customized Google Translate acceptable:'</span>,<span class="hljs-string">"True:"</span>,at,<span class="hljs-string">"False:"</span>,af-dt,<span class="hljs-string">'ETP'</span><span class="hljs-meta">,round(</span>(af-dt)/l<span class="hljs-meta">en(</span><span class="hljs-meta">X</span>),2))
</code></pre>
    <ul>
      <li class="list">A subjective acceptance of an approximate result has been added to increase the true probability.</li>
      <li class="list">The error rate should decrease as the quality of the KNN knowledge base increases. In frequent probability theory, this means that a stabilized prediction rate should be reached.</li>
    </ul>
    <p class="normal">We've come to the <a id="_idIndexMarker298"/>end of our attempts to improve Google Translate. Let's consider some of the conclusions following our experiment.</p>
    <h3 id="_idParaDest-121" class="title">Conclusions on the Google Translate customized experiment</h3>
    <p class="normal">The final error (translation) probability<a id="_idIndexMarker299"/> produced is interesting, as shown in the following output:</p>
    <pre class="programlisting"><code class="hljs groovy">&gt;&gt;------Summary------
&gt;&gt;Neural Machine Translation <span class="hljs-string">model:</span>nmt
&gt;&gt;Google <span class="hljs-string">Translate:</span> <span class="hljs-string">True:</span> <span class="hljs-number">2</span> <span class="hljs-string">False:</span> <span class="hljs-number">8</span> ETP <span class="hljs-number">0.67</span>
&gt;&gt;Customized Google <span class="hljs-string">Translate:</span> <span class="hljs-string">True:</span> <span class="hljs-number">2</span> <span class="hljs-string">False:</span> <span class="hljs-number">7</span> ETP <span class="hljs-number">0.58</span>
&gt;&gt;Google Translate <span class="hljs-string">acceptable:</span> <span class="hljs-string">True:</span> <span class="hljs-number">4.5</span> <span class="hljs-string">False:</span> <span class="hljs-number">5.5</span> ETP <span class="hljs-number">0.46</span>
&gt;&gt;Customized Google Translate <span class="hljs-string">acceptable:</span> <span class="hljs-string">True:</span> <span class="hljs-number">4.5</span> <span class="hljs-string">False:</span> <span class="hljs-number">4.5</span> ETP <span class="hljs-number">0.38</span>
</code></pre>
    <p class="normal">Even with its NMT model, Google Translate is still struggling.</p>
    <p class="normal">This provides great opportunities for AI linguists, as shown with some of the methods presented to improve Google Translate at a local level that could go even further.</p>
    <p class="normal">This experiment with Google Translate shows that Google has just scratched the surface of real-life translations that sound right to the native speakers that receive these translations. It would take a real company project to get this on track with a financial analysis of its profitability before consuming resources.</p>
    <h3 id="_idParaDest-122" class="title">The disruptive revolutionary loop</h3>
    <p class="normal">As you can now see, Google Translate, like all AI solutions, has its limits. Once this limit has been reached, you are at the cutting edge.</p>
    <p class="normal">Cross the border into AI Frontierland; innovate on your own or with a team.</p>
    <p class="normal">If you work for a corporation, you can create a revolutionary customized solution for hundreds of users. It does not have to go public. It can remain a strong asset to your company.</p>
    <p class="normal">At some point or other, the revolutionary add-on will reach beyond the company, and others will use it. It will become disruptive.</p>
    <p class="normal">Finally, others will reach the limit of your now-disruptive solution. They will then innovate and customize it in their corporation as a revolutionary solution. This is what I call the disruptive revolutionary loop. It is challenging and exciting because it means that AI developers will not all be replaced in the near future by AutoAI bots!</p>
    <p class="normal">Designing a solution does not mean it will be an invention, an innovation, revolutionary, or disruptive. But that does not really matter. What a company earns with a solution represents more than the novelty of what it sells as long as it is profitable. That is rule number 1. That said, without innovating in its market, that company will not survive through the years.</p>
    <p class="normal">If a product requires quality for security reasons, it should remain in its invention state as long as necessary. If a product can produce sales at the low end of the market before its total completion, then the company should sell it. The company will acquire a reputation for innovation, get more money to invest, and take over the territory of its competitors.</p>
    <h1 id="_idParaDest-123" class="title">Summary</h1>
    <p class="normal">Google Translate is a good example of disruptive marketing. As shown, the theory, the model, and even the cloud architecture are over 10 years old. But each time one of the hundreds of millions of users stumbles across it, it creates more disruption by hooking the user onto Google solutions. The user will come back again and again to view more advertisements, and everyone is happy!</p>
    <p class="normal">AI has only just begun. Google Translate has been around since 2006. However, the results still leave room for developers, linguists, and mathematicians to improve upon. Google has added a neural network and offers other models to improve translations by analyzing whole sentences. How long will it take to be really reliable? In the meantime, the world community is moving AI forward beyond the cutting edge into Frontierland.</p>
    <p class="normal">In this chapter, we first carefully explored the difference between inventing and innovation. An innovation has an impact on the rest of the market. An invention is just the starting point of an innovation. We saw that a revolutionary solution could be a technical breakthrough. But that revolutionary solution will only become disruptive when it spreads out to the rest of the market.</p>
    <p class="normal">We then studied some basic linguistics principles that could help us understand Google Translate, its limits, and how to improve translation errors.</p>
    <p class="normal">We finally implemented a customized translation tool using a KNN to work around Google Translate errors.</p>
    <p class="normal">In the next chapter, <em class="italics">Chapter 7</em>, <em class="italics">Optimizing Blockchains with Naive Bayes</em>, we will go further in our investigation of the new frontier of AI by using blockchains to make predictions in corporate environments.</p>
    <h1 id="_idParaDest-124" class="title">Questions</h1>
    <ol>
      <li class="list">Is it better to wait until you have a top-quality product before putting it on the market? (Yes | No)</li>
      <li class="list">Considering the investment made, a new product should always be priced high to reach the top segment of the market. (Yes | No)</li>
      <li class="list">Inventing a new solution will make it known in itself. (Yes | No)</li>
      <li class="list">AI can solve most problems without using standard non-learning algorithms. (Yes | No)</li>
      <li class="list">Google Translate can satisfactorily translate all languages. (Yes | No)</li>
      <li class="list">If you are not creative, it is no use trying to innovate. (Yes | No)</li>
      <li class="list">If you are not a linguist, it is no use bothering with trying to improve Google Translate. (Yes | No)</li>
      <li class="list">Translating is too complicated to understand. (Yes | No)</li>
      <li class="list">AI has already reached its limits. (Yes | No)</li>
    </ol>
    <h1 id="_idParaDest-125" class="title">Further reading</h1>
    <ul>
      <li class="list">The Harvard Business Review on disruptive innovations can be found here: <a href="https://hbr.org/2015/12/what-is-disruptive-innovation"><span class="url">https://hbr.org/2015/12/what-is-disruptive-innovation</span></a></li>
      <li class="list">Google Translate documentation can be found here: <a href="https://cloud.google.com/translate/docs/ "><span class="url">https://cloud.google.com/translate/docs/</span></a></li>
      <li class="list">Google AlphaGo Zero: <a href="https://deepmind.com/blog/article/alphago-zero-starting-scratch"><span class="url">https://deepmind.com/blog/article/alphago-zero-starting-scratch</span></a></li>
      <li class="list">KNN documentation: <a href="http://scikit-learn.org/stable/modules/neighbors.html#neighbors"><span class="url">http://scikit-learn.org/stable/modules/neighbors.html#neighbors</span></a></li>
      <li class="list">Insights on translation ANNs: <a href="https://research.googleblog.com/2016/09/a-neural-network-for-machine.html"><span class="url">https://research.googleblog.com/2016/09/a-neural-network-for-machine.html</span></a></li>
      <li class="list">Insights on English-French translations: <a href="http://www.oneskyapp.com/blog/french-translation-challenges/"><span class="url">http://www.oneskyapp.com/blog/french-translation-challenges/</span></a></li>
      <li class="list">More on how to work with text data to build datasets for your algorithms: <a href="https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html"><span class="url">https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html</span></a></li>
    </ul>
  </div>
</body></html>