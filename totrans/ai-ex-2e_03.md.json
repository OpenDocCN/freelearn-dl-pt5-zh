["```py\n# Gamma: It's a form of penalty or uncertainty for learning\n# If the value is 1, the rewards would be too high.\n# This way the system knows it is learning.\ngamma = 0.8 \n```", "```py\nfor i in range(50000):\n    current_state = ql.random.randint(0, int(Q.shape[0]))\n    PossibleAction = possible_actions(current_state)\n    action = ActionChoice(PossibleAction)\n    reward(current_state,action,gamma) \n```", "```py\nfor i in range(sec): \n```", "```py\nconv=Q.sum() \n```", "```py\nQ.sum() \n```", "```py\n    ci=0          # convergence counter which counts the number of episodes\n    conv=0        # sum of Q at state 1 and then every x episodes\n    nc=1          # numerical convergence activated to perform numerical-controlled gradient descent\n    xi=100        # xi episode optimizer: stop as soon as convergence reached + xi-x(unknown)\n    sec=2500      # security number of episodes for this matrix size brought down from 50,000 to 2,500\n    cq=ql.zeros((2500, 1)) \n    ```", "```py\n    for i in range(sec):\n        current_state = ql.random.randint(0, int(Q.shape[0]))\n        PossibleAction = possible_actions(current_state)\n        action = ActionChoice(PossibleAction)\n        reward(current_state,action,gamma)\n        ci+=1                          # convergence counter incremented by 1 at each state\n        if(nc==1):                      # numerical convergence activated \n    ```", "```py\n     if(i==1):               # at state one, conv is activated\n                conv=Q.sum()    # conv= the sum of Q \n    ```", "```py\n     print(\"Episode\",i,\"Local derivative:\",-Q.sum()+conv,... \n    ```", "```py\n     print(... \"Numerical Convergence value estimator\",\n                Q.sum()-conv)\n                    cq[i][0]=Q.sum()-conv \n    ```", "```py\n     if(ci==xi):   # every 100 episodes the system checks to see... \n    ```", "```py\n if(conv!=Q.sum()): # if the sum of Q changes...\n                conv=Q.sum()   # ...the training isn't over, conv is updated\n                ci=0           # ...the convergence counter is set to O \n```", "```py\nEpisode 1911 Local derivative: -9.094947017729282e-13 Numerical Convergence value estimator 9.094947017729282e-13\nEpisode 1912 Local derivative: -9.094947017729282e-13 Numerical Convergence value estimator 9.094947017729282e-13\nEpisode 1913 Local derivative: -1.3642420526593924e-12 Numerical Convergence value estimator 1.3642420526593924e-12 \n```", "```py\n if(conv==Q.sum()):        # ...if the sum of Q has changed\n                print(i,conv,Q.sum()) # ...if it hasn't the training is over\n                break                 # ...the system stops training \n```", "```py\nEpisode 2096 Local derivative: 0.0 Numerical Convergence value estimator 0.0\nEpisode 2097 Local derivative: 0.0 Numerical Convergence value estimator 0.0\nEpisode 2098 Local derivative: 0.0 Numerical Convergence value estimator 0.0\nEpisode 2099 Local derivative: 0.0 Numerical Convergence value estimator 0.0 \n```", "```py\nnumber of episodes: 2099 \n```", "```py\n cq[i][0]=Q.sum()-conv \n```", "```py\nimport matplotlib.pyplot as plt\nplt.plot(cq)\nplt.xlabel('Episodes')\nplt.ylabel('Convergence Distances')\nplt.show() \n```", "```py\norigin=int(input(\"index number origin(A=0,B=1,C=2,D=3,E=4,F=5): \")) \n```", "```py\nindex number origin(A=0,B=1,C=2,D=3,E=4,F=5): 1\n…/…\nprint(\"Path:\")\n-> B\n-> D\n-> C \n```", "```py\nimport collections       # from Python library container datatypes\nimport pydotplus         # a Python Interface to Graphviz's Dot language.(dot-V command line \n```", "```py\nfeatures = [ 'Priority/location', 'Volume', 'Flow_optimizer' ] \n```", "```py\nY = ['Low', 'Low', 'High', 'High', 'Low', 'Low'] \n```", "```py\nX = [[256, 1,0],\n     [320, 1,0],\n     [500, 1,1],\n     [400, 1,0],\n     [320, 1,0],\n     [256, 1,0]] \n```", "```py\nclassify = tree.DecisionTreeClassifier()\nclassify = classify.fit(X,Y) \n```", "```py\ninfo = tree.export_graphviz(classify,feature_names=features,\n    out_file=None, filled=True,rounded=True)\ngraph = pydotplus.graph_from_dot_data(info)\nedges = collections.defaultdict(list)\nfor edge in graph.get_edge_list():\n    edges[edge.get_source()].append(int(edge.get_destination()))\nfor edge in edges:\n    edges[edge].sort()\n    for i in range(2):\n        dest = graph.get_node(str(edges[edge][i]))[0]\ngraph.write_png(<your file name here>.png) \n```", "```py\n        X = [[256, 1,0],\n              [320, 1,0],\n              [500, 1,1],\n              [400, 1,0],\n              [320, 1,0],\n              [256, 1,0]] \n        ```"]