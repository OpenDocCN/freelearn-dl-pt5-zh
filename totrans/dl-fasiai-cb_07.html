<html><head></head><body>
		<div id="_idContainer250">
			<h1 id="_idParaDest-166"><em class="italic"><a id="_idTextAnchor178"/>Chapter 7</em>: Deployment and Model Maintenance</h1>
			<p>So far in this book, you have trained a wide variety of fastai models, including models trained with tabular datasets, models trained with text datasets, recommender systems, and models trained with image data. All the models that you have trained have been exercised in the context of Jupyter notebooks. Jupyter notebooks are great for training models and exercising them with a couple of test examples, but what about actually making your model useful? How do you make your model available to other people or applications to actually solve problems? </p>
			<p>The process of making your deep learning models available to other people or applications is called <strong class="bold">deployment</strong>. In this chapter, we will go through recipes that show how to deploy your fastai models. The industrial-strength production deployment of deep learning models is beyond the scope of this book. Instead, in this chapter, you will learn how to create simple, self-contained deployments that you can serve from your own local system.</p>
			<p>Here are the recipes that will be covered in this chapter:</p>
			<ul>
				<li>Setting up fastai on your local system</li>
				<li>Deploying a fastai model trained on a tabular dataset </li>
				<li>Deploying a fastai model trained on an image dataset</li>
				<li>Maintaining your fastai model</li>
				<li>Test your knowledge</li>
			</ul>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor179"/>Technical requirements</h1>
			<p>In this chapter, you will be running deployments on your local system, which requires having fastai installed on your local system. To run fastai locally, a Windows or Linux system is recommended, with Python installed. While fastai can be installed on macOS, you will save yourself a lot of headaches if you use a Windows or Linux system for your local installation of fastai. </p>
			<p>Ensure that you have cloned the repo for the book at <a href="https://github.com/PacktPublishing/Deep-Learning-with-fastai-Cookbook">https://github.com/PacktPublishing/Deep-Learning-with-fastai-Cookbook</a> and have access to the <strong class="source-inline">ch7</strong> folder. This folder contains the code samples described in this chapter.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor180"/>Setting up fastai on your local system</h1>
			<p>The first step in <a id="_idIndexMarker560"/>being able to do a simple web deployment of a fastai deep learning model is to set up your local system with PyTorch and fastai. You need to do this because you will be running code on your local system that invokes models that you trained earlier in this book. To exercise models to make predictions on your local system, you need to have the fastai framework installed. In this recipe, you will see how to set up fastai on your local system and how to validate your installation.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor181"/>Getting ready</h2>
			<p>Ensure that you have Python (at least 3.7) installed on your local system.</p>
			<p>To check the level of Python, enter the following command on the command line:</p>
			<p class="source-code">python –version</p>
			<p>The output will show the version of Python installed on your local system as follows:</p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/B16216_7_1.jpg" alt="Figure 7.1 – Python version&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Python version</p>
			<p>Ensure that you have cloned the book's repo at <a href="https://github.com/PacktPublishing/Deep-Learning-with-fastai-Cookbook">https://github.com/PacktPublishing/Deep-Learning-with-fastai-Cookbook</a> to your local system.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor182"/>How to do it…</h2>
			<p>To set up fastai on your <a id="_idIndexMarker561"/>local system, you need to set up PyTorch (the deep learning framework upon which fastai runs) and then fastai. To do this, run through the following steps:</p>
			<ol>
				<li>Install PyTorch on your local system by running the following command in a terminal or command window of your local system. You can find complete details about installing PyTorch on your local system here: <a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a>:<p class="source-code"><strong class="bold">pip3 install torch==1.8.1+cpu torchvision==0.9.1+cpu torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html</strong></p></li>
				<li>Install fastai on your local system by following the instructions here for your operating system and typical Python installation approach: <a href="https://docs.fast.ai/">https://docs.fast.ai/</a>.</li>
				<li>Once you have installed PyTorch and fastai, validate your installation by opening up the <strong class="source-inline">validate_local_setup.ipynb</strong> notebook from the <strong class="source-inline">ch7</strong> directory in your local repo and run the following cell:<p class="source-code">import fastai</p><p class="source-code">fastai.__version__</p></li>
			</ol>
			<p>Congratulations! You have successfully set up fastai on your local system.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor183"/>How it works…</h2>
			<p>You may be asking why it's necessary to set up fastai on a local system to demonstrate how to deploy a fastai model. While it is possible to deploy fastai models without using your local system, there are several advantages to installing fastai locally:</p>
			<ol>
				<li value="1">You have complete control over the entire environment. By installing fastai locally, you can control the entire stack, from the level of pandas to the details of the web pages that you will use for deployment.</li>
				<li>By deploying fastai models locally, you will avoid shortcuts that could limit your complete appreciation of how fastai models work when they are deployed. The deployments that you will see in this chapter may be simple but they are complete. By working through recipes where nothing is left as a black box, you will gain a thorough understanding of what is really happening when a fastai model is deployed.</li>
				<li>If you are serious about exploiting fastai, it is handy to have a local installation. Back in <a href="B16216_01_Final_VK_ePub.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Getting Started with fastai</em>, I specified that you would need a cloud environment, either Gradient or Colab, to run through the recipes in this book. Most fastai applications require GPUs to be trained efficiently. Setting up a GPU on an existing local system is not easy, and buying a pre-configured system with a GPU only makes sense if you are fully committed to exploiting the GPU regularly by <a id="_idIndexMarker562"/>working full-time on deep learning applications. So, a cloud environment that is GPU-enabled is the best place to start. However, having a working fastai environment on your local system can be very useful even if you're not going to be using the local system for model training. For example, in the process of writing this book, there were a couple of instances where there was a problem with the Gradient environment where I did most of the development of recipes for this book. Because I have fastai installed locally, when Gradient was unavailable, I could still use my local system to make progress on coding outside of the model.</li>
				<li>If you don't already have some exposure to web application development, you will benefit from the brief experience you will get in this chapter. In my experience, many data scientists have zero idea of how web applications work, and since most of what we work on will eventually be rendered in one form or another in a web framework, it behooves us to get a basic understanding of how web applications work. By using a combination of the Python Flask library and basic HTML and JavaScript, we will create a very simple, yet complete, web application that illustrates some basic web application principles. If you haven't come across these principles before, you will find them useful to have in your toolbox.</li>
			</ol>
			<p>I hope that this background helps to convince you of the value of having a working fastai setup on your local system. Now that you have completed the fastai setup, you are ready for the <a id="_idIndexMarker563"/>subsequent sections where you deploy models on your local syste<a id="_idTextAnchor184"/>m.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor185"/>Deploying a fastai model trained on a tabular dataset </h1>
			<p>Back in the <em class="italic">Saving a trained tabular model</em> recipe in <a href="B16216_03_Final_VK_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a><em class="italic">, Training Models with Tabular Data</em>, you exercised a fastai model <a id="_idIndexMarker564"/>that you had saved. Recall the steps you went through in the recipe. </p>
			<p>First, you loaded the saved model as follows:</p>
			<p class="source-code">learn = load_learner('/storage/data/adult_sample/adult_sample_model.pkl')</p>
			<p>Then you took a test sample and generated a prediction from the model for the test sample:</p>
			<p class="source-code">test_sample = df_test.iloc[0]</p>
			<p class="source-code">learn.predict(test_sample)</p>
			<p>The output of the prediction, as shown in the following screenshot, included the values of the input sample, the prediction, and probability of each outcome for the prediction:</p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B16216_7_2.jpg" alt="Figure 7.2 – Output of running a prediction on the saved adult_sample_model model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Output of running a prediction on the saved adult_sample_model model</p>
			<p>In the web deployment of the model described in this recipe, you will be going through exactly the same steps (as outlined in the following list) as you went through in the recipe from <a href="B16216_03_Final_VK_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a><em class="italic">, Training Models with Tabular Data</em>, that we just reviewed:</p>
			<ol>
				<li value="1">Load the saved, trained model.</li>
				<li>Apply the model to an input sample.</li>
				<li>Get the prediction from the model.</li>
			</ol>
			<p>Unlike the recipe in <a href="B16216_03_Final_VK_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a><em class="italic">, Training Models with Tabular Data</em>, where all the action took place in the context of a Jupyter notebook, in this recipe you will be accomplishing <a id="_idIndexMarker565"/>these steps through a simple web application. You will be able to enter new input samples and get predictions on them in a very natural fashion, and you will see the predictions as clear English statements rather than as tensors. Even better, you will be able to share your web application with others so they can exercise your model and see the predictions that it makes. In short, by deploying your model, you will transform it from an abstract coding artifact that can only be accessed in a program to a useful piece of software that non-programmers can actually use.</p>
			<p>The deployment described in this section incorporates a web server implemented as a Flask module. Flask is a Python library that lets you serve web applications from the familiar surroundings of Python. In this recipe, you will start the Flask module and then use the web pages that it serves to exercise the model.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor186"/>Getting ready</h2>
			<p>Ensure that you have followed the steps in the <em class="italic">Setting up fastai on your local system</em> recipe to get fastai installed on your local system. Confirm that you can access the files in the <strong class="source-inline">deploy_tabular</strong> directory of the <strong class="source-inline">ch7</strong> directory of your repo.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor187"/>How to do it…</h2>
			<p>To deploy a model trained on a tabular dataset on your system, you will start the Flask server and work through the associated web pages to validate that you can get a prediction from the model for a given set of input scoring parameters. Complete the following steps to do this: </p>
			<ol>
				<li value="1">From a command window/terminal on your local system, make <strong class="source-inline">deploy_tabular</strong> in the <strong class="source-inline">ch7</strong> directory of your repo your current directory.</li>
				<li>Enter the following command in the command line/terminal to start the Flask server:<p class="source-code"><strong class="bold">python web_flask_deploy.py</strong></p><p>The output of this command indicates that the web server is running <strong class="source-inline">localhost:5000</strong>, as shown in the following screenshot:</p><div id="_idContainer234" class="IMG---Figure"><img src="image/B16216_7_3.jpg" alt="Figure 7.3 – Output when the Flask server starts&#13;&#10;"/></div><p class="figure-caption">Figure 7.3 – Output when the Flask server starts</p></li>
				<li>Open a <a id="_idIndexMarker566"/>browser window and enter the following in the address field:<p class="source-code"><strong class="bold">Localhost:5000</strong></p><p>If the Flask server started successfully, the <strong class="source-inline">home.html</strong> web page will be loaded in the browser, as shown in <em class="italic">Figure 7.4</em>:</p><div id="_idContainer235" class="IMG---Figure"><img src="image/B16216_7_4.jpg" alt="Figure 7.4 – home.html being server by the Flask server&#13;&#10;"/></div><p class="figure-caption">Figure 7.4 – home.html being server by the Flask server</p></li>
				<li>Now, select <strong class="bold">Get prediction</strong>. When <a id="_idIndexMarker567"/>you select this button, the <strong class="bold">query string</strong> shown in <em class="italic">Figure 7.5</em> gets <a id="_idIndexMarker568"/>displayed momentarily at the bottom of the page. This query string specifies the values of the <strong class="bold">scoring parameters</strong>, that is, the values that will be used to exercise the model. These are the values specified in the fields in <strong class="source-inline">home.html</strong>, in this case the default values for the fields:</li>
			</ol>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B16216_7_5.jpg" alt="Figure 7.5 – The query string generated with the default setting in home.html&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – The query string generated with the default setting in home.html</p>
			<p>After a few seconds, the <strong class="source-inline">show-prediction.html</strong> web page is displayed with the prediction the model made for the values entered in <strong class="source-inline">home.html</strong>, as shown in <em class="italic">Figure 7.6</em>:</p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B16216_7_6.jpg" alt="Figure 7.6 – The model's prediction displayed in show-prediction.html&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – The model's prediction displayed in show-prediction.html</p>
			<p>Congratulations! You <a id="_idIndexMarker569"/>have successfully set up a Flask server and exercised the web deployment of a fastai model in the context of simple web page deployment.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor188"/>How it works…</h2>
			<p>There was a lot going on behind the scenes when you ran through this recipe. In this section, we'll begin by going through an overview of the flow through the web deployment and then we'll dig deeper into the key pieces of code that make up the deployment.</p>
			<h3>Overview of how the web deployment of the fastai tabular model works</h3>
			<p>The web deployment described in this <a id="_idIndexMarker570"/>recipe is a departure from the recipes you have seen so far in this book. Unlike the other recipes, which involved a single code file in the form of a Jupyter notebook, the web deployment incorporates code that is spread across a series of files, as shown in <em class="italic">Figure 7.7</em>:</p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B16216_7_7.jpg" alt="Figure 7.7 – Overview of the web deployment of a fastai model using Flask&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Overview of the web deployment of a fastai model using Flask</p>
			<p>Here are the <a id="_idIndexMarker571"/>key items highlighted by the numbers in <em class="italic">Figure 7.7</em>:</p>
			<ol>
				<li value="1"><strong class="source-inline">home.html</strong> – This is the web page where the user specifies the <strong class="bold">scoring parameters</strong>, that is, the details (including <strong class="bold">work class</strong>, <strong class="bold">age</strong>, <strong class="bold">education level</strong>, and <strong class="bold">occupation</strong>) for the individual for whom they want the model to make a prediction. These scoring parameters will be fed into the model and the model will return a prediction on whether the individual described by the scoring parameters has an income above or below 50,000. There is one control on <strong class="source-inline">home.html</strong> for every feature that was used to train the model. <strong class="source-inline">home.html</strong> incorporates a set of JavaScript functions that set the available values in each control, package up the user's entries, and call <strong class="source-inline">show-prediction.html</strong> with the scoring parameters as arguments.</li>
				<li>The Flask <strong class="source-inline">web_flask_deploy.py</strong> module – A Python module that uses the Flask library to serve the web pages that make up the web deployment. This module includes <strong class="bold">view functions</strong> for <strong class="source-inline">home.html</strong> and <strong class="source-inline">show-prediction.html</strong> that do most of the work for the web deployment. The view function for <strong class="source-inline">show-prediction.html</strong> parses the scoring parameters sent from <strong class="source-inline">home.html</strong>, assembles the scoring parameter values into a DataFrame, calls the trained model using the DataFrame containing the scoring parameters to get a prediction, generates a string from the model's prediction, and finally triggers <strong class="source-inline">show-prediction.html</strong> to be displayed with the prediction string.</li>
				<li>The fastai <a id="_idIndexMarker572"/> <strong class="source-inline">adult_sample_model.pkl</strong> model – This is the model that you trained and saved in the <em class="italic">Saving a trained tabular model</em> recipe of <a href="B16216_03_Final_VK_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a><em class="italic">, Training Models with Tabular Data</em>. The view function for <strong class="source-inline">show-prediction.html</strong> in the <strong class="source-inline">web_flask_deploy.py</strong> Flask module loads this model and then uses it to make a prediction with the scoring parameters entered in <strong class="source-inline">home.html</strong>.</li>
				<li><strong class="source-inline">show-prediction.html</strong> – This web page displays the prediction made by the model on the scoring parameters entered in <strong class="source-inline">home.html</strong>. Once the user has read the prediction, they can select the <strong class="bold">Get another prediction</strong> button to go back to <strong class="source-inline">home.html</strong> to enter another set of scoring parameters.</li>
			</ol>
			<p>That is a high-level summary of how the web deployment works. Next, we'll take a look at some of the key pieces of code that make up the deployment.</p>
			<h3>Digging deeper into the code behind the web deployment</h3>
			<p>Now that you have <a id="_idIndexMarker573"/>seen the high-level picture of what's happening behind the scenes, let's dig into two pieces of code that are particularly important to the overall web deployment. We'll go through the major code items that make up the deployment, including the Python code in the Flask server module as well as the JavaScript functions in the HTML files.</p>
			<p>When you start the Flask server, as shown in <em class="italic">Step 2</em> of the recipe, the trained model is loaded into the Python module, as shown in this snippet from the Flask server code:</p>
			<p class="source-code">path = Path(os.getcwd())</p>
			<p class="source-code">full_path = os.path.join(path,'adult_sample_model.pkl')</p>
			<p class="source-code">learner = load_learner(full_path)</p>
			<p>Here are the <a id="_idIndexMarker574"/>key parts of this snippet:</p>
			<ul>
				<li><strong class="source-inline">path = Path(os.getcwd())</strong> – Sets <strong class="source-inline">path</strong> to be the directory where you started the Flask server. The code assumes the model file is in the same directory.</li>
				<li><strong class="source-inline">full_path = os.path.join(path,'adult_sample_model.pkl')</strong> – Defines the full path for the model, including the filename.</li>
				<li><strong class="source-inline">learner = load_learner(full_path)</strong> – Loads the model into <strong class="source-inline">learner</strong>.</li>
			</ul>
			<p>When you go to <strong class="source-inline">localhost:5000</strong> in your browser, the <strong class="source-inline">home.html</strong> page gets displayed. How does this happen? In the <strong class="source-inline">web_flask_deploy.py</strong> Flask module, the <strong class="bold">view function</strong> for <strong class="source-inline">home.html</strong> controls what happens when you navigate to <strong class="source-inline">localhost:5000</strong> when the Flask server is active, as shown in the following code snippet:</p>
			<p class="source-code">@app.route('/')</p>
			<p class="source-code">def home():   </p>
			<p class="source-code">    title_text = "fastai deployment"</p>
			<p class="source-code">    title = {'titlename':title_text}</p>
			<p class="source-code">    return render_template('home.html',title=title)  </p>
			<p>Here are the key parts of this view function:</p>
			<ul>
				<li><strong class="source-inline">@app.route('/')</strong> – Specifies that this view function is applied when you navigate to the <strong class="source-inline">localhost:5000</strong> address</li>
				<li><strong class="source-inline">return render_template('home.html',title=title)</strong> – Specifies that <strong class="source-inline">home.html</strong> is displayed when you navigate to <strong class="source-inline">localhost:5000</strong></li>
			</ul>
			<p>As <strong class="source-inline">home.html</strong> is loaded, the action moves from Python in the Flask server module to a combination of HTML and JavaScript in <strong class="source-inline">home.html</strong>. First, the <strong class="source-inline">load_selections()</strong> function is called to load values into the controls in the web page, as shown in the following HTML statement:</p>
			<p class="source-code">&lt;body onload="load_selections()"&gt;</p>
			<p>The <strong class="source-inline">load_selections()</strong> function <a id="_idIndexMarker575"/>populates the select controls (drop-down lists) on the page with lists specifying the valid values, such as the following for the <strong class="source-inline">relationship</strong> control:</p>
			<p class="source-code">var relationship_list = [" Wife" ," Not-in-family" ," Unmarried" ," Husband" ," Own-child" ," Other-relative" ];</p>
			<p>The <strong class="source-inline">load_selections()</strong> function also includes <strong class="source-inline">for</strong> loops that set the values in the select controls to the lists of valid values, such as the following <strong class="source-inline">for</strong> loop that populates the <strong class="source-inline">relationship</strong> <a id="_idTextAnchor189"/>control:</p>
			<p class="source-code">for(var i = 0; i &lt; relationship_list.length; i++) {</p>
			<p class="source-code">      var opt = relationship_list[i];</p>
			<p class="source-code">      select_relationship.innerHTML += "&lt;option value=\"" + opt + "\"&gt;" + opt + "&lt;/option&gt;";</p>
			<p>For the controls for entering numeric values, the <strong class="source-inline">load_selections()</strong> function sets the default values that appear when the page is loaded. For example, the following statement in the <strong class="source-inline">load_selections()</strong> function sets the default value for the <strong class="source-inline">age</strong> field: </p>
			<p class="source-code">document.getElementById("age").defaultValue = 40;</p>
			<p>Once the values are loaded in the controls and the page is displayed, the user can select values for the scoring parameters in the controls that are different from the defaults. </p>
			<p>After the user has selected values for the scoring parameters, the user can select the <strong class="bold">Get prediction</strong> button. Here is the HTML associated with that button. It specifies that the <strong class="source-inline">link_with_args()</strong> function gets called when the button is selected:</p>
			<p class="source-code">&lt;button&gt;</p>
			<p class="source-code">&lt;a onclick="link_with_args();" style="font-size : 20px; width: 100%; height: 100px;"&gt;Get prediction&lt;/a&gt;</p>
			<p class="source-code">&lt;/button&gt;</p>
			<p>The <strong class="source-inline">link_with_args()</strong> function calls the <strong class="source-inline">getOption()</strong> function that loads the values the user selected in the controls in <strong class="source-inline">home.html</strong> and builds the query string with these values, as shown in the following snippet from <strong class="source-inline">getOption()</strong>:</p>
			<p class="source-code">prefix = "/show-prediction/?"</p>
			<p class="source-code">window.output = prefix.concat("workclass=",workclass_string,"&amp;age=",age_value,"&amp;fnlwgt=",fnlwgt_value,"&amp;education=",education_string,"&amp;education-num=",education_num_value,"&amp;marital-status=",marital_status_string,"&amp;occupation=",occupation_string,"&amp;relationship=",relationship_string,"&amp;race=",race_string,"&amp;sex=",sex_string,"&amp;capital-gain=",capital_gain_value,"&amp;capital-loss=",capital_loss_value,"&amp;hours-per-week=",hours_per_week_value,"&amp;native-country=",native_country_string);</p>
			<p class="source-code">document.querySelector('.output').textContent = window.output;</p>
			<p>Here are the <a id="_idIndexMarker576"/>key parts of this snippet:</p>
			<ul>
				<li><strong class="source-inline">prefix = "/show-prediction/?"</strong> – Specifies which view function in the Flask module will be invoked when the link is triggered.</li>
				<li><strong class="source-inline">window.output</strong> – Specifies the set of parameters included in the query string. This string is made up of a series of key value pairs, where each value equals the corresponding control in <strong class="source-inline">home.html</strong>. </li>
				<li><strong class="source-inline">document.querySelector('.output').textContent = window.output;</strong> – Specifies that the query string is displayed in the browser window.</li>
			</ul>
			<p>You may recall seeing the query string in this recipe. In <em class="italic">Step 4</em> of the recipe, when you selected the <strong class="bold">Get prediction</strong> button in <strong class="source-inline">home.html</strong>, the query string was briefly displayed at the bottom of the page before <strong class="source-inline">show-prediction.html</strong> was loaded.</p>
			<p>After calling <strong class="source-inline">getOption()</strong>, the <strong class="source-inline">link_with_args()</strong> function triggers a reference to <strong class="source-inline">show-prediction.html</strong> with the following statement:</p>
			<p class="source-code">window.location.href = window.output;</p>
			<p>With this statement, the action switches from the world of HTML and JavaScript back to Python, and the view function for <strong class="source-inline">show-prediction.html</strong> is invoked in the Flask server. Here is the beginning of this view function where the scoring parameter values that were entered in <strong class="source-inline">home.html</strong> and passed along in the query string are loaded into the <strong class="source-inline">score_df</strong> DataFrame: </p>
			<p class="source-code">@app.route('/show-prediction/')</p>
			<p class="source-code">def show_prediction():</p>
			<p class="source-code">     score_df = pd.DataFrame(columns=scoring_columns)</p>
			<p class="source-code">for col in scoring_columns:</p>
			<p class="source-code">        print("value for "+col+" is: "+str(request.args.get(col)))    </p>
			<p class="source-code">        score_df.at[0,col] = request.args.get(col)</p>
			<p>Here are the <a id="_idIndexMarker577"/>key parts of this snippet:</p>
			<ul>
				<li><strong class="source-inline">@app.route('/show-prediction/')</strong> – Specifies that this view function is applied for the <strong class="source-inline">show-prediction.html</strong> web page.</li>
				<li><strong class="source-inline">score_df = pd.DataFrame(columns=scoring_columns)</strong> – Creates an empty dataframe to hold the scoring parameters.</li>
				<li><strong class="source-inline">score_df.at[0,col] = request.args.get(col)</strong> – This statement is run for every column in the <strong class="source-inline">scoring_columns</strong> list. It copies the values in the query string that was built in the <strong class="source-inline">getOption()</strong> JavaScript function and passed as part of the reference to <strong class="source-inline">show-prediction.html</strong> to the corresponding column in the first row of the <strong class="source-inline">score_df</strong> dataframe. This is how the scoring parameter values that the user entered in <strong class="source-inline">home.html</strong> are brought into the Python Flask server module.</li>
			</ul>
			<p>Now that the scoring parameters have been loaded into the first row of the <strong class="source-inline">score_df</strong> dataframe, we can invoke the model on the first row of the dataframe, as shown in the following code snippet from the view function for <strong class="source-inline">show-prediction.html</strong>: </p>
			<p class="source-code">pred_class,pred_idx,outputs = learner.predict(score_df.iloc[0])</p>
			<p class="source-code">if outputs[0] &gt;= outputs[1]:</p>
			<p class="source-code">        predict_string = "Prediction is: individual has income less than 50k"</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        predict_string = "Prediction is: individual has income greater than 50k"</p>
			<p class="source-code">    prediction = {'prediction_key':predict_string}</p>
			<p class="source-code">    return(render_template('show-prediction.html',prediction=prediction))</p>
			<p>Here are the <a id="_idIndexMarker578"/>key parts of this snippet:</p>
			<ul>
				<li><strong class="source-inline">pred_class,pred_idx,outputs = learner.predict(score_df.iloc[0])</strong> – Invokes the model with the first row of the <strong class="source-inline">score_df</strong> DataFrame as input. The call has three outputs:<p>a) <strong class="source-inline">pred_class</strong> lists the scoring parameters as they were fed into the model. For the categorical columns, the original scoring parameter value is replaced with the category identifier. For example, the value <strong class="source-inline">United States</strong> in the <strong class="source-inline">native-country</strong> column is replaced with <strong class="source-inline">40.0</strong>. These transformations are exactly the same as the transformations that were done on the training data back when you trained the model in <a href="B16216_03_Final_VK_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a><em class="italic">, Training Models with Tabular Data</em>. Thanks to the way that fastai manages these transformations, unlike Keras, you don't need to worry about maintaining a pipeline object and applying it when you deploy a model – fastai just takes care of it. This is a great advantage of fastai.</p><p>b) <strong class="source-inline">pred_idx</strong> – The index of the prediction. For this model, the prediction will be either 0 (indicating the individual has an income less than 50,000) or 1 (indicating the individual has an income more than 50,000).</p><p>c) <strong class="source-inline">outputs</strong> – Shows the probability of each prediction value.</p><p><em class="italic">Figure 7.8</em> shows an example of prediction output and how it corresponds to the <strong class="source-inline">pred_class</strong>, <strong class="source-inline">pred_idx</strong>, and <strong class="source-inline">outputs</strong> variables:</p></li>
			</ul>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B16216_7_8.jpg" alt="Figure 7.8 – Example of model prediction output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Example of model prediction output</p>
			<ul>
				<li><strong class="source-inline">return(render_template('show-prediction.html',prediction=prediction))</strong> – Specifies that <strong class="source-inline">show-prediction.html</strong> is displayed with the argument value set in this view function.</li>
			</ul>
			<p>With this <a id="_idIndexMarker579"/>statement, the action moves back to HTML as <strong class="source-inline">show-prediction.html</strong> is loaded in the browser. The following snippet shows the HTML that displays the prediction text:</p>
			<p class="source-code">&lt;div class="home"&gt;</p>
			<p class="source-code">  &lt;h1 style="color: green"&gt; </p>
			<p class="source-code">    Here is the prediction for the individual's income:</p>
			<p class="source-code">  &lt;/h1&gt; </p>
			<p class="source-code">  &lt;h1 style="color: green"&gt; </p>
			<p class="source-code">    {{ prediction.prediction_key }}</p>
			<p class="source-code">  &lt;/h1&gt;</p>
			<p>The <strong class="source-inline">{{ prediction.prediction_key }}</strong> value corresponds to the <strong class="source-inline">predict_string</strong> value that was set in the view function for <strong class="source-inline">show-prediction</strong> in the Flask server. The result is that the prediction that the model made on the scoring parameters is displayed, as shown in <em class="italic">Figure 7.9</em>:</p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B16216_7_9.jpg" alt="Figure 7.9 – The end result of the deployed model – a prediction on the scoring parameters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – The end result of the deployed model – a prediction on the scoring parameters</p>
			<p>Now you have <a id="_idIndexMarker580"/>seen all the major code items that make up the entire flow of this web deployment of a fastai model. The flow goes through the following steps:</p>
			<ol>
				<li value="1">The flow begins when you start the Flask server. Once you have started the Flask server, it is ready to serve <strong class="source-inline">home.html</strong> at <strong class="source-inline">localhost:5000</strong>.</li>
				<li>When you go to <strong class="source-inline">localhost:5000</strong> in your browser, the view function for <strong class="source-inline">home.html</strong> runs in the Flask server and <strong class="source-inline">home.html</strong> is displayed in the browser.</li>
				<li>The flow then goes to HTML/JavaScript in <strong class="source-inline">home.html</strong>, where the user selects the scoring parameters and selects the <strong class="bold">Get prediction</strong> button.</li>
				<li>The flow then returns to the Flask server where the view function for <strong class="source-inline">show-prediction.html</strong> is run to get a prediction from the model on the scoring parameters and to display <strong class="source-inline">show-prediction.html</strong> in the browser.</li>
				<li>Finally, the flow returns back to HTML in <strong class="source-inline">show-prediction.html</strong>, where the model's prediction is displayed. </li>
				<li>At this point, the user can select the <strong class="bold">Get another prediction</strong> button in <strong class="source-inline">show-prediction.html</strong> to start the process over again at <em class="italic">Step 2</em> with a different set of scoring parameters.</li>
			</ol>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor190"/>There's more…</h2>
			<p>The tour through the web deployment example in this recipe only scratches the surface of what you can <a id="_idIndexMarker581"/>do with Flask, and it covers only the bare minimum of what you can do with modern HTML and JavaScript. A thorough exploration of how to develop web applications with Python is beyond the scope of this book, but if you are interested in learning more, you can check out the following resources:</p>
			<ul>
				<li><em class="italic">Deploying a Deep Learning Model using Flask</em> (<a href="https://towardsdatascience.com/deploying-a-deep-learning-model-using-flask-3ec166ef59fb">https://towardsdatascience.com/deploying-a-deep-learning-model-using-flask-3ec166ef59fb</a>) goes into additional details about how to use Flask to deploy deep learning models. This article is focused on deploying Keras models rather than fastai models, but the principles described in the article apply to both frameworks.</li>
				<li><em class="italic">Responsive Web Design with HTML5 and CSS</em> (<a href="https://www.amazon.com/Responsive-Web-Design-HTML5-CSS/dp/1839211563/ref=sr_1_2?dchild=1&amp;keywords=html5+packt&amp;qid=1623055650&amp;sr=8-2">https://www.amazon.com/Responsive-Web-Design-HTML5-CSS/dp/1839211563/ref=sr_1_2?dchild=1&amp;keywords=html5+packt&amp;qid=1623 055650&amp;sr=8-2</a>) gives a broad background on modern HTML and also covers <strong class="bold">cascading style sheets</strong> (<strong class="bold">CSS</strong>), which <a id="_idIndexMarker582"/>are used to control how web pages are rendered.</li>
				<li><em class="italic">Clean Code in JavaScript</em> (<a href="https://www.amazon.com/Clean-Code-JavaScript-reliable-maintainable/dp/1789957648/ref=sr_1_6?dchild=1&amp;keywords=Javascript+Packt&amp;qid=1623055616&amp;sr=8-6">https://www.amazon.com/Clean-Code-JavaScript-reliable-maintainable/dp/1789957648/ref=sr_1_6?dchild=1&amp;keywords=Javascript+Packt&amp;qid =1623055616&amp;sr=8-6</a>) describes good programming practices for JavaScript. If you are reading this book, you are reasonably comfortable with Python, and you should not have much trouble picking up JavaScript. JavaScript doesn't always get the respect it deserves from people who program in more illustrious languages such as C++ and Scala, but the fact is that JavaScript is remarkably flexible and really useful to know.</li>
			</ul>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor191"/>Deploying a fastai model trained on an image dataset </h1>
			<p>In the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe, we went through the <a id="_idIndexMarker583"/>process of deploying a model trained on a tabular dataset. We deployed a model that predicted whether an individual would have an income over 50,000 based on a set of characteristics called <strong class="bold">scoring parameters</strong>, including education, job category, and hours worked per week. To do this deployment, we needed a way to allow the user to select values for the scoring parameters and then show the prediction made by the trained fastai model on these scoring parameters. </p>
			<p>In this recipe, we will deploy the image classification model that you trained in the <em class="italic">Training a classification model with a standalone vision dataset</em> recipe of <a href="B16216_06_Final_VK_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 6</em></a><em class="italic">, Training Models with Visual Data</em>. This model predicts what fruit or vegetable is depicted in an image. Unlike the deployment of the tabular dataset model, to deploy the image dataset model we will need to be able to specify an image file on which to make a prediction.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For the sake of simplicity, this deployment uses web pages with the same names (<strong class="source-inline">home.html</strong> and <strong class="source-inline">show-prediction.html</strong>) as the deployment of a tabular dataset that we did in the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe. However, these web pages are customized for the image model deployment.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor192"/>Getting ready</h2>
			<p>Ensure that you have followed the steps in the <em class="italic">Setting up fastai on your local system</em> recipe to get fastai installed on your local system. Confirm that you can access the files in the <strong class="source-inline">deploy_image</strong> directory of the <strong class="source-inline">ch7</strong> directory of your repo.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor193"/>How to do it…</h2>
			<p>To exercise the deployment of an image classification model on your local system, you will start the Flask server, open up the <strong class="source-inline">home.html</strong> page for this deployment in your browser, select an image file to get a prediction on, and then validate that you get a prediction for the image displayed in the <strong class="source-inline">show-prediction.html</strong> page for this deployment. </p>
			<p>Complete the <a id="_idIndexMarker584"/>following steps to exercise the deployment of a fastai model trained on an image dataset: </p>
			<ol>
				<li value="1">From a command window/terminal on your local system, make <strong class="source-inline">deploy_image</strong> in the <strong class="source-inline">ch7</strong> directory of your repo your current directory.</li>
				<li>Enter the following command in the command line/terminal to start the Flask server:<p class="source-code"><strong class="bold">python web_flask_deploy_image_model.py</strong></p><p>This output of this command indicates that the web server is running <strong class="source-inline">localhost:5000</strong>, as shown in <em class="italic">Figure 7.10</em>:</p><div id="_idContainer241" class="IMG---Figure"><img src="image/B16216_7_10.jpg" alt="Figure 7.10 – Output when the Flask server starts&#13;&#10;"/></div><p class="figure-caption">Figure 7.10 – Output when the Flask server starts</p></li>
				<li>Open a browser window and enter the following in the address field:<p class="source-code"><strong class="bold">localhost:5000</strong></p><p>If the Flask server started successfully, the web page <strong class="source-inline">home.html</strong> will be loaded in the browser, as shown in <em class="italic">Figure 7.11</em>:</p><div id="_idContainer242" class="IMG---Figure"><img src="image/B16216_7_11.jpg" alt="Figure 7.11 – home.html for the image model deployment being served by the Flask server&#13;&#10;"/></div><p class="figure-caption">Figure 7.11 – home.html for the image model deployment being served by the Flask server</p></li>
				<li>Now select <strong class="bold">Choose File</strong>. A file <a id="_idIndexMarker585"/>dialog opens. In this dialog, navigate to the <strong class="source-inline">test_images</strong> subdirectory in your <strong class="source-inline">deploy_images</strong> directory. Select the lemon image file, <strong class="source-inline">5_100.jpg</strong>, and close the file dialog, for example, by selecting <strong class="bold">Open</strong> in Windows.</li>
				<li>When the file dialog closes, the name of the file you selected shows in <strong class="source-inline">home.html</strong> beside the <strong class="bold">Choose File</strong> button, as shown in <em class="italic">Figure</em> <em class="italic">7.12</em>:<div id="_idContainer243" class="IMG---Figure"><img src="image/B16216_7_12.jpg" alt="Figure 7.12 – The name of the file you selected displayed in home.html&#13;&#10;"/></div><p class="figure-caption">Figure 7.12 – The name of the file you selected displayed in home.html</p></li>
				<li>Now select <strong class="bold">Get prediction</strong>. The <strong class="source-inline">show-prediction.html</strong> page is displayed with the model's prediction for what is displayed in the image you selected in <strong class="source-inline">home.html</strong>, as shown in <em class="italic">Figure</em> <em class="italic">7.13</em>:</li>
			</ol>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/B16216_7_13.jpg" alt="Figure 7.13 – The model's prediction of what is in the image, shown in show-prediction.html&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – The model's prediction of what is in the image, shown in show-prediction.html</p>
			<p>Congratulations! You <a id="_idIndexMarker586"/>have successfully set up a Flask server and exercised the web deployment of a fastai model that predicts the object depicted in an image.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor194"/>How it works…</h2>
			<p>Now that you have worked through the web deployment of a fastai image classification model, let's go through what's happening behind the scenes. We'll start by going through an overview of the deployment and then digging into the code differences between the deployment of the image classification model and the deployment of a tabular dataset model as described in the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe. </p>
			<h3>Overview of how the web deployment of the fastai image classification model works</h3>
			<p>Let's review the <a id="_idIndexMarker587"/>end-to-end flow of the deployment, as shown in <em class="italic">Figure 7.14</em>:</p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B16216_7_14.jpg" alt="Figure 7.14 – Overview of web deployment of a fastai image classification model using Flask&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">    </p>
			<p class="figure-caption">Figure 7.14 – Overview of web deployment of a fastai image classification model using Flask</p>
			<p>Here are the <a id="_idIndexMarker588"/>key items highlighted by the numbers in <em class="italic">Figure 7.14</em>:</p>
			<ol>
				<li value="1"><strong class="source-inline">home.html</strong> – This is the web page where the user specifies the image file that they want the model to make a prediction on. The version of <strong class="source-inline">home.html</strong> used for the image classification model deployment incorporates HTML and JavaScript functions that display a file selection dialog, package up the name of the selected file, and call <strong class="source-inline">show-prediction.html</strong> with the name of the selected image file as an argument.</li>
				<li>The Flask <strong class="source-inline">web_flask_deploy_image_model.py</strong> module – The Python module that uses the Flask library to serve the web pages that make up the web deployment. This module includes view functions for <strong class="source-inline">home.html</strong> and <strong class="source-inline">show-prediction.html</strong>. The view function for <strong class="source-inline">show-prediction.html</strong> ingests the name of the image file selected in <strong class="source-inline">home.html</strong>, calls the trained model using this filename to get a prediction, generates a string from the model's prediction, and finally triggers <strong class="source-inline">show-prediction.html</strong> to be displayed with the prediction string.</li>
				<li>The fastai <strong class="source-inline">fruits_360may3.pkl</strong> image classification model – This is the model that you trained and saved in the <em class="italic">Training a classification model with a standalone vision dataset</em> recipe of <a href="B16216_06_Final_VK_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 6</em></a><em class="italic">, Training Models with Visual Data</em>. The view function for <strong class="source-inline">show-prediction.html</strong> in the <strong class="source-inline">web_flask_deploy_image_model.py</strong> Flask module loads this model and then uses it to make a prediction for the image file selected in <strong class="source-inline">home.html</strong>.</li>
				<li><strong class="source-inline">show-prediction.html</strong> – This web page displays the prediction made by the model on the image file selected in <strong class="source-inline">home.html</strong>. On this page, the user can optionally select the <strong class="bold">Get another prediction</strong> button to go back to <strong class="source-inline">home.html</strong> to select another image file to make a prediction on.</li>
			</ol>
			<p>That is a high-level <a id="_idIndexMarker589"/>summary of how the web deployment of the image classification model works. </p>
			<h3>Digging deeper into the code behind the web deployment of the image classification model</h3>
			<p>Now that we <a id="_idIndexMarker590"/>have reviewed the overall flow of the deployment of the image classification model, let's take a look at some of the key differences between the deployment of a tabular model that we covered in the <em class="italic">Deploying a fastai model trained on a tabular dataset </em>recipe and the deployment of an image classification model that we worked through in this section. Here are the key differences:</p>
			<ul>
				<li>HTML in <strong class="source-inline">home.html</strong> – The version of <strong class="source-inline">home.html</strong> for the deployment of the tabular dataset model required a large number of controls to allow the user to specify all the required scoring parameters. The user needed to be able to specify values for all the features that were used to train the model. For the deployment of the image classification model, there is only one feature – the image file – so we only need a control for selecting a file. Here is the HTML for the file selection control:<p class="source-code">  &lt;label for="image_field"&gt;Please choose an image:&lt;/label&gt;</p><p class="source-code">  &lt;input type="file"</p><p class="source-code">       id="image_field" name="image_field"</p><p class="source-code">       accept="image/png, image/jpeg"&gt;  </p><p>Here are the key items in this piece of HTML:</p><p>a) <strong class="source-inline">input type="file"</strong> – Specifies that this control is for inputting files from the local filesystem.</p><p>b) <strong class="source-inline">accept="image/png, image/jpeg"</strong> – Specifies that the file dialog that is opened from this control will only allow image files with <strong class="source-inline">image/png</strong> or <strong class="source-inline">image/jpeg</strong> content types to be selected.</p></li>
				<li>JavaScript in <strong class="source-inline">home.html</strong> – The version of <strong class="source-inline">home.html</strong> for the deployment of the tabular <a id="_idIndexMarker591"/>dataset model has three JavaScript functions: <p>a) <strong class="source-inline">getOption()</strong>, to get the values from the controls </p><p>b) <strong class="source-inline">link_with_args()</strong>, to call <strong class="source-inline">getOption()</strong> and send the query string to the view function for <strong class="source-inline">show-prediction.html</strong> </p><p>c) <strong class="source-inline">load_selections()</strong>, to initialize the controls</p><p>The version of <strong class="source-inline">home.html</strong> used for the image classification model deployment doesn't need <strong class="source-inline">load_selections()</strong> (because there aren't any controls that need to initialized) and its version of <strong class="source-inline">link_with_args()</strong> is identical to the tabular model deployment version. That leaves the <strong class="source-inline">getOption()</strong> function, which is significantly different from the version in the tabular model deployment. Here is the image classification deployment version of <strong class="source-inline">getOption()</strong>:</p><p class="source-code">function getOption() { </p><p class="source-code">      var file_value = [];</p><p class="source-code">      const input = document.querySelector('input');</p><p class="source-code">      const curFiles = input.files;</p><p class="source-code">      if(curFiles.length === 0) {</p><p class="source-code">        console.log("file list empty");</p><p class="source-code"> </p><p class="source-code">      } else {</p><p class="source-code">      for(const file of curFiles) {</p><p class="source-code">        file_value.push(file.name);</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">      prefix = "/show-prediction/?"</p><p class="source-code">      window.output = prefix.concat("file_name=",file_value[0])</p><p class="source-code">    }</p><p>Here are the <a id="_idIndexMarker592"/>key items in the definition of <strong class="source-inline">getOption()</strong>:</p><p>a) <strong class="source-inline">const input = document.querySelector('input');</strong> – Associates <strong class="source-inline">input</strong> with the file selector.</p><p>b) <strong class="source-inline">const curFiles = input.files;</strong> – Assigns the list of files associated with the file selector to <strong class="source-inline">curFiles</strong>. </p><p>c) <strong class="source-inline">for(const file of curFiles) { file_value.push(file.name);}</strong> – Loops through the files in the file list associated with the file selector and adds each filename to the <strong class="source-inline">file_value</strong> list. </p><p>d) <strong class="source-inline">window.output = prefix.concat("file_name=",file_value[0])</strong> – Builds the query string using the first element from the <strong class="source-inline">file_value</strong> list of filenames. We will only make predictions on one file at a time, so we just need one filename for the query string. The resulting query string would look something like this: <strong class="source-inline">/show-prediction/?file_name=5_100.jpg</strong>.</p></li>
				<li>View function for <strong class="source-inline">show-prediction.html</strong> in the Flask server – The following code <a id="_idIndexMarker593"/>snippet shows what this view function looks like for the image classification web deployment:<p class="source-code">@app.route('/show-prediction/')</p><p class="source-code">def show_prediction():</p><p class="source-code">    image_file_name = request.args.get("file_name")</p><p class="source-code">    full_path = os.path.join(path,image_directory,image_file_name)</p><p class="source-code">    img = PILImage.create(full_path)</p><p class="source-code">    pred_class, ti1, ti2 = learner.predict(img)</p><p class="source-code">    predict_string = "Predicted object is: "+pred_class</p><p class="source-code">    prediction = {'prediction_key':predict_string}</p><p class="source-code">    return(render_template('show-prediction.html',prediction=prediction))</p><p>Here are the key items in the definition of this view function:</p><p>a) <strong class="source-inline">image_file_name = request.args.get("file_name")</strong> – Sets the value of <strong class="source-inline">image_file_name</strong> to be the filename from the query string.</p><p>b) <strong class="source-inline">full_path = os.path.join(path,image_directory,image_file_name)</strong> – Sets the value of <strong class="source-inline">full_path</strong> to be the fully qualified filename for the image file selected in <strong class="source-inline">home.html</strong>. This assumes that the file was selected from the <strong class="source-inline">test_images</strong> subdirectory of the directory where you are running the Flask server.</p><p>c) <strong class="source-inline">img = PILImage.create(full_path)</strong> – Creates an image object called <strong class="source-inline">img</strong> for the image file selected in <strong class="source-inline">home.html</strong>.</p><p>d) <strong class="source-inline">pred_class, ti1, ti2 = learner.predict(img)</strong> – Gets a prediction from the image classification model for the <strong class="source-inline">img</strong> object. <strong class="source-inline">pred_class</strong> contains <a id="_idIndexMarker594"/>the category (such as <em class="italic">Apple</em> or <em class="italic">Pear</em>) predicted by the model for the image file.</p><p>e) <strong class="source-inline">return(render_template('show-prediction.html',prediction=prediction))</strong> – Specifies that <strong class="source-inline">show-prediction.html</strong> is displayed with the argument value set in this view function.</p></li>
			</ul>
			<p>Now you have seen all the major code differences between the deployment of the tabular dataset model and the deployment of the image classification model.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor195"/>There's more…</h2>
			<p>In this chapter, you <a id="_idIndexMarker595"/>have seen two examples of deploying fastai models using a Flask-based web application. This isn't the only approach that you can take to deploy models. Other approaches include deploying models via REST API endpoints (so that other applications can invoke the models directly) or encapsulating models along with their dependencies in other applications. Models can be packaged with the dependencies (such as required Python libraries) in Docker containers, and then these containers can be made available to other applications through orchestration systems such as Kubernetes. </p>
			<p>Rather than dwelling on these general deployment concepts, it may be more useful to review some concrete approaches to deploying fastai models in particular. Here is a sample of approaches to deploying fastai models:</p>
			<ul>
				<li>Deploying with Amazon SageMaker, the AWS machine learning environment, as described here: <a href="https://aws.amazon.com/blogs/machine-learning/building-training-and-deploying-fastai-models-with-amazon-sagemaker/">https://aws.amazon.com/blogs/machine-learning/building-training-and-deploying-fastai-models-with-amazon-sagemaker/</a>. This approach requires using some PyTorch code directly and may not have been validated on the latest version of fastai.</li>
				<li>Deploying in AWS using TorchServe, as described here: <a href="https://aws.amazon.com/blogs/opensource/deploy-fast-ai-trained-pytorch-model-in-torchserve-and-host-in-amazon-sagemaker-inference-endpoint/">https://aws.amazon.com/blogs/opensource/deploy-fast-ai-trained-pytorch-model-in-torchserve-and-host-in-amazon-sagemaker-inference-endpoint/</a>. This <a id="_idIndexMarker596"/>approach has fewer <em class="italic">moving parts</em> than the approach described in the previous point, and it is more current, but the essence of the approach seems to be re-implementing the fastai model in PyTorch.</li>
				<li>Deploying using Google Cloud Platform, as described here: <a href="https://jianjye.medium.com/how-to-deploy-fast-ai-models-to-google-cloud-functions-for-predictions-e3d73d71546b">https://jianjye.medium.com/how-to-deploy-fast-ai-models-to-google-cloud-functions-for-predictions-e3d73d71546b</a>.</li>
				<li>Deploying using Azure, as described here: <a href="https://forums.fast.ai/t/platform-azure/65527/7">https://forums.fast.ai/t/platform-azure/65527/7</a>.</li>
			</ul>
			<p>This list is not exhaustive but it does demonstrate the variety of deployment options available for fastai models.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor196"/>Maintaining your fastai model</h1>
			<p>Deploying a model is <a id="_idIndexMarker597"/>not the end of the story. Once you have deployed a model, you need to maintain the deployment so that it matches the current characteristics of the data on which the model is trained. A thorough description of how to maintain a deep learning model in production is beyond the scope of this book, but it is worthwhile to touch on how to maintain models in the context of the simple model deployments described in this chapter. In this recipe, we will look at actions you could take to maintain the tabular model that you deployed in the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor197"/>Getting ready</h2>
			<p>Ensure that you have followed the steps in the <em class="italic">Setting up fastai on your local system</em> recipe to get fastai installed on your local system. Also ensure that you have the Flask server started for the tabular model deployment by following <em class="italic">Steps 1, 2, and 3</em> from the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe.</p>
			<p>In this recipe, you will be doing some basic analysis of the training data that you used to train the tabular model deployed in the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe. To prepare for this analysis, confirm that you can use your spreadsheet of choice (such as Excel or Google Sheets) to open up <strong class="source-inline">adult.csv</strong>, the file in the <strong class="source-inline">ADULT_SAMPLE</strong> dataset that contains the training data. If you don't already have <strong class="source-inline">adult.csv</strong> on your local system, follow these steps to get this file on your local system and confirm you can open it up with your spreadsheet application:</p>
			<ol>
				<li value="1">In your <a id="_idIndexMarker598"/>Gradient environment, enter the following command in a terminal window to copy <strong class="source-inline">adult.csv</strong> to your <strong class="source-inline">temp</strong> directory:<p class="source-code"><strong class="bold">cp /storage/data/adult_sample/adult.csv /notebooks/temp/adult.csv</strong></p></li>
				<li>In JupyterLab in your Gradient environment, navigate to the <strong class="source-inline">temp</strong> directory where you copied <strong class="source-inline">adult.csv</strong> in the previous step, right-click on <strong class="source-inline">adult.csv</strong>, and select <strong class="bold">Download</strong>.</li>
				<li>Use your spreadsheet application to open up the local copy of <strong class="source-inline">adult.csv</strong> that you downloaded in the previous step. <em class="italic">Figure 7.15</em> shows what the first few rows of <strong class="source-inline">adult.csv</strong> look like in Excel:</li>
			</ol>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B16216_7_15.jpg" alt="Figure 7.15 – The first few rows of adult.csv in Excel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – The first few rows of adult.csv in Excel</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may wonder why I am suggesting using a spreadsheet to examine the data in this recipe. Why not use Python? There are a couple of reasons I recommend a spreadsheet here. First, no less an authority than Jeremy Howard stated that Excel is a great data science tool, and I happen to think he is absolutely right. It's flexible, lightweight, and faster than Python for the kind of simple investigation on a small dataset that I'm featuring in this recipe. Second, Excel helped me to debug a problem with the deployment of the tabular model. When I first tested the deployment, I struggled to understand why the deployed model produced different predictions than the model invoked in a Python notebook. However, once I examined the data in Excel, the problem was obvious: all categorical values began with spaces in the data used for training the model. The categorical values that users could select in the deployment didn't start with spaces, so the model did not recognize them as being the same as the categorical values it had encountered at training time. Excel gave me a quick way to detect the root cause of the problem.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor198"/>How to do it…</h2>
			<p>To exercise some <a id="_idIndexMarker599"/>model maintenance actions, complete the following steps:</p>
			<ol>
				<li value="1">First, take a closer look at how categorical values are represented in <strong class="source-inline">ADULT_SAMPLE</strong>. If you don't already have your local copy of <strong class="source-inline">adult.csv</strong> open in your spreadsheet application, open it up now. Select one of the values in the <strong class="source-inline">workclass</strong> column. Do you notice anything unusual about the value? Check out the values in some of the other categorical columns: <strong class="source-inline">relationship</strong> and <strong class="source-inline">native-country</strong>. You will see that the values in every categorical column begin with a blank.</li>
				<li>Recall that in <strong class="source-inline">home.html</strong>, the user is constrained in the choices they can make for each of the categorical features. Open up <strong class="source-inline">home.html</strong> in the tabular model deployment and see what values are available for <strong class="source-inline">workclass</strong>. <em class="italic">Figure 7.16</em> shows the values that the user can select for <strong class="source-inline">workclass</strong>:<div id="_idContainer247" class="IMG---Figure"><img src="image/B16216_7_16.jpg" alt="Figure 7.16 – Values available for workclass in home.html&#13;&#10;"/></div><p class="figure-caption">Figure 7.16 – Values available for workclass in home.html</p></li>
				<li>The values that <a id="_idIndexMarker600"/>users can choose in <strong class="source-inline">home.html</strong> for the categorical columns are defined in a series of lists in the <strong class="source-inline">load_selections()</strong> JavaScript function. Here are the lists defined in the <strong class="source-inline">load_selections()</strong> JavaScript function for <strong class="source-inline">workclass</strong>, <strong class="source-inline">relationship</strong>, and <strong class="source-inline">native-country</strong>:<p class="source-code">var workclass_list = [" Private" ," Self-emp-inc" ," Self-emp-not-inc" ," State-gov" ," Federal-gov" ," Local-gov" ];</p><p class="source-code">var relationship_list = [" Wife" ," Not-in-family" ," Unmarried" ," Husband" ," Own-child" ," Other-relative" ];</p><p class="source-code">var native_country_list = [" United-States"," Puerto-Rico"," Mexico"," Canada"," Taiwan"," Vietnam"," Philippines"];</p><p>Notice how the values in each of these lists begin with a blank, just like the values in the corresponding categorical columns in <strong class="source-inline">adult.csv</strong>. The values in these lists are used to build the query string, which in turn gets used as input to get a prediction from the model in the view function for <strong class="source-inline">show-prediction.html</strong>. What would have happened if the values in the lists in <strong class="source-inline">home.html</strong> had been defined without leading blanks?</p></li>
				<li>Suppose that the training data for the model gets expanded to include individuals who come from the <strong class="bold">United Kingdom</strong>, and you received an updated version of <strong class="source-inline">adult.csv</strong> that includes rows with the value <strong class="source-inline">United-Kingdom</strong> in the <strong class="source-inline">native-country</strong> column. Here is what you would need to do to update the deployment to adapt to this change:<p>a) Retrain the <a id="_idIndexMarker601"/>model with the new version of <strong class="source-inline">adult.csv</strong> and save the new trained model to a <strong class="source-inline">pkl</strong> file using the <strong class="source-inline">learner.export()</strong> fastai API. For the purposes of this recipe, suppose that you call the new <strong class="source-inline">adult_sample_model_new.pkl</strong> model.</p><p>b) Copy the updated <strong class="source-inline">adult_sample_model_new.pkl</strong> model file into the <strong class="source-inline">deploy_tabular</strong> directory on your local system.</p><p>c) Update the definition of the model path in the <strong class="source-inline">web_flask_deploy.py</strong> Flask server module to include the new model filename:</p><p class="source-code">full_path = os.path.join(path, 'adult_sample_model_new.pkl')</p><p>d) Update <strong class="source-inline">native_country_list</strong> in <strong class="source-inline">home.html</strong> to include the new value:</p><p class="source-code">var native_country_list = [" United-States"," Puerto-Rico"," Mexico"," Canada"," Taiwan"," Vietnam"," Philippines", "  United-Kingdom"  ];</p><p>You would need to take the same steps to update the deployment for new values in any of the categorical columns: retrain the model with the updated training dataset, copy the updated trained model to the deployment directory, update the Flask server so that it loads the updated model, and update the list of valid categorical values in <strong class="source-inline">home.html</strong>. </p></li>
				<li>In the previous step, we saw what we will need to do if the dataset gets expanded with new categorical values. What if a brand-new column is added to the dataset? Just like the process described in <em class="italic">Step 4</em>, you would need to retrain the model on the updated training dataset that includes the new column, copy the new model into the <strong class="source-inline">deploy_tabular</strong> directory, and update <strong class="source-inline">web_flask_deploy.py</strong> so that it loads the new model. Finally, you would need to update <strong class="source-inline">home.html</strong> to allow the user to enter information about the new column. The updates you need to make depend on whether the new column is <strong class="bold">continuous</strong>, that is, contains numeric values, or <strong class="bold">categorical</strong>, that is, contains a fixed set of values. The following two steps describe the specific updates you would need to make to <strong class="source-inline">home.html</strong> in each case.</li>
				<li>Suppose you <a id="_idIndexMarker602"/>need to update the deployment to handle a new continuous column called <strong class="source-inline">years-in-job</strong> – a count of how many years the individual has been in their current job. The valid values are 0 to 45, and the default value is 5. To add this column, you need to make several updates to <strong class="source-inline">home.html</strong>. First, you need to add the following code to define a control for this new column:<p class="source-code">&lt;p&gt; </p><p class="source-code">  &lt;label for="years-in-job"&gt;years in job (0 - 45):&lt;/label&gt;</p><p class="source-code">  &lt;input type="number" id="years-in-job" name="years-in-job"  min="0" max="45"&gt;</p><p class="source-code">  &lt;/p&gt;</p><p>Next, you need to add the following line to the <strong class="source-inline">load_selection()</strong> JavaScript function to set the default value:</p><p class="source-code">document.getElementById("years-in-job").defaultValue = 5;</p><p>Next, you need to add the following line to the <strong class="source-inline">getOption()</strong> JavaScript function to set the value that will be included in the query string for this column:</p><p class="source-code">years_in_job_value = document.getElementById("years-in-job ").value;</p><p>Finally, you need to add the following to the end of the query string used to define <strong class="source-inline">window.output</strong>:</p><p class="source-code">,"&amp;years-in-job=",years_in_job_value</p></li>
				<li>Suppose <a id="_idIndexMarker603"/>you need to update the deployment to handle a new categorical column called <strong class="source-inline">work-location</strong> that specifies the location of the individual's current job. Valid values for this column are <strong class="source-inline">remote</strong>, <strong class="source-inline">on-site</strong>, and <strong class="source-inline">mixed</strong>. To adapt <strong class="source-inline">home.html</strong> to work with this new column, start by adding the following code to define a control for the <strong class="source-inline">work-location</strong> column:<p class="source-code">  &lt;p&gt;</p><p class="source-code">    Select work location:</p><p class="source-code">    &lt;select id="work-location"&gt;</p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">  &lt;/p&gt;</p><p>Next, add the following lines to the <strong class="source-inline">load_selection()</strong> JavaScript function to set the values for the control for the new column. Note that we assume that like the other categorical columns, values in <strong class="source-inline">work-location</strong> will be preceded by a blank, so the values in <strong class="source-inline">work_location_list</strong> all begin with blanks:</p><p class="source-code">var select_work_location = document.getElementById("work-location");</p><p class="source-code">var work_location_list = [" remote"," on-site"," mixed"];</p><p class="source-code">for(var i = 0; i &lt; work_location_list.length; i++) {</p><p class="source-code">      var opt = work_location_list[i];</p><p class="source-code">      select_work_location.innerHTML += "&lt;option value=\"" + opt + "\"&gt;" + opt + "&lt;/option&gt;";</p><p class="source-code">    }</p><p>Next, add the <a id="_idIndexMarker604"/>following lines to the <strong class="source-inline">getOption()</strong> JavaScript function to set the value that will be included in the query string for this column:</p><p class="source-code">selectElementworklocation = \</p><p class="source-code">document.querySelector('#work-location'); </p><p class="source-code">work_location_string =\</p><p class="source-code">selectElementworklocation.options[selectElementworklocation.selectedIndex].value</p><p>Finally, add the following to the end of the query string used to define <strong class="source-inline">window.output</strong>:</p><p class="source-code">,"&amp;work-location=",work_location_string</p></li>
			</ol>
			<p>Congratulations! You have worked through some of the actions required to maintain the deployment of a model to ensure it can adapt to changes in the training dataset.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor199"/>How it works…</h2>
			<p>In this recipe, we reviewed how you could maintain the web deployment of a model trained on tabular data. We saw the steps we would take to adapt the deployment to work with changes in the training dataset. The dataset changes we covered were new values in existing categorical columns, new continuous columns, and new categorical columns. </p>
			<p>In an industrial-strength production deployment, the schema of the dataset, that is, the characteristics of all the columns that make up the dataset, would be maintained outside of the HTML files. For example, we might maintain the schema in a separate configuration file that had information about the columns in the dataset. Instead of being hardcoded, the controls and valid values in <strong class="source-inline">home.html</strong> would be built on the fly using the contents of the configuration file. </p>
			<p>With this kind of dynamic setup, when a new column is added to the dataset or the valid values for a column change, we will only have to update the definition of the dataset schema in the configuration file and <strong class="source-inline">home.html</strong> would be updated automatically. To keep the web deployment as easy to follow as possible, we code the controls and valid values directly in <strong class="source-inline">home.html</strong> instead of building them dynamically. This made the <em class="italic">Deploying a fastai model trained on a tabular dataset</em> recipe easier to follow, but it also meant there were several places in <strong class="source-inline">home.html</strong> that had to be updated to maintain the deployment when the dataset changed. </p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor200"/>There's more…</h2>
			<p>In this recipe, we <a id="_idIndexMarker605"/>talked about how to handle changes to the dataset schema, but we didn't talk about how to deal with changes in the distribution of the dataset or how to monitor the model to ensure that it maintained its performance over time. Both of these issues are critical to maintaining a deployed model but they are beyond the scope of this book. </p>
			<p>If you are interested in learning more about monitoring the performance of models in production, this article provides a great overview: <a href="https://christophergs.com/machine%20learning/2020/03/14/how-to-monitor-machine-learning-models/">https://christophergs.com/machine%20learning/2020/03/14/how-to-monitor-machine-learning-models/</a>.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor201"/>Test your knowledge</h1>
			<p>Now that you have <a id="_idIndexMarker606"/>deployed two kinds of fastai models and worked through some of the challenges related to maintaining deployed models, you can try some additional variations on deployment to exercise what you've learned. </p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor202"/>Getting ready</h2>
			<p>Ensure that you have followed the steps in the <em class="italic">Setting up fastai on your local system</em> recipe to get fastai installed on your local system. Also, ensure that you have the Flask server started for the image classification model deployment by following <em class="italic">Steps 1, 2, </em>and <em class="italic">3</em> in the <em class="italic">Deploying a fastai model trained on an image dataset</em> recipe.</p>
			<p>To experiment on the image classification model deployment, make a copy of the <strong class="source-inline">deploy_image</strong> directory. To do this, make the directory that contains <strong class="source-inline">deploy_image</strong> your current directory and run the following command to make a copy of the directory and its contents called <strong class="source-inline">deploy_image_test</strong>:</p>
			<p class="source-code">cp -r deploy_image deploy_image_test</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor203"/>How to do it…</h2>
			<p>You can follow the steps in this recipe to extend and enhance the model deployment that you followed in the <em class="italic">Deploying a fastai model trained on an image dataset</em> recipe to allow the <a id="_idIndexMarker607"/>user to select multiple image files in <strong class="source-inline">home.html</strong> and show predictions for all the images in <strong class="source-inline">show-prediction.html</strong>:</p>
			<ol>
				<li value="1">Make <strong class="source-inline">deploy_image_test</strong> your current directory.</li>
				<li>To allow users to select multiple files and show predictions for all the files at once, you will need to update <strong class="source-inline">home.html</strong>, the Flask server, and <strong class="source-inline">show-prediction.html</strong>.</li>
				<li>Start by updating <strong class="source-inline">home.html</strong> so that the user can select multiple files in the file dialog. Add the <strong class="source-inline">multiple</strong> attribute to the definition of the file dialog control, as shown in the following HTML snippet:<p class="source-code">  &lt;input type="file" multiple</p><p class="source-code">       id="image_field" name="image_field"</p><p class="source-code">       accept="image/png, image/jpeg"&gt;</p><p>Now the user will be able to select more than one file in the file dialog.</p></li>
				<li>Next, update the <strong class="source-inline">getOption()</strong> JavaScript function in <strong class="source-inline">home.html</strong> to build a list of filenames to add to <a id="_idIndexMarker608"/>the query string and send back to the Flask server. The updated <strong class="source-inline">getOption()</strong> function looks like this:<p class="source-code">function getOption() { </p><p class="source-code">     var file_value = [];</p><p class="source-code">  var file_count = 0;</p><p class="source-code">  const input = document.querySelector('input');</p><p class="source-code">  var file_path = input.value;</p><p class="source-code">  const curFiles = input.files;</p><p class="source-code">  if(curFiles.length === 0) {</p><p class="source-code">    console.log("file list empty");</p><p class="source-code">   } else {</p><p class="source-code">  for(const file of curFiles) {</p><p class="source-code">    if (file_count == 0) {</p><p class="source-code">      file_count = 1;</p><p class="source-code">      file_list_prefix = "&amp;file_name=";</p><p class="source-code">      var file_list = file_list_prefix.concat(file.name);</p><p class="source-code">    } else {</p><p class="source-code">      file_list = file_list.concat("&amp;file_name=",file.name);</p><p class="source-code">    }</p><p class="source-code">    file_value.push(file.name);</p><p class="source-code">  }</p><p class="source-code">  }</p><p class="source-code">  prefix = "/show-prediction/?"</p><p class="source-code">  window.output = prefix.concat("file_path=",file_path,file_list)</p><p class="source-code">}  </p><p>Here are the <a id="_idIndexMarker609"/>key updated items in the <strong class="source-inline">getOption()</strong> function:</p><p>a) <strong class="source-inline">var file_list = file_list_prefix.concat(file.name);</strong> – Specifies that if this is the first file, initialize the <strong class="source-inline">file_list</strong> string</p><p>b) <strong class="source-inline">file_list = file_list.concat("&amp;file_name=",file.name);</strong> – Specifies that if this isn't the first file, add the filename to the end of the <strong class="source-inline">file_list</strong> string</p><p>c) <strong class="source-inline">window.output = prefix.concat("file_path=",file_path,file_list)</strong> – Specifies that the query string includes the <strong class="source-inline">file_list</strong> string, which has the filenames for all the image files selected by the user</p><p>You have completed the updates required in <strong class="source-inline">home.html</strong> to handle multiple image files.</p></li>
				<li>Now it's time to update the Flask server. First, add the following function to the Flask server. You will use this function later to build the parameters that you will send to <strong class="source-inline">show-prediction.html</strong>:<p class="source-code">def package_list(key_name,list_in):</p><p class="source-code">    i = 0</p><p class="source-code">    list_out = []</p><p class="source-code">    for element in list_in:</p><p class="source-code">        key_value = list_in[i].strip()</p><p class="source-code">        list_out.append({key_name:key_value})</p><p class="source-code">        i = i+1</p><p class="source-code">    return(list_out)</p></li>
				<li>Next, update the view function for <strong class="source-inline">show-prediction.html</strong>. First, you will want to bring the list of filenames that you built in the <strong class="source-inline">getOption()</strong> function of <strong class="source-inline">home.html</strong> into a Python list. The following statement will create such a list called <strong class="source-inline">image_file_name_list</strong>:<p class="source-code">image_file_name_list = request.args.getlist('file_name')</p></li>
				<li>Next, update <a id="_idIndexMarker610"/>the view function for <strong class="source-inline">show-prediction.html</strong> so that you iterate through <strong class="source-inline">image_file_name_list</strong> to get a prediction for each file in the list. Save the <strong class="source-inline">pred_class</strong> value for each prediction in a list called <strong class="source-inline">prediction_string_list</strong>.</li>
				<li>Use the <strong class="source-inline">package_list</strong> function that you defined in <em class="italic">Step 5</em> to prepare <strong class="source-inline">prediction_string_list</strong> to send to <strong class="source-inline">show-prediction.html</strong>:<p class="source-code">    prediction_list = package_list("prediction_key",prediction_string_list)</p></li>
				<li>Update the <strong class="source-inline">return</strong> statement of the view function to include <strong class="source-inline">prediction_list</strong>:<p class="source-code">    return(render_template('show-prediction.html',prediction_list=prediction_list))</p><p>Now you have completed the updates to the Flask server required to handle multiple image files.</p></li>
				<li>Next, update <strong class="source-inline">show-prediction.html</strong> to show the predictions for each of the images:<p class="source-code">  &lt;h1 style="color: green"&gt; </p><p class="source-code">    Here are the predictions for the images you selected:</p><p class="source-code">  &lt;/h1&gt; </p><p class="source-code">  &lt;h1 style="color: green"&gt;</p><p class="source-code">  &lt;p&gt; </p><p class="source-code">  {% for prediction in prediction_list %}</p><p class="source-code">    {{prediction.prediction_key}}{% if not loop.last %}, {% endif %}</p><p class="source-code">  {% endfor %}</p><p class="source-code">  &lt;/p&gt;  </p><p class="source-code">  &lt;/h1&gt;</p></li>
				<li>Now test whether everything works. Start the Flask server in <strong class="source-inline">deploy_image_test</strong>:<p class="source-code"><strong class="bold">pyth<a id="_idTextAnchor204"/>on web_flask_deploy_image_model.py</strong></p></li>
				<li>Go to <strong class="source-inline">localhost:5000</strong> in your browser to display <strong class="source-inline">home.html</strong>. Select the <strong class="bold">Choose Files</strong> button to <a id="_idIndexMarker611"/>bring up the file selection dialog. In the file selection dialog, select the <strong class="source-inline">4_100.jpg</strong>, <strong class="source-inline">5_100.jpg</strong>, and <strong class="source-inline">26_100.jpg</strong> files from the <strong class="source-inline">deploy_image_test/test_images</strong> directory. Once you have selected these files, <strong class="source-inline">home.html</strong> will be updated to indicate that three files have been selected, as shown in <em class="italic">Figure 7.17</em>:<div id="_idContainer248" class="IMG---Figure"><img src="image/B16216_7_17.jpg" alt="Figure 7.17 – home.html after selecting three image files&#13;&#10;"/></div><p class="figure-caption">Figure 7.17 – home.html after selecting three image files</p></li>
				<li>Select the <strong class="bold">Get prediction</strong> button. You should now see the predictions for all three files in <strong class="source-inline">show-predictions.html</strong>, as shown in <em class="italic">Figure 7.18</em>:</li>
			</ol>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/B16216_7_18.jpg" alt="Figure 7.18 – show-prediciton.html showing predictions for multiple images&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.18 – show-prediciton.html showing predictions for multiple images</p>
			<p>Congratulations! You <a id="_idIndexMarker612"/>have completed a useful extension to the deployment of the image classification model.</p>
		</div>
	</body></html>