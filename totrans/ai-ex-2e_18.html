<html><head></head><body>
  <div id="_idContainer435">
    <h1 class="chapterNumber">18</h1>
    <h1 id="_idParaDest-365" class="chapterTitle">Neuromorphic Computing</h1>
    <p class="normal">Our brain activates thousands or even billions of neurons when necessary, getting our body battle-ready to face any situation. As we saw in <em class="italics">Chapter 17</em>, <em class="italics">Genetic Algorithms in Hybrid Neural Networks</em>, evolution has fined-tuned biological capacities over thousands of generations and millions of years.</p>
    <p class="normal">In this chapter, we will take a deeper look into the cognitive power inside our bodies. We will go from the chromosomes of the previous chapter to biological neurons that make us intelligent creatures. The neurons interact in billions of ways producing cognitive patterns leading to mind structures.</p>
    <p class="normal">Neuromorphic computing taps into the tremendous optimized power of our brain, which surprisingly consumes very little energy. On average, we consume a few watts, less than a lightbulb, to solve very complex problems. In itself, this shows that the neuronal structure of our brain has a unique architecture that we have yet to reproduce physically.</p>
    <p class="normal">To bring neuromorphic computing into the real world requires hardware and software, as in all computer science models. In this chapter, we will focus on the software, though it is important to mention the hardware associated with the neuromorphic research Intel is conducting. That hardware takes the form of a chip named Loihi, after the emerging Hawaiian underwater volcano that will hit the surface one day. Loihi contains thousands upon thousands of neurons with their synapses, dendrites, and axons reproducing our brain activity. IBM and other corporations have been conducting research in this area.</p>
    <p class="normal">We have around 100 billion neurons. These chips are only reaching hundreds of thousands of neurons. However, by connecting thousands of those chips in physical networks, neuromorphic computing will be an area we all will have to take into account in the near future.</p>
    <p class="normal">We will first define what neuromorphic computing is and then explore Nengo, a unique neuromorphic framework with solid tutorials and documentation. Nengo is one among many other approaches that go beyond the scope of this book. This chapter is not a neuromorphic course but rather an overview, inviting you to tap into the wonderful power of our brain structures to solve complex problems. The problems we will explore will bring us closer to understanding how our brain works.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="list">What neuromorphic computing is</li>
      <li class="list">Getting started with Nengo</li>
      <li class="list">Basic Nengo concepts</li>
      <li class="list">Exploring the Nengo tutorial and interface</li>
      <li class="list">The difference between Nengo and classical AI</li>
      <li class="list">Applying Nengo's unique <strong class="bold">Semantic Pointer Architecture </strong>(<strong class="bold">SPA</strong>) model to critical research areas</li>
    </ul>
    <p class="normal">Let's start with the basics—what is neuromorphic computing?</p>
    <h1 id="_idParaDest-366" class="title">Neuromorphic computing</h1>
    <p class="normal">Let's go directly to the core of our <a id="_idIndexMarker874"/>thought process to understand neuromorphic computing. For AI experts, I would like to summarize the voyage from our classical models to cutting-edge neuromorphic models in a single phrase:</p>
    <p class="center"><em class="italics">from mind to brain</em></p>
    <p class="normal">If we take this further, <em class="italics">M</em> is the set of all of our mental representations and <em class="italics">B</em> is the world of physical reactions that lead to thinking patterns.</p>
    <p class="normal">In this sense, <em class="italics">M</em> is a set of everything we have explored up to this point in this book:</p>
    <p class="center"><em class="italics">M</em> = {rule based systems, machine learning, deep learning, evolutionary algorithms … <em class="italics">m</em>}</p>
    <p class="normal"><em class="italics">m</em> is any mathematical <em class="italics">mental representation</em> of the world surrounding us. In deep learning, for example, an artificial neural network will try to make sense of the chaos of an image by searching the patterns it can find in an image through lower dimensions and higher levels of abstraction.</p>
    <p class="normal">However, a mental construction, no matter how efficient it seems, remains a <em class="italics">representation</em>, not a physical reality.</p>
    <p class="normal">Now, let's observe <em class="italics">B</em> = <em class="italics">brain constructions</em>:</p>
    <p class="normal"><em class="italics">B</em> = phenomena/events (inside us or in the outer world) -&gt; physical stimuli -&gt; physical neural activity in the brain -&gt; higher activity in the target zones -&gt; physical electric learning reactions -&gt; a human action</p>
    <p class="normal">The architecture of <em class="italics">B</em> takes <a id="_idIndexMarker875"/>us much closer to reality! Mental representations are minimized, thus reducing the distortion of artificial constructions regardless of their efficiency.</p>
    <p class="normal">Classical AI is about building mental representations of our cognitive activity.</p>
    <p class="normal">Neuromorphic computing is about building a brain that can encode reality, process it like a human brain, and decode the result.</p>
    <p class="normal">Bear in mind that corporations such as Intel are providing the chips to accomplish wonderful things with neuromorphic computing, as we will discover in this chapter.</p>
    <p class="normal">Now that we have some idea of what neuromorphic computing is, let's take a look at the neuromorphic framework, Nengo.</p>
    <h1 id="_idParaDest-367" class="title">Getting started with Nengo</h1>
    <p class="normal">In a<a id="_idIndexMarker876"/> nutshell, <em class="italics">Nengo builds brains, not mental representations</em>, as in classical machine learning and deep learning.</p>
    <p class="normal">Nengo<a id="_idIndexMarker877"/> stands for <em class="italics">Neural Engineering Object</em>. It has both scripting capability with Nengo and a graphical capacity with Nengo GUI. We will be using NEF, which is Nengo's <strong class="bold">Neural Engineering Framework</strong> (<strong class="bold">NEF</strong>).</p>
    <p class="normal">Nengo was created by the Centre for Theoretical Neuroscience at the University of Waterloo (Ontario, Canada). Chris Eliasmith has played an important role in this project.</p>
    <p class="normal">We have explored many ways to approach cognitive modeling in the previous chapters. Nengo uses an NEF to implement an SPA.</p>
    <p class="normal">A <em class="italics">semantic pointer</em> is a<a id="_idIndexMarker878"/> neural representation in a biological system that carries structures that will lead to higher-level cognitive representations.</p>
    <p class="normal">The term <em class="italics">pointer</em> refers<a id="_idIndexMarker879"/> to pointers as we know in C++, for example, because they can access data they do not contain.</p>
    <p class="normal">The term <em class="italics">semantic</em> refers to<a id="_idIndexMarker880"/> the fact that they are not just mathematical tools as in C++ because they contain virtual representations through the distances between them.</p>
    <p class="normal">If we put the two concepts together, this leads to the mind-blowing concept of meaning being generated through biological pointer activity located at various distances and states from each other in our brain. Let's dive into neuromorphic computing by first installing Nengo.</p>
    <h2 id="_idParaDest-368" class="title">Installing Nengo and Nengo GUI</h2>
    <p class="normal">For this chapter, I used the<a id="_idIndexMarker881"/> Python interfaces with NumPy and Matplotlib libraries, as we have since the beginning of this book. All that is then required is to install Nengo with <code class="Code-In-Text--PACKT-">pip</code>, for example:</p>
    <pre class="programlisting"><code class="hljs cmake">pip <span class="hljs-keyword">install</span> nengo
</code></pre>
    <p class="normal">You can install it using <a id="_idIndexMarker882"/>other approaches. For more information, go to <a href="https://github.com/nengo/nengo"><span class="url">https://github.com/nengo/nengo</span></a>.</p>
    <p class="normal">Let's install the nice HTML 5 visualizer and interact with Nengo through this GUI I installed with <code class="Code-In-Text--PACKT-">pip</code>:</p>
    <pre class="programlisting"><code class="hljs cmake">pip <span class="hljs-keyword">install</span> nengo-gui
</code></pre>
    <p class="normal">You can install it using<a id="_idIndexMarker883"/> other approaches, too. For more information, go<a id="_idIndexMarker884"/> to: <a href="https://github.com/nengo/nengo-gui/"><span class="url">https://github.com/nengo/nengo-gui/</span></a>.</p>
    <p class="normal">Once both programs are installed, if you encounter any problems then consult the links, which contain a lot of information, or Nengo's support team, who provide excellent feedback.</p>
    <p class="normal">There are many ways to use Nengo. This chapter describes a quick start method with Python.</p>
    <p class="normal">Once you are all set, open your browser, Chrome, for example, and then type <code class="Code-In-Text--PACKT-">nengo</code> in a command-line console and it should open the Nengo GUI interface in your browser, opening a <code class="Code-In-Text--PACKT-">default.py</code> Python program:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.1: Nengo Python code</p>
    <p class="normal">Click on the folder icon in the top left and click on <code class="Code-In-Text--PACKT-">built-in examples</code>:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.2: Nengo examples</p>
    <p class="normal">A list will appear. Click on <code class="Code-In-Text--PACKT-">tutorial</code>:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.3: List of Nengo examples</p>
    <p class="normal">A list of fascinating <a id="_idIndexMarker885"/>educational examples will appear:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.4: Examples in the tutorial section</p>
    <p class="normal">The tutorial programs are in the directory the installer wrote them in.</p>
    <p class="normal">You can see them in the URL of a Python example of the tutorial in the address bar of your browser.</p>
    <h2 id="_idParaDest-369" class="title">Creating a Python program</h2>
    <p class="normal">Now, let's create a<a id="_idIndexMarker886"/> Python program and save the file through a few steps:</p>
    <ul>
      <li class="list">Open an empty Python file but do not save it yet</li>
      <li class="list">Write the following code to import the <code class="Code-In-Text--PACKT-">nengo</code> library and create a model:
        <pre class="programlisting"><code class="hljs nix"><span class="hljs-built_in">import</span> nengo
<span class="hljs-attr">model</span> = nengo.Network()
<span class="hljs-keyword">with</span> model:
    <span class="hljs-comment">#&lt;your code here&gt;</span>
</code></pre>
      </li>
    </ul>
    <p class="normal">Now, save the Python file in the path of the other programs of the tutorial. You can see this path when you open a Nengo example. Just navigate to that path to save your program. We will name it <code class="Code-In-Text--PACKT-">00-myintro.py</code> to fit in nicely with the list of programs in the tutorial:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.5: Saving a Python program</p>
    <p class="normal">We will go back to the <code class="Code-In-Text--PACKT-">tutorial</code> directory as we did previously, and we will open it to add basic Nengo objects.</p>
    <p class="normal">Nengo objects are the building blocks of a Nengo model to create populations of neurons, connecting them to stimulation functions, and managing the outputs.</p>
    <p class="normal">For our <a id="_idIndexMarker887"/>Python program, we will use some key Nengo objects, which are detailed in the following sections.</p>
    <h2 id="_idParaDest-370" class="title">A Nengo ensemble</h2>
    <p class="normal">A Nengo ensemble <a id="_idIndexMarker888"/>is a group of neurons. It can be considered as a population of neurons that contain real numbers.</p>
    <p class="normal">An ensemble is an object created with:</p>
    <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">nengo</span><span class="hljs-selector-class">.Ensemble</span>
</code></pre>
    <p class="normal">An ensemble can be created in one line:</p>
    <pre class="programlisting"><code class="hljs routeros">ensemblex = nengo.Ensemble(<span class="hljs-attribute">n_neurons</span>=5, <span class="hljs-attribute">dimensions</span>=1)
</code></pre>
    <p class="normal">As soon as we add a line to <code class="Code-In-Text--PACKT-">00-myintro.py</code>, a representation of the ensemble appears on the left-hand pane of the Nengo interface:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.6: Neuron ensemble</p>
    <p class="normal">While writing your Python code in the code editor on the right, you can visualize the visual flow of the model in the visual interface pane.</p>
    <p class="normal">An ensemble can contain a population of one individual, a single neuron. This neuron is a representation of our biological neurons:</p>
    <ul>
      <li class="list"><strong class="bold">Postsynaptic currents</strong> (<strong class="bold">PSCs</strong>) flow through our <a id="_idIndexMarker889"/>dendrites</li>
      <li class="list">The <em class="italics">current</em> then reaches the core of the neuron (cell body)</li>
      <li class="list">If the current exceeds a threshold at the axon's initial segment (axon hillock), then a <em class="italics">spike</em> is generated</li>
      <li class="list">With ion channels open, the<a id="_idIndexMarker890"/> PSCs are produced in the receiving cell</li>
    </ul>
    <p class="normal">Let's take a more detailed look at Nengo's neuron types.</p>
    <h3 id="_idParaDest-371" class="title">Nengo neuron types</h3>
    <p class="normal">We created 50 neurons in <a id="_idIndexMarker891"/>our ensemble:</p>
    <pre class="programlisting"><code class="hljs ini"><span class="hljs-attr">ens</span> = nengo.Ensemble(n_neurons=<span class="hljs-number">50</span>...
</code></pre>
    <p class="normal">There are various neuron types. However, in our example, we will be using the default neuron, a <strong class="bold">leaky integrate-and-fire </strong>(<strong class="bold">LIF</strong>) neuron.</p>
    <p class="normal">Neuronal dynamics are based on a summation process <a id="_idIndexMarker892"/>called <strong class="bold">integration</strong>. This integration is associated with a mechanism that will fire (trigger) up above a critical voltage.</p>
    <p class="normal">A linear differential equation combined with a threshold that will trigger file spiking are the final components that make up the default LIF neuron we will be using, unless specified otherwise.</p>
    <p class="normal">For more on Nengo <a id="_idIndexMarker893"/>neuron types, see <a href="https://www.nengo.ai/nengo-extras/neurons.html"><span class="url">https://www.nengo.ai/nengo-extras/neurons.html</span></a>.</p>
    <h3 id="_idParaDest-372" class="title">Nengo neuron dimensions</h3>
    <p class="normal">In our <a id="_idIndexMarker894"/>example, <code class="Code-In-Text--PACKT-">dimensions</code> is set to <code class="Code-In-Text--PACKT-">1</code>; this means that the ensemble is represented by one number (or dimension):</p>
    <pre class="programlisting"><code class="hljs routeros">ens = nengo.Ensemble(<span class="hljs-built_in">..</span>., <span class="hljs-attribute">dimensions</span>=1)
</code></pre>
    <h3 id="_idParaDest-373" class="title">A Nengo node</h3>
    <p class="normal">Now that we have<a id="_idIndexMarker895"/> defined our ensemble of neurons and their output dimension, we will define the output:</p>
    <pre class="programlisting"><code class="hljs crmsh">node_number = nengo.<span class="hljs-keyword">Node</span><span class="hljs-title">(output</span>=<span class="hljs-number">0.5</span>)
</code></pre>
    <p class="normal">The stimulation will be a constant and will be displayed on the slider as such:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.7: Nengo slider</p>
    <p class="normal">An output with a number might not suffice in some cases. This number can be replaced by a function importing <a id="_idIndexMarker896"/>NumPy. A sine wave function can be used, for example:</p>
    <pre class="programlisting"><code class="hljs crmsh">node_function = nengo.<span class="hljs-keyword">Node</span><span class="hljs-title">(output</span>=np.sin)
</code></pre>
    <p class="normal">As soon as we enter our node function, it appears on the interface in addition to the previous information displayed:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.8: The node function on the interface</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">node_function</code> provides a way to send non-neural inputs to Nengo objects.</p>
    <p class="normal">We will explore such an implementation in the <code class="Code-In-Text--PACKT-">15-lorenz.py</code> example in this chapter that is in the tutorial section Nengo's examples.</p>
    <p class="normal">If you right-click on the <code class="Code-In-Text--PACKT-">node_function</code> image and choose a value, you will see a curve representing the real-time value of the sine wave stimulation:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.9: Node function</p>
    <p class="normal">For more on <a id="_idIndexMarker897"/>Nengo objects, go to <a href="https://www.nengo.ai/nengo/getting_started.html#creating-nengo-objects"><span class="url">https://www.nengo.ai/nengo/getting_started.html#creating-nengo-objects</span></a>.</p>
    <h2 id="_idParaDest-374" class="title">Connecting Nengo objects</h2>
    <p class="normal">We now need to connect the<a id="_idIndexMarker898"/> ensemble and the node to make our system work. In this manner, the ensemble will have a function.</p>
    <p class="normal">At this point, we have an ensemble and a node function, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.10: Ensemble and node function</p>
    <p class="normal">To connect them, we will add a Nengo connection:</p>
    <pre class="programlisting"><code class="hljs reasonml">nengo.<span class="hljs-constructor">Connection(<span class="hljs-params">node_function</span>, <span class="hljs-params">ens</span>)</span>
</code></pre>
    <p class="normal">For more Nengo<a id="_idIndexMarker899"/> frontend API definitions, see <a href="https://www.nengo.ai/nengo/frontend_api.html"><span class="url">https://www.nengo.ai/nengo/frontend_api.html</span></a>.</p>
    <p class="normal">Now, let's explore the exciting visual interface.</p>
    <h2 id="_idParaDest-375" class="title">Visualizing data</h2>
    <p class="normal">The first step is to click on the<a id="_idIndexMarker900"/> play button in the bottom-right corner of the screen:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.11: Play button</p>
    <p class="normal">This will set time in motion, simulating our brain activity. Time is one of the unique features of neuromorphic computing. We do not pile layer upon layer of static mathematics into a mental representation. With Nengo, we simulate brain activity step by step, second by second!</p>
    <p class="normal">Once you click on the play button, it feels like we are looking inside our brain!</p>
    <p class="normal">We saw how to visualize the slider's activity in the previous section, which produces the stimulations. We will focus on our ensemble in this section.</p>
    <p class="normal">If we right-click on the ensemble visualization, several options appear: <strong class="screen-text">Value</strong>, <strong class="screen-text">Spikes</strong>, <strong class="screen-text">Voltages</strong>, <strong class="screen-text">Firing pattern</strong>, and <strong class="screen-text">Details...</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.12: Ensemble options</p>
    <ul>
      <li class="list"><strong class="screen-text">Value</strong>: The value of our <a id="_idIndexMarker901"/>ensemble will be displayed, from –1 to 1, for example:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.13: Values of an ensemble</p>
    <ul>
      <li class="list"><strong class="screen-text">Spikes</strong>: The spiking activity produces nice colors that show how our neurons are reacting to sine wave stimulation:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.14: Spiking patterns</p>
    <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">You will notice that each neuron has its own spiking channel. This property of ensembles produces a wide variety of responses.</p>
    <ul>
      <li class="list"><strong class="screen-text">Voltages</strong>: The voltages <a id="_idIndexMarker902"/>provide interesting information on the current that is flowing through our neurons under stimulation from other neurons and, in turn, from yet more neurons that are gathering information from the world outside us.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In the following screenshot, the ensemble contained a population of five neurons with color channels providing yet more information:</p>
      </li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.15: Neuron activity with color patterns</p>
    <ul>
      <li class="list"><strong class="screen-text">Firing pattern</strong>: The firing pattern of the ensemble in the following image was generated with 50 neurons. The firing pattern is necessarily directly linked to the stimulations and connections:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.16: Firing pattern</p>
    <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">I have been observing <a id="_idIndexMarker903"/>many patterns through the experiments I carried out. One of the areas of research I'm doing is to feed the thousands of frames of firing patterns of a given function to an ANN and a stochastic Church-Turing algorithm and generate "thought" patterns. For example, running the channels of the frames could produce sequences of new data. It's worth experimenting with.</p>
    <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The following image represents the pattern of 500 neurons bringing complexity to the potential of running deep learning on thousands of frames of these patterns:</p>
    <figure class="mediaobject"><img src="../Images/B15438_18_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.17: Firing patterns</p>
    <ul>
      <li class="list"><strong class="screen-text">Details...</strong>: In the plots section, we can visualize input current and tuning curves. The tuning curve<a id="_idIndexMarker904"/> shows how the neurons are reacting to the input current. If there is no pattern, then there must be an explanation or a configuration problem.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The visual control of tuning curves is a time saver by showing how they converge!</p>
      </li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.18: Tuning curves</p>
    <p class="normal">We have covered some of the main visual tools Nengo provides.</p>
    <p class="normal">Now, we will see how to retrieve data from our system with probes.</p>
    <h2 id="_idParaDest-376" class="title">Probes</h2>
    <p class="normal">We can retrieve information <a id="_idIndexMarker905"/>with probes, either to visualize them or to process output data.</p>
    <p class="normal">In this section, I enhanced <code class="Code-In-Text--PACKT-">00-myintro.py</code> to produce numerical output as well as visual output using the information on the following page that you can get ideas from for your projects: <a href="https://www.nengo.ai/nengo/examples/basic/single_neuron.html"><span class="url">https://www.nengo.ai/nengo/examples/basic/single_neuron.html</span></a></p>
    <p class="normal">The program I created is <code class="Code-In-Text--PACKT-">nengo_probing.py</code> and is available in the GitHub repository of this book. The program is a standalone program that does not run in Nengo's GUI. You cannot use simulation commands as shown in the following in Nengo's GUI. Run this program in your Python interface. It shows yet another way to run the rich Nengo software.</p>
    <p class="normal">The program contains <a id="_idIndexMarker906"/>additional headers for Matplotlib and distributions for data displaying and processing purposes:</p>
    <pre class="programlisting"><code class="hljs elm"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-title">from</span> nengo.utils.matplotlib <span class="hljs-keyword">import</span> rasterplot
<span class="hljs-title">from</span> nengo.dists <span class="hljs-keyword">import</span> Uniform
</code></pre>
    <p class="normal">The program contains the same architecture as <code class="Code-In-Text--PACKT-">00-myintro.py</code>. It creates an ensemble, adds a function, and then connects the objects:</p>
    <pre class="programlisting"><code class="hljs reasonml">model = nengo.<span class="hljs-constructor">Network(<span class="hljs-string">"Probing"</span>)</span>
<span class="hljs-keyword">with</span> model:
    ens = nengo.<span class="hljs-constructor">Ensemble(<span class="hljs-params">n_neurons</span>=50, <span class="hljs-params">dimensions</span>=1)</span>
    #node_number = nengo.<span class="hljs-constructor">Node(<span class="hljs-params">output</span>=0.5)</span>
    node_function=nengo.<span class="hljs-constructor">Node(<span class="hljs-params">output</span>=<span class="hljs-params">np</span>.<span class="hljs-params">sin</span>)</span>
    nengo.<span class="hljs-constructor">Connection(<span class="hljs-params">node_function</span>, <span class="hljs-params">ens</span>)</span>
    print(ens.probeable)
<span class="hljs-keyword">with</span> model:
    # Connect the input signal <span class="hljs-keyword">to</span> the neuron
    nengo.<span class="hljs-constructor">Connection(<span class="hljs-params">node_function</span>, <span class="hljs-params">ens</span>)</span>
</code></pre>
    <p class="normal">We will now add a probing function using <code class="Code-In-Text--PACKT-">nengo.Probe</code>:</p>
    <pre class="programlisting"><code class="hljs routeros">    # The original input
    function_probe = nengo.Probe(node_function)
    # The<span class="hljs-built_in"> raw </span>spikes <span class="hljs-keyword">from</span> the neuron
    spikes = nengo.Probe(ens.neurons)
    # Subthreshold soma voltage of the neuron
    voltage = nengo.Probe(ens.neurons, <span class="hljs-string">'voltage'</span>)
    # Spikes filtered by a 10ms post-synaptic<span class="hljs-built_in"> filter
</span>    filtered = nengo.Probe(ens, <span class="hljs-attribute">synapse</span>=0.01)
</code></pre>
    <p class="normal">To obtain some data, let's run the simulator for 5 seconds:</p>
    <pre class="programlisting"><code class="hljs applescript"><span class="hljs-keyword">with</span> nengo.Simulator(model) <span class="hljs-keyword">as</span> sim:  <span class="hljs-comment"># Create the simulator</span>
    sim.<span class="hljs-built_in">run</span>(<span class="hljs-number">5</span>)
</code></pre>
    <p class="normal">The simulator runs the calculation <em class="italics">before</em> displaying the outputs.</p>
    <p class="normal">Then, we can probe the data and display it in numerical format. That way, we can retrieve output data from our system for further use, visualizing or chaining neuromorphic models to <a id="_idIndexMarker907"/>other algorithms in a few lines of code:</p>
    <ul>
      <li class="list"><strong class="bold">Decoded output</strong>: The decoded output can be filtered (see the preceding filter):
        <pre class="programlisting"><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"Decoded output of the ensemble"</span>)</span></span>
<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sim.trange()</span></span>, sim<span class="hljs-selector-class">.data</span>[filtered])
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The output data is then displayed or can be processed:</p>
        <pre class="programlisting"><code class="hljs json">[<span class="hljs-number">1.000e-03</span> <span class="hljs-number">2.000e-03</span> <span class="hljs-number">3.000e-03</span> ... <span class="hljs-number">4.998e+00</span> <span class="hljs-number">4.999e+00</span> <span class="hljs-number">5.000e+00</span>] [[ <span class="hljs-number">0.</span>        ]
 [ <span class="hljs-number">0.</span>        ]
 [<span class="hljs-number">-0.03324582</span>]
 ...
 [<span class="hljs-number">-1.26366121</span>]
 [<span class="hljs-number">-1.22083471</span>]
 [<span class="hljs-number">-1.18750863</span>]]
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Nengo can produce a chart with Matplotlib:</p>
        <pre class="programlisting"><code class="hljs less"># <span class="hljs-selector-tag">Plot</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">decoded</span> <span class="hljs-selector-tag">output</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">ensemble</span>
<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.figure</span>()
<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.plot</span>(sim.trange(), sim.data[filtered])
<span class="hljs-selector-id">#plt</span><span class="hljs-selector-class">.plot</span>(sim.trange(), sim.data[node_function])
<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.xlim</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.suptitle</span>(<span class="hljs-string">'Filter decoded output'</span>, fontsize=<span class="hljs-number">16</span>)
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The output of the preceding code is plotted as follows:</p>
      </li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.19: Decoded input</p>
    <ul>
      <li class="list"><strong class="bold">Spikes</strong>: Spikes are <a id="_idIndexMarker908"/>retrieved in a single line of code:
        <pre class="programlisting"><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"Spikes"</span>)</span></span>
<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sim.trange()</span></span>,sim<span class="hljs-selector-class">.data</span>[spikes])
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The output produces sequences of spikes:</p>
        <pre class="programlisting"><code class="hljs angelscript">[<span class="hljs-number">1.000e-03</span> <span class="hljs-number">2.000e-03</span> <span class="hljs-number">3.000e-03</span> ... <span class="hljs-number">4.998e+00</span> <span class="hljs-number">4.999e+00</span> <span class="hljs-number">5.000e+00</span>] [[   <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span> ...    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>]
 [   <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span> ...    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>]
 [   <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span> ... <span class="hljs-number">1000.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>]
 ...
 [   <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span> <span class="hljs-number">1000.</span> ...    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>]
 [   <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span> ...    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>    <span class="hljs-number">0.</span>]
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The program produces a figure for spikes that matches the data:</p>
      </li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.20: Spiking output</p>
    <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We can check <a id="_idIndexMarker909"/>the visual display with valuable raw data.</p>
    <ul>
      <li class="list"><strong class="bold">Voltage</strong>: The simulation provides voltage data:
        <pre class="programlisting"><code class="hljs markdown">print("Voltage")
print((sim.trange(), sim.data[<span class="hljs-string">voltage</span>][<span class="hljs-symbol">:, 0</span>]))
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The data is stored in a ready-to-use array:</p>
        <pre class="programlisting"><code class="hljs angelscript">(<span class="hljs-built_in">array</span>([<span class="hljs-number">1.000e-03</span>, <span class="hljs-number">2.000e-03</span>, <span class="hljs-number">3.000e-03</span>, ..., <span class="hljs-number">4.998e+00</span>, <span class="hljs-number">4.999e+00</span>,
       <span class="hljs-number">5.000e+00</span>]), <span class="hljs-built_in">array</span>([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]))
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The program produces a figure for the voltage of the ensemble as well:</p>
      </li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.21: Neuron voltage</p>
    <p class="normal">At this point, we have covered the main features of Nengo. We will now see how Nengo can boost research in critical AI research areas.</p>
    <h1 id="_idParaDest-377" class="title">Applying Nengo's unique approach to critical AI research areas</h1>
    <p class="normal">It is useless to apply the <a id="_idIndexMarker910"/>power of brain neuromorphic models to simple arithmetic or classical neural networks that do not require any more than TensorFlow 2.x, for example.</p>
    <p class="normal">But it is also a waste of time to try to solve problems with classical networks that neuromorphic computing can solve better with organic brain models. For example:</p>
    <ul>
      <li class="list">Deep learning, TensorFlow 2. Convolutional models use a unique activation function such as ReLU (see <em class="italics">Chapter 9</em>, <em class="italics">Abstract Image Classification with Convolutional Neural Networks (CNNs)</em>). Neuromorphic neurons have a variety of reactions when stimulated.</li>
      <li class="list">Neuromorphic models integrate time versus more static DL algorithms. When we run neuromorphic models, we are closer to the reality of our time-driven biological models.</li>
      <li class="list">The Human Brain Project, <a href="https://www.humanbrainproject.eu/en/"><span class="url">https://www.humanbrainproject.eu/en/</span></a>, provides wide research and examples of how neuromorphic computing provides additional insights to classical computing.</li>
    </ul>
    <p class="normal">I recommend testing a given problem with several AI tools and choosing the most efficient one.</p>
    <p class="normal">The SPA<a id="_idIndexMarker911"/> examples demonstrate the efficiency of Nengo in several areas. All of the examples in the tutorial section are well documented and run well. You can apply the visualizing functions we explored in this chapter to them and also modify the code, experiment with them in your Python environment, and more.</p>
    <p class="normal">I wish to highlight two domains: linguistics and weather representations:</p>
    <ul>
      <li class="list"><strong class="bold">Linguistics</strong>: <code class="Code-In-Text--PACKT-">25-spa-parse.py</code> processes neuronal signals and produces words. When you run it, the performances look magical, thanks to the SPA. The code is well documented.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The program contains the mind-blowing <code class="Code-In-Text--PACKT-">thalamus</code> module that can simulate the subcortical nuclei in our brains (forebrain and midbrain). This part of our brain, the basal ganglia, has high-density connections.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">This class can reduce or even eliminate low responses and intensify high responses to the stimulations. The program is worth running and exploring! The Nengo GUI makes it intuitive to understand:</p>
      </li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.22: Nengo GUI options</p>
    <ul>
      <li class="list"><strong class="bold">Weather representations</strong>: <code class="Code-In-Text--PACKT-">15-lorenz.py</code> is not an SPA program. It is only a few lines long. It displays the graphs of the three basic Lorenz equations that represent temperatures and variations in the atmosphere. Nengo modified the code for educational purposes as explained in a publication at <a href="http://compneuro.uwaterloo.ca/publications/eliasmith2005b.html"><span class="url">http://compneuro.uwaterloo.ca/publications/eliasmith2005b.html</span></a>. The Nengo GUI displays an exciting representation:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B15438_18_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 18.23: Lorenz equations</p>
    <p class="Bullet-Without-Bullet-Within-Bullet-End--PACKT-">The code of <code class="Code-In-Text--PACKT-">15-lorenz.py</code> is short, and the program looks simple. But weather forecasting is one of <a id="_idIndexMarker912"/>the toughest fields to represent events with AI models!</p>
    <p class="normal">The potential of neuromorphic computing can be a real game-changer. Let's conduct a mind experiment. Imagine that:</p>
    <ul>
      <li class="list">A hurricane is like a living organism</li>
      <li class="list">That its center is connected to everything around it</li>
      <li class="list">That it "feeds" on the heat and waters of our oceans</li>
      <li class="list">That everything that is in it can be considered as small hurricane particles</li>
    </ul>
    <p class="normal">Let's now continue the experiment by:</p>
    <ul>
      <li class="list">Feeding the billions of particles in the neuromorphic model in a stream</li>
      <li class="list">Using the power of a network of neuromorphic chips</li>
      <li class="list">Using the calculation power of quantum computing (see <em class="italics">Chapter 19</em>, <em class="italics">Quantum Computing</em>) to perform computations with the input/output of the chip</li>
      <li class="list">Applying SPA to the hurricane particle representations as if they were neurons and running predictions</li>
    </ul>
    <p class="normal">I think the future of <a id="_idIndexMarker913"/>weather forecasting is in physical, neuromorphic models, that will take billions of parameters into account.</p>
    <p class="normal">The result: we will be able to predict the course and level of a hurricane a few hours to a few days more in advance. This could save lives.</p>
    <p class="normal">In a nutshell, neuromorphic computing has only just begun to demonstrate its worth. When neuromorphic chips hit the market, neuromorphic computing will grow exponentially.</p>
    <h1 id="_idParaDest-378" class="title">Summary</h1>
    <p class="normal">In this chapter, we built neuromorphic Python programs from scratch. Populations of neurons, in Nengo ensembles, are made up of neurons. The system then has stimulation functions, connections, and probing objects. Nengo offers many other examples you can explore.</p>
    <p class="normal">The NEF was designed to implement neuromorphic computing models. The novel concept of SPA shows that our brains have enhanced pointers that have a meaning and are linked to our physical data.</p>
    <p class="normal">Neuromorphic computing opens tremendous horizons for a complex program that classical machine learning and deep learning cannot solve. Weather forecasting, with the power of the neuromorphic chips that are reaching the market, can tap into the complexity and variety of a machine brain. A machine brain can produce unique calculations by firing hundreds of thousands of neurons with both individual and collective behavior.</p>
    <p class="normal">We have covered many algorithms and frameworks in this book. We have access to the most powerful intelligent algorithms in the history of humanity. From MDP to GA algorithms, and from KMC, KNN, PCA, NLP, and CUI algorithms to CNN, RBM, RNN, and LSTM networks, we have explored many AI tools. But there may be ways to build unified models. We will see in the years to come. In the meantime, neuromorphic computing makes our toolbox incredibly intelligent. Google has TPU hardware to optimize TensorFlow, neuromorphic computing can rely on Intel chips, and many corporations are working to produce more innovative hardware.</p>
    <p class="normal">The future will no doubt rely on hybrid architectures in which some or all of the AI tools will be built into meta-AI systems.</p>
    <p class="normal">In <em class="italics">Chapter 19</em>, <em class="italics">Quantum Computing</em>, we will explore the exponential hardware available for quantum mechanics. Quantum computers, having no memory, rely on other systems to provide inputs and process outputs. Imagine a neuromorphic system chained to a quantum computer!</p>
    <h1 id="_idParaDest-379" class="title">Questions</h1>
    <ol>
      <li class="list">Neuromorphic computing reproduces our mental activity. (Yes | No)</li>
      <li class="list">Neuromorphic computing reproduces our brain activity. (Yes | No)</li>
      <li class="list">Semantic Pointer Architecture (SPA) is a hardware architecture. (Yes | No)</li>
      <li class="list">NEF stands for Neural Engineering Framework. (Yes | No)</li>
      <li class="list">Loihi is a classical chip. (Yes | No)</li>
      <li class="list">Reproducing our brain's neural activity cannot solve an equation. (Yes | No)</li>
      <li class="list">An ensemble in Nengo contains algorithms. (Yes | No)</li>
      <li class="list">Spiking blocks neuronal activity. (Yes | No)</li>
      <li class="list">Firing patterns can be used to analyze brain activity. (Yes | No)</li>
      <li class="list">Machine learning and deep learning are only metaphors of our brain's activity. (Yes | No)</li>
    </ol>
    <h1 id="_idParaDest-380" class="title">References</h1>
    <p class="normal">Reference programs used for this chapter can be found at <a href="https://www.nengo.ai"><span class="url">https://www.nengo.ai</span></a>, <a href="https://www.nengo.ai/examples/"><span class="url">https://www.nengo.ai/examples/</span></a>.</p>
    <h1 id="_idParaDest-381" class="title">Further reading</h1>
    <ul>
      <li class="list"><strong class="bold">Research</strong> – <em class="italics">How to Build a Brain</em>, <em class="italics">Chris Eliasmith</em>: This book provides the theoretical background for neuromorphic computing.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Chris Eliasmith is also one of the designers of Nengo.</p>
      </li>
      <li class="list"><strong class="bold">Software</strong> – Nengo (<a href="https://www.nengo.ai/"><span class="url">https://www.nengo.ai/</span></a>): Nengo is based on solid research, documentation, and an excellent community.</li>
      <li class="list"><strong class="bold">Hardware</strong> – Intel: Intel is working hard to produce a neuromorphic chip (<a href="https://www.intel.fr/content/www/fr/fr/research/neuromorphic-computing.html"><span class="url">https://www.intel.fr/content/www/fr/fr/research/neuromorphic-computing.html</span></a>).</li>
    </ul>
  </div>
</body></html>