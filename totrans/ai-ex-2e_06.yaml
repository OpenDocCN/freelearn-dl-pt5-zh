- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Innovating AI with Google Translate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will illustrate how to innovate existing AI through Google
    Translate. First, we will start by understanding the difference between inventions,
    innovations, disruption, high-priced products, and revolutions, and how we can
    create an impact on an AI innovation.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a developer will confuse an invention with innovation, leading to
    a major failure in a key AI project. Some AI designers take a revolution to mean
    a disruption, leading to early sales and then nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined the key concepts of innovation, we will use Google Translate
    to understand the linguistic principles that surround **natural language processing**
    (**NLP**).
  prefs: []
  type: TYPE_NORMAL
- en: Google Translate entered the market in 2006 and was enhanced by neural networks
    in 2016, but still, it often produces bad answers. Is that good news or bad news?
    We will implement Google's API in a Python program to find out how to uncover
    false translations from one language to another.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have found Google Translate's limits, we will finally find out how to
    transcend those limits with our own adaptations, by exploring Google's API in
    a Python program, adding a **k-nearest neighbors** (**KNN**) algorithm, and measuring
    the results statistically.
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to media hype, artificial intelligence has only just begun to innovate
    human processes. A huge amount of work remains to be done. To achieve progress,
    everybody must get involved, as we'll discuss in this chapter. Even if Google,
    Amazon, Microsoft, IBM, and others offer a solution, this does not mean it cannot
    be improved by third parties as add-ons to existing solutions or new standalone
    products. After all, once Ford invented the Model T over a hundred years ago,
    this did not preclude the development of even better cars. On the contrary, look
    around you!
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of the AI adventure, we will go from understanding disruption
    in AI to Google Translate, and then innovate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the key concepts of AI innovation before starting to implement
    Google Translate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between inventions and innovations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between revolutionary and disruptive AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Translate API implementation in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing linguistics as a prerequisite to building any **natural language
    processing** (**NLP**) algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KNN algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to customize Google Translate with a KNN in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by exploring the key concepts of AI innovation and disruption.
  prefs: []
  type: TYPE_NORMAL
- en: All the Python programs and files in this chapter are available at [https://github.com/PacktPublishing/Artificial-Intelligence-By-Example-Second-Edition/tree/master/CH06](https://github.com/PacktPublishing/Artificial-Intelligence-By-Example-Second-Edition/tree/master/CH0).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a Jupyter notebook named `COLAB_Translate.ipynb` that contains
    all of the Python programs in one run. You can upload it directly to Google Colaboratory
    using your Google account: [https://colab.research.google.com/](https://colab.research.google.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding innovation and disruption in AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first question we must ask ourselves when starting a project such as a translation
    solution is to find out where we fit in. Is what we are going to do an invention
    or an innovation? Is our work disruptive or revolutionary? We will explore these
    concepts in this chapter to understand the broad pragmatic picture before going
    any further.
  prefs: []
  type: TYPE_NORMAL
- en: Is AI disruptive?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word "disruptive" is more often than not associated with artificial intelligence.
    Media hype tells us that AI robots will soon have replaced humans around the world.
    Although media hype made it much easier to obtain AI budgets, we need to know
    where we stand if we want to implement an AI solution. If we want to innovate,
    we need to find the cutting edge and build new ideas from there.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just plunge into the tools and see what happens? Is that a good idea
    or a risky one? Unlike corporations with huge budgets, a single human has limited
    resources. If you spend time learning in the wrong direction, it will take months
    to gather enough experience in another, better direction to reach your goal. For example,
    suppose you have trouble classifying large amounts of data, as we explored in
    *Chapter 4*, *Optimizing Your Solutions with K-means Clustering*. You will spend
    months on a project in your company and fail. It could cost you your job. Conversely,
    if you find the right model and learn the key concepts, your project can take
    off in a few days.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into a project, find out where we stand in terms of innovation
    and disruption. This doesn't seem important at the start of a project, but it
    will mean a lot during the production and distribution phases. This section will
    clarify these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing is new under the sun—not even when considering AI. Most AI theory and
    mathematical tools have been around for decades, if not centuries. We often tend
    to think that since something appears new to us, it has just been invented or
    discovered. This mistake can prove fatal in many projects. If you know that a
    theory or function has been around for decades or centuries, you can do some deep
    research and use solutions found 100+ years ago to solve your present problems.
    If you do, you will save a lot of time using equations that have been proven and
    are reliable. If you do not, you might spend useless vital time reinventing equations
    that exist.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out what is new and what is not will make a major difference in your
    personal or professional AI projects.
  prefs: []
  type: TYPE_NORMAL
- en: AI is based on mathematical theories that are not new
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AI theory presently relies heavily on applied mathematics. In *Chapter 1*, *Getting
    Started with Next-Generation Artifcial Intelligence through Reinforcement Learning*,
    the **Markov decision process** (**MDP**), a **reinforcement learning** (**RL**)
    approach was described. Google has been successfully combining RL with neural
    networks in AlphaGo Zero.
  prefs: []
  type: TYPE_NORMAL
- en: Andrey Markov was a Russian mathematician born in 1856 who invented the MDP.
    He successfully applied the algorithm to letter predictions in a word sequence
    in a given language, for example. Richard Bellman published an enhanced version
    of the MDP in 1957.
  prefs: []
  type: TYPE_NORMAL
- en: Bellman also coined the expression "curse of dimensionality" and published books
    on mathematical tools widely used today in AI. It is now well known that dimensionality
    reduction can be performed to avoid facing thousands of dimensions (features,
    for example) in an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The logistic function (see *Chapter 2*, *Building a Reward Matrix – Designing
    Your Datasets*) can be traced back to Pierre François Verhulst (1844-1845), a
    Belgian mathematician. The logistic function uses *e*, the natural logarithm base,
    which is also named Euler's number. Leonhard Euler (1707-1783) is a Swiss mathematician
    who worked on this natural logarithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thomas Bayes (1701-1761) invented the theorem that bears his name: Bayes''
    Theorem. It is widely used in AI. We will be using it in *Chapter 7*, *Optimizing
    Blockchains with Naive Bayes*.'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all of the applied mathematics in artificial intelligence, machine learning,
    and deep learning can be traced from 17th century to 20th century mathematicians.
    We must look elsewhere for 21st century AI innovations. We need to find what is
    truly new in AI, which is also what helped it expand so rapidly in the early 21st
    century.
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks are not new
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Neural networks, as described by contemporary experts, date back to the 1940s
    and 1950s. Even **convolutional neural networks** (**CNNs**) date back to the
    20th century. Yann LeCun, a French computer scientist, laid down the basics of
    a CNN (see *Chapter 9*, *Abstract Image Classifcation with Convolutional Neural
    Networks (CNNs)*) in the 1980s; he successfully applied them as we know them today
    in the 1990s.
  prefs: []
  type: TYPE_NORMAL
- en: We must again look elsewhere for 21st century AI innovations.
  prefs: []
  type: TYPE_NORMAL
- en: If neural networks are not new either, we must find the real new factors in
    our environment that produced the success of present-day AI.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at disruption – the factors that are making AI disruptive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the foundations of AI find their roots long before computers existed
    or were widespread, it is only recently that we have seen AI truly begin to cause
    waves within our society. In the following sections, we'll look at factors that
    have come together to make AI a powerful force of disruption in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud server power, data volumes, and web sharing of the early 21st century
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to understand what has driven the emergency of AI in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: Data volumes drive the emergence of AI in the 21st century. Processing data,
    classifying data, and making predictions and decisions would be impossible without
    AI driving the entire computer science market.
  prefs: []
  type: TYPE_NORMAL
- en: If you leave the fantasy surrounding AI behind you and bear this key necessity
    for AI in mind, you will perfectly understand why AI has emerged and is here to
    stay.
  prefs: []
  type: TYPE_NORMAL
- en: The first sign of AI's innovative disruption appeared between the years 2000
    and 2010\. Before then, the internet existed, and servers existed. But, starting
    from around 2005, cloud servers were made widely available. With that kind of
    computing power, developers around the world could try using the highly greedy
    resources required by machine learning and deep learning. They could finally solve
    otherwise impossible big data problems using AI.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, as powerful servers became available, the internet provided
    the largest library of knowledge in the history of humanity.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, social networking became widely used. Sharing discoveries and
    source code became commonplace. The World Wide Web (WWW) encouraged open source
    software, boosting local research and development.
  prefs: []
  type: TYPE_NORMAL
- en: The era of artificial intelligence became possible for local experts starting
    from the middle of the first decade of the 21st century.
  prefs: []
  type: TYPE_NORMAL
- en: What makes AI appear as an innovation today is the conjunction of more powerful
    machines and the availability of intellectual resources.
  prefs: []
  type: TYPE_NORMAL
- en: Public awareness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Public awareness of AI remained dim for several years after the cloud architectural
    revolution occurred from around 1995 to 2005.
  prefs: []
  type: TYPE_NORMAL
- en: AI hit us hard by around 2015 when we all woke up realizing that AI could massively
    replace humans and create job displacement at levels never before seen in human
    history.
  prefs: []
  type: TYPE_NORMAL
- en: Worse, we realized that machines could beat us in fields we took pride in, such
    as chess (*Chapter 3*, *Machine Intelligence – Evaluation Functions and Numerical
    Convergence*), the game of Go, and video games. We see manufacturing jobs increasingly
    performed by robots, office jobs being done by bots, and more fields that are
    appearing every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first time in human history, the human species can be surpassed by
    a new "species": smart bots. As developers, we thought we were safe until Google
    presented AutoML, a solution that could create machine learning solutions better
    than humans. At the same time, ready-to-use machine learning platforms have spread
    that can reduce and even replace AI software development.'
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence inspires both awe and fear. How far will machines go?
    Will we simply experience job displacement, or will it go as far as species replacement?
  prefs: []
  type: TYPE_NORMAL
- en: Could this be an opportunity for many? Who knows? In any case, this chapter
    provides some guidance to help you to think in a way that drives you to be constantly
    innovating and being useful. In the age of Big Data, where we are often faced
    with huge datasets, AI is here to stay; we won't be able to cope without it. Let's
    make the most of it!
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin to look into the incredible opportunities provided by AI, let's
    clarify in our minds what exactly the differences are, first between *invention*
    and *innovation*, and then *revolution* versus *disruption*. It is important to
    understand the impact that what we are developing and implementing will have on
    the AI market.
  prefs: []
  type: TYPE_NORMAL
- en: Inventions versus innovations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some AI programs, especially deep learning algorithms, remained inventions and
    not innovations until Google and other major players used them on a large scale.
  prefs: []
  type: TYPE_NORMAL
- en: If you have invented a better algorithm than Google for some applications, it
    remains an invention until it actually *changes* something in your corporation
    or on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you find a quicker way to recognize an image through an optimized number
    of neurons and a new activation function. If nobody uses it, then that invention
    remains a personal theoretical finding no matter how good it appears.
  prefs: []
  type: TYPE_NORMAL
- en: When others begin to use this new algorithm, then it becomes an innovation.
    An invention becomes an innovation only when it changes a process within a company
    or by a sufficient number of private users.
  prefs: []
  type: TYPE_NORMAL
- en: Revolutionary versus disruptive solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose a new image recognition algorithm becomes an innovation in a significant
    corporation. This new algorithm has gone from being an **invention** (not used)
    to an **innovation** (a solution making a difference).
  prefs: []
  type: TYPE_NORMAL
- en: The corporation now widely uses the algorithm. Every subsidiary has access to
    it. For this corporation, the new image recognition algorithm has attained a revolutionary
    status. Corporate sales have gone up, and profit margins have as well.
  prefs: []
  type: TYPE_NORMAL
- en: But maybe this corporation does not dominate the market, and nobody has followed
    its example. The innovation remains revolutionary but has not become disruptive.
  prefs: []
  type: TYPE_NORMAL
- en: Then, let's say the person who created the algorithm decides to leave the company
    and start a business with the algorithm. It appears on GitHub as an open source
    program. Everybody wants it and the number of downloads increases daily until
    1,000,000+ users have begun to implement it. Some very low-priced add-ons are
    provided on the company website. Within a year, it becomes a new way of recognizing
    images. All companies must follow suit or lag behind. The solution has become
    **disruptive** because it has changed its market on a global scale.
  prefs: []
  type: TYPE_NORMAL
- en: Where to start?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now explored the basic concepts of creating AI. The first step in a
    translation project using Google Translate is to take the algorithm as far as
    possible using Google's API. As we will see in the next section, we will explore
    the limits of Google Translate. Once the limit is found, creativity kicks in when
    we customize Google Translate using AI.
  prefs: []
  type: TYPE_NORMAL
- en: We will discover that even if a solution exists, it has limits and can be improved,
    customized, packaged, and sold. *If there is a limit, there is a market*.
  prefs: []
  type: TYPE_NORMAL
- en: Never criticize the flaws you find in an AI solution; they are gold mines!
  prefs: []
  type: TYPE_NORMAL
- en: '*Where there is a limit, there is an opportunity*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go to the cutting edge and then over the border into uncharted territory
    using Google Translate to illustrate this.
  prefs: []
  type: TYPE_NORMAL
- en: Discover a world of opportunities with Google Translate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with Google Translate to explore NLP is a good way to prepare to use
    NLP in web solutions. Any disruptive web-based solution must be able to run in
    at least a few languages. You will need to master NLP in several languages to
    implement a chatbot, a translation solution, and online information sites such
    as Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: Google provides many resources to use, explore, or improve Google Translate.
    Getting a Python code to run and then assess the quality of the results will prove
    vital before implementing it for crucial translations in a company. Let's get
    Google Translate running.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Google''s developers'' API client library page is as follows: [https://developers.google.com/api-client-library/](https://developers.google.com/api-client-library/).
    On this page, you will see libraries for many languages: Java, PHP, .NET, JavaScript,
    Objective-C, Dart, Ruby and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, go to the Python resources and follow the instructions to sign up, create
    a project in the Google API Console, and install the library.
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter problems doing this part or do not wish to install anything
    yet, this chapter is self-contained. The source code is described in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to go, irrespective of whether you installed the tools.
  prefs: []
  type: TYPE_NORMAL
- en: The program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this section is to implement Google Translate functionality. You
    can implement and run the program or first simply read the self-contained section.
  prefs: []
  type: TYPE_NORMAL
- en: The header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard Google header provided by Google should be enough to get the API
    to work, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Considering the many languages Google manages, special characters are a major
    problem to handle. Many forums and example programs on the web struggle with the
    `UTF-8` header when using Google Translate. Many solutions are suggested, such
    as the following source code header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, when Google Translate returns the result, more problems occur, and many
    develop their own functions. They work fine, but I was looking for a straightforward
    one-line solution. The goal here was not to have many lines of code but focus
    on the limit of Google Translate to discover the cutting-edge interpreting languages
    in AI.
  prefs: []
  type: TYPE_NORMAL
- en: So, I did not use the `UTF-8` header, but implemented it using the HTML library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When confronted with a result, the following one-line HTML parser code did the
    job.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It works well because Google will return an HTML string or a text string depending
    on what option you implement. This means that the HTML module can do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Google's translation service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Google''s translation service needs at least three values to return a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '`developerKey`: This is the API key obtained at the end of the getting-started
    process described previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`q="text to translate"`: In my code, I used `source`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target="abbreviation of the translated text"`: `en` for English, `fr` for
    French, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More options are available, as described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, the translation function will work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Google_translate.py` program, `q` and `target` will be sent to the
    function to obtain a parsed result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up the program, let''s translate Google Translate into French, which
    contains accents parsed by the HTML parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Google_Translate.py` works fine. The result will come out with the correct
    answer and the parsed accent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, Google Translate satisfies a black box exploration approach.
    It is disruptive, has changed the world, and can replace translators in many corporations
    for all corporate needs.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we could end the chapter here, go to our favorite social network, and
    build some hype on our translation project.
  prefs: []
  type: TYPE_NORMAL
- en: Happy ending?
  prefs: []
  type: TYPE_NORMAL
- en: Well, not yet!
  prefs: []
  type: TYPE_NORMAL
- en: We need to explore Google Translate from a linguist's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Google Translate from a linguist's perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A linguist's approach to the program will involve a deeper, white box sort of
    exploration. The method will reveal many areas to improve.
  prefs: []
  type: TYPE_NORMAL
- en: By the time this book is published, perhaps Google will have improved the examples
    in this chapter. But don't worry; in this case, you will quickly find hundreds
    of other examples that are incorrect. The journey has just begun!
  prefs: []
  type: TYPE_NORMAL
- en: Playing with the tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Playing with a tool with random examples can lead to surprising results. This
    exploratory source code is saved as `Google_translate_a_few_test_expressions.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program simulates a dialog created by a person named Usty as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first two examples look fine in French, although the second translation
    is a bit strange. But in the third test, the expression *chercher des poux* means
    *looking for trouble* in English, and not looking for lice, as translated into
    French.
  prefs: []
  type: TYPE_NORMAL
- en: A linguistic assessment of Google Translate will now be made.
  prefs: []
  type: TYPE_NORMAL
- en: Linguistic assessment of Google Translate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assessing Google Translate correctly will lead directly to its limits.
  prefs: []
  type: TYPE_NORMAL
- en: Limits are the boundaries researchers crave! We are frontiersmen!
  prefs: []
  type: TYPE_NORMAL
- en: An expert-level assessment will lead the project team to the frontier and beyond.
    To do this, we will first explore some linguistic methods.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical field theory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lexical fields describe word fields. A word only acquires its full meaning when
    interpreted within a context. This context often goes beyond a few other words
    or even a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chercher des poux* translated as such means *look for lice*. But in French,
    it can mean *looking for trouble* or literally *looking for lice*. The result
    that Google Translate comes up with contains three basic problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Problem 1 – the lexical field**: There is no way of knowing whether this
    means looking for lice or looking for trouble without a context.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 2 – metaphors or idiomatic expressions**: Suppose you have to translate
    *this is giving you a headache*. There is no way of knowing whether it is a physical
    problem or a metaphor meaning *this is driving you crazy*. These two idiomatic
    expressions happen to have the same metaphors when translated into French. But
    the *lice* metaphor in French means nothing in English.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 3**: *chercher* is an infinitive in French, and the result should
    have been *looking* for lice in English. But entering *chercher des limites est
    intéressant* provides the right verb form, which is *looking for*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The answer is correct because *is* splits the sentence into two, making it easier
    for Google Translate to identify *chercher* as the first part of a sentence, thus
    using *looking* in English.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical fields vary from language to language, but so does jargon.
  prefs: []
  type: TYPE_NORMAL
- en: Jargon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Jargon arises when fields specialize. In AI, the expression *hidden neurons*
    is jargon. This expression means nothing to a lawyer, for example. A lawyer may
    think you have hidden intelligence on the subject somewhere or are hiding money
    in a cryptocurrency named hidden neuron.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, if somebody asks an AI expert to explain the exact meaning
    of *filing a motion*, that would prove difficult.
  prefs: []
  type: TYPE_NORMAL
- en: In a corporate legal environment, beyond using Google Translate as a dictionary,
    translating sentences might be risky if only a random number of results prove
    to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: If we add the jargon variations to the lexical variations from one language
    to another, we can see that word-to-word translation does not work when a word
    is in a context. Translating is thus more than just finding the most similar words
    in the language we are translating to.
  prefs: []
  type: TYPE_NORMAL
- en: Translating is not just translating but interpreting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, translating requires interpreting, as shown with the following sentence
    taken from a standard description of French commercial law:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The French sentence refers to a type of company; SAS is similar to company types
    like inc., ltd., and so on. In English, SAS means Special Air Service. Then comes
    the grammar, which does not sound right.
  prefs: []
  type: TYPE_NORMAL
- en: 'A translator would write better English and also specify what an SAS is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An SAS (a type of company in France) must follow the recommendations that
    cover commercial practices.*'
  prefs: []
  type: TYPE_NORMAL
- en: Translating often means interpreting, and not simply translating words.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a legal translator may interpret the text in a contract and go
    as far as writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The COMPANY must respect the legal obligation to treat all customers fairly.*'
  prefs: []
  type: TYPE_NORMAL
- en: The legal translator will suggest that *COMPANY* be defined at the beginning
    of the contract to avoid confusion, such as the one Google Translate just made.
  prefs: []
  type: TYPE_NORMAL
- en: When reading about NLP, chatbots, and translation, everything seems easy. However,
    working on Google Translate can easily turn into a nightmare!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Google Translate provides the output in French:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In French, as in English, it is better to say *project team* and not use *of*
    to say the *team of the project*. In French, we have *équipe projet* (équipe (team)
    appears before project).
  prefs: []
  type: TYPE_NORMAL
- en: 'From our examples so far, we can see that Google Translate is:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes wrong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes partly correct and partly wrong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem now is how to know which category a translation is in.
  prefs: []
  type: TYPE_NORMAL
- en: How to know whether a translation is correct
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can you check a translation if you do not know the language?
  prefs: []
  type: TYPE_NORMAL
- en: Be careful. If Google Translate provides randomly correct answers in another
    language, then you have no way of knowing whether the translation is reliable
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: If you can't be confident that Google Translate is going to be correct, you
    may find yourself in difficult situations; even sending the opposite of what you
    mean to somebody important to you. You may misunderstand a sentence you are trying
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a transportation company, for example, you could write an email stating
    that the coach stopped and people were complaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Google Translate, for lexical field reasons, got it wrong and translated *coach*
    as a sports trainer in French, which would give a completely different meaning
    to the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, the situation can get worse. To help Google Translate, let's add some context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This answer is worse. Google Translate translates *broke down* correctly with
    the French expression *en panne* but still translates *coach* as *entraineur*
    (trainer) in French, meaning the *trainer* broke down, not the *coach* (bus).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Google will no doubt continue to improve the program as it has done since 2006\.
    For now, however, a human translator will find hundreds of expressions Google
    Translate cannot deal with yet.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a sentence in your native language can prove difficult when a
    word or an expression has several meanings. Adding a translation function to the
    issue makes it even more difficult to provide a reliable answer.
  prefs: []
  type: TYPE_NORMAL
- en: And that is where we reach the frontier, just beyond the cutting edge, as we
    have established the limits of Google Translate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at some ways we could improve standard Google
    Translate results. Although no silver bullet exists to verify a translation, we
    will explore methods to improve the process. We will find a way to improve Google
    Translate and implement it.
  prefs: []
  type: TYPE_NORMAL
- en: AI as a new frontier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google has a great, but limited, translation program. Use the flaws to innovate!
    AI research and development has just scratched the surface of the innovations
    to come.
  prefs: []
  type: TYPE_NORMAL
- en: First, implement an AI solution. Then, use it for what it is. But don't accept
    its limits. Don't be negative about it. Innovate! Imagine ideas or listen to other
    ideas you like and build solutions in a team! Google might even publish your solutions!
  prefs: []
  type: TYPE_NORMAL
- en: Improving Google Translate for any translation is impossible. A realistic approach
    is to focus on customizing Google Translate for a given domain, such as the transportation
    company in this example. In the next section, we will focus on ways to customize
    Google Translate.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical field and polysemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Google_Translate_Customized.py` will provide ideas on how to improve Google
    Translate in a specific area. This section focuses on the transportation vocabulary
    error Google Translate made. Once again, Google may rapidly correct this error,
    but the method can be applied to the many remaining errors.'
  prefs: []
  type: TYPE_NORMAL
- en: A **lexical field** contains words that form sets and subsets. They differ from
    one language to another. A language itself forms a set and contains subsets of
    lexical fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Colder countries have more words describing water in its frozen form than tropical
    countries where snow hardly ever falls. A lexical field of cold could be a subset
    of *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C* = {*ice*, *hail*, *snowflakes*, *snowman*, *slushy*, *powder*, *flake*,
    *snowball*, *blizzard*, *melting*, *crunch* … *n*}'
  prefs: []
  type: TYPE_NORMAL
- en: The curse of dimensionality applies here. Words contain an incredible number
    of dimensions and definitions. To translate certain expressions, Google Translate
    suppresses their dimensions and reduces them.
  prefs: []
  type: TYPE_NORMAL
- en: Google Translate often uses n-grams to translate. An n-gram is a fixed-length
    sequence of tokens. Tokens can be a word, a character, or even a numerical representation
    of words and characters.
  prefs: []
  type: TYPE_NORMAL
- en: The probability that token *n* means something is calculated given the preceding/following
    *n* – *x* or *n* + *x* tokens. *x* is a variable depending on the algorithm applied.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *slushy* has a special meaning in the expression *slushy snow*.
    The snow is partly melting, it's watery and making a *slushing* sound when we
    walk through it. Melting is only one component of the meaning of *slush*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Translate, at this point, will only translate *slushy snow* in French
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*neige* (snow) *fondante* (melting)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Translate will also translate *melting snow* by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*neige* (snow) *fondante* (melting)'
  prefs: []
  type: TYPE_NORMAL
- en: To translate *slushy* into French, you have to use a phrase. To find that phrase,
    you need some imagination or have some parsed (searched) novels or other forms
    of speech representations. That takes time and resources. It will most probably
    take years before Google Translate reaches an acceptable native level in all the
    languages publicized.
  prefs: []
  type: TYPE_NORMAL
- en: Another dimension to take into account is polysemy.
  prefs: []
  type: TYPE_NORMAL
- en: Polysemy means a word can have several very different meanings in a language.
    The equivalent word in another language may simply have one meaning or other,
    very different meanings.
  prefs: []
  type: TYPE_NORMAL
- en: '"Go + over" in English can mean *go over a bridge* or *go over some notes*.
    At this point (hopefully it will improve by the time you read this book), it is
    translated in both cases in French by *aller sur*. This means to go on (not over),
    which is incorrect in both cases. Prepositions in English constitute a field in
    themselves, generating many meanings with the same word. The verb *go* can have
    a wide list of meanings: *go up* (upstairs), *go up* (stock market), *go down*
    (downstairs), *go down* (fall apart), and many more possibilities besides.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototype customized program starts with defining `X`. A small dataset
    to translate that will be more than enough to get things going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you find spelling mistakes or minor mistakes, do not correct them during
    the training phase. Some amount of noise is required to reproduce human and machine
    errors to avoid overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: Google Translate will automatically translate these sentences.
  prefs: []
  type: TYPE_NORMAL
- en: '`X1`, as implemented in the following code, defines some keywords statistically
    related to the sentences; it applies the n-gram probability theory described previously.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each line in `X1` goes with the corresponding line in `X`. As explained, this
    only remains a probability and may not be correct.
  prefs: []
  type: TYPE_NORMAL
- en: '*We are not seeking perfection at this point but an improvement.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how we can improve Google Translate by customizing translations
    by implementing a KNN in a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the frontier – customizing Google Translate with a Python program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to add some customized novelties. The use of the vectors in this
    section will be explained in the next section, again through the source code that
    uses them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A trigger vector will force the program to try an alternate method to translate
    a mistranslated sentence. When the sentence has been identified, and if its value
    in `X2` is equal to `1`, it triggers a deeper translation function, as implemented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`0` and `1` are flags. Each value represents a line in `X`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note for developers**: To use this method correctly, all the values of this
    vector should be set to `1`. That will automatically trigger several alternate
    methods to translate Google Translate errors. A lot of work remains to be done
    here!'
  prefs: []
  type: TYPE_NORMAL
- en: The example is taken from a transportation business. A transportation phrase
    dictionary should be built. In this case, a general `phrase_translation` dictionary
    has been implemented with one expression, as shown in the following array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What remains to be done in order to fill up this dictionary?
  prefs: []
  type: TYPE_NORMAL
- en: Scan all the documents of the company—emails, letters, contracts, and every
    form of written documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the embedded words and sentences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Train the team to use the program to improve it by providing feedback (the right
    answer) in a learning interface when the system returns incorrect answers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Google Translate cannot do on a global scale, you can implement at a local
    scale to improve the system significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined a method, we will dig into the KNN algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: k-nearest neighbor algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No matter how you address a linguistic problem, it will always boil down to
    the concept of **context**. When somebody does not understand somebody else, they
    say: "you took my words out of their context," or "that is not what I meant; let
    me explain."'
  prefs: []
  type: TYPE_NORMAL
- en: As explained before, in many cases, you cannot translate a word or expression
    without a lexical field. The difficulty remains proportional to the polysemy property,
    as the program will show.
  prefs: []
  type: TYPE_NORMAL
- en: Using the KNN algorithm as a classification method can prove extremely useful.
    Any language interpretation (translation or chatbot) will have to use a context-oriented
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: By finding the words closest (neighbors) to each other, KNN will create the
    lexical fields required to interpret a language. Even better, when provided with
    the proper datasets, it will solve the polysemy problem, as shown in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KNN algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, a word requires a context to mean something. Looking for "neighbors"
    close by provides an efficient way to determine where the word belongs.
  prefs: []
  type: TYPE_NORMAL
- en: KNN is supervised because it uses the labels of the data provided to train its
    algorithm. KNN, in this case, is used for classification purposes. For a given
    point *p*, KNN will calculate the distances to all other points. Then, *k* represents
    the k-nearest neighbors to take into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clear this up by means of an example. In English, the word "coach" can
    mean a trainer on a football field, a bus, or a railroad passenger car. In a transportation
    company, "coach" will mostly be a bus that should not be confused with a trainer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Parsing (examining in a detailed manner) texts with "coach" as
    a bus and "coach" as a trainer. Thus, the program is searching for three target
    words: trainer, bus, and coach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2**: Finding some words that appear close to the target words we are
    searching for. As recommended, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse all the company documents you can use with a standard program.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a Python function such as `if(n-gram in the source)` then store the data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, the `V1.csv` file shown in the following output excerpt provided
    with the source code contains the result of such a parsing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating files such as `V1.csv` is not in the scope of this chapter or book.
    However, you can start, among other sites, by exploring scikit-learn''s text document
    functionality at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html](https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The program parsed emails, documents, and contracts. Each line represents the
    result of parsing one document. The numbers represent the occurrences (number
    of times the word was present). The numbers have been "squashed" (divided again
    and again) to remain small and manageable. For more on how to work with text data,
    please click on the scikit-learn link in the previous paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Progressively, the words that came out with "trainer" were "shouted" more than
    "stopped." For a bus, "broke" (broken down as in breaking down), "road," and "stopped"
    appeared more than "shout."
  prefs: []
  type: TYPE_NORMAL
- en: '"Coach" appeared on an average of "shouted," "stopped," "road," and "broke"
    because it could be either a trainer or a bus, hence the problem we face when
    translating this word. The polysemy (several meanings) of "coach" can lead to
    poor translations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The KNN algorithm loaded the `V1.csv` file that contains the data to be trained
    and finds the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_08_01-1.png](img/B15438_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Result from the KNN algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `knn_polysemy.py` program determined the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The verb "broke" in blue has a better chance of applying to a bus (*x* axis
    value > 6) than to a trainer (*x* axis value < 4). However, "coach" remains above
    "trainer" and below "bus" because it can be both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word "road" follows the same logic as the blue chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verb "stopped" can apply to a trainer and more to a bus. "Coach" remains
    undecided again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verb "shouted" applies clearly to a trainer more than a bus. "Coach" remains
    undecided again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the coordinates of each point in these charts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**y axis**: bus = 1, coach = 2, and trainer = 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x axis**: The value represents the "squashed" occurrence (the number of times
    the word appeared) values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the result of the search for those words in many sources.
  prefs: []
  type: TYPE_NORMAL
- en: When a new point, a data point named *P*[n] is introduced into the system, it
    will find its nearest neighbor(s) depending on the value of *k*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The KNN algorithm will calculate the Euclidean distance between *P*[n] and
    all the other points from *P*[1] to *P*[n] [– 1] using the Euclidean distance
    formula. The *k* in KNN represents the number of "nearest neighbors" the algorithm
    will take into account for classification purposes. The Euclidean distance (*d*[1])
    between two given points, for example, between *P*[n](*x*[1], *y*[1]) and *P*[1](*x*[2],
    *y*[2]), is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_06_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Considering the number of distances to calculate, a function such as the one
    provided by `sklearn.neighbors` proves necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The knn_polysemy.py program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The program imports the `V1.csv` file described previously, prints a few lines,
    and prepares the labels in the correct arrays in their respective *x* axis and
    *y* axis, as shown in this source code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the model is trained, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the model is trained, a prediction is requested and is provided by the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial data is plotted for visualization purposes, as implemented in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A compressed version of this program has been introduced in `Google_Translate_Customized.py`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`polysemy` is the name of the file to read because it can be any file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vpolysemy` is the vector that needs to be predicted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In future, in the to-do list, `begin` should replace `broke` and `end` should
    replace `shouted` so that the function can predict the values of any vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KNN classifier is called and the prediction returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have prepared the KNN classifier function, we can customize Google
    Translate.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KNN function in Google_Translate_Customized.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This program requires more time and research because of the concepts of linguistics
    involved. The best way to grasp the algorithm is to run it in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Translate offers various translation methods. We will focus on two of
    them in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phrase-based machine translation (PBMT)**: This translates the whole sequence
    of words. The phrase, or rather phraseme (multi-word expression), is not always
    quite a sentence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neural machine translation (NMT)**: This uses neural networks such as a **recurrent
    neural network** (**RNN**), which will be detailed later in this book. This method
    goes beyond the phraseme and takes the whole sentence into account. In terms of
    the dataset presented in this chapter, this neural network method provides slightly
    better results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods and Google's other approaches are interesting, but Google Translate
    still requires additional customized algorithms to reach an acceptable level of
    quality in many cases. In this chapter, we are exploring one approach with a KNN,
    but you can use others as long as they work.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen so far, the subject is extremely complex if you take the lexical
    fields and structures of the many languages, their regional variations, and jargon
    into account.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – translating the X dataset line by line from English into French
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code calls the translation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xi` is the line number in `X`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source` is the `xi` line in `X`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetl` is the target language, in this case, `fr` (French).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m` is the method (PBMT or NMT), as described previously. In this case, `nmt`
    is applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the Google Translate function is called as described earlier in this chapter.
    The result is stored in the `result` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – backtranslation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can somebody know the correctness of a translation from language *L*[1]
    to language *L*[2] if *L*[1] is the person's native language, and *L*[2] is a
    language the person does not understand at all?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the reasons, among others, that translators often use backtranslation
    to check translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Translation* = *Initial translation from L*[1] *to L*[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '*Backtranslation* = *Translation back from L*[2] *to L*[1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the initial text is not obtained, then there is probably a problem. In this
    case, the length of the initial sentence *L*[1] can be compared to the length
    of the same sentence translated back to *L*[1]. The following code calls backtranslation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Length comparison can be used to improve the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Length of the initial n-gram* = *Length of the backtranslation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s equal, then the translation may be correct. If not, it could be incorrect.
    Of course, more methods must be applied during each translation. However, a method
    that leads to improvement is already a good step. In this case, the source (initial
    sentence) is compared to the backtranslation in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`t` is a `True` counter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` is a `False` counter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first line of `X` runs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Eating fatty food* is backtranslated as *eating fat food*, which is slightly
    wrong. Something may be wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: The French sentence sounds wrong, too. Fatty food cannot be translated as such.
    Usually, the common sentence is *manger gras*, meaning *eating* (manger) *fatty*
    (gras), which cannot be translated into English as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `X` array referred to in this section starts at line 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Several phrases come back with a false translation, for example, `X[4]`, `'He
    had a chip on his shoulder'`. I programmed a phrase-based translation using a
    trigger in the `False` condition in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Since I did not write a complete application for this book, but just some examples
    that can be extended in the future, I used `X2` as a trigger. If `X2[x1]>0`, then
    the `deeper_translate` function is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – deeper translation with phrase-based translations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`deeper_translate` has two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: The initial sentence to translate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x1`: The target sentence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, the problem to solve is an idiomatic expression that exists in
    English but does not exist in French:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To have *a chip on the shoulder* means to have an issue with something or somebody.
    It expresses some form of tension.
  prefs: []
  type: TYPE_NORMAL
- en: Google translated *chip* by assuming computer chip, or *puce* in French, which
    means both *computer chip* and *flea*. The translation is meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chip* enters three categories and should be labeled as such:'
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jargon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polysemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the following function I created simulates the phrase-based solution
    to implement deeper translations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `deeper_translate` function looks for the translated sentence containing
    *chip* in the following `phrase_translation` array (list, vector, or whatever
    is necessary).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result comes out with a translation, backtranslation, term search,
    and phrase translation. The following is the result produced, with comments added
    here before each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The question is, where did `term` come from?
  prefs: []
  type: TYPE_NORMAL
- en: '`term` comes from `X1`, a list of keywords that should be in the translation.
    `X1` has been entered manually, but it should be a list of possibilities resulting
    from an automatic search conducted on the words in the sentence viewed as classes.
    This means that the sentence to be translated should have several levels of meaning,
    not just the literal one that is being calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual `True`/`False` conditions contain the following deeper translation-level
    words to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the present state of the prototype, only example four activates a phrase-based
    translation. Otherwise, `True` is accepted. If `False` is the case, the deeper
    translation is only activated for two cases in this sample code. The flag is in
    `X2` (`0` or `1`).
  prefs: []
  type: TYPE_NORMAL
- en: '`deeper_translate` is called for either the phrase-based translation (described
    previously) or the KNN routine, which is activated if the phrase-based translation
    did not work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the translation did not work, an n-gram is prepared for the KNN algorithm,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`V1[i]` contains the keywords (n-grams) described in the preceding KNN algorithm
    for the transport lexical field, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The source (sentence to translate) is parsed for each n-gram. If the n-gram
    is found, the polysemy vector is activated for that n-gram. The initial values
    are set to `0`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The variable `v1` is activated, which informs the program that `V1.csv` must
    be read for this case. An unlimited number of KNN references should be automatically
    created, as described previously in the KNN section.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, only `v1` is activated. But after several months of working on
    the project for the company to customize their local needs, many other files should
    be created.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, when `v1` is activated, it fills out the variables as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`polysemy` indicates the KNN file to open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`begin` is the first label of the `V1` vector and `end` is the last label of
    the `V1` vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sememe` is the prediction we expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, a condensed version of the KNN algorithm is called, as described previously
    for `knn_polysemy.py`, in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The example, in this case, is the polysemy feature of *a coach*, as explained
    in the KNN section. The output will be produced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The translation is false because Google Translate returns *trainer* instead
    of *bus*.
  prefs: []
  type: TYPE_NORMAL
- en: The term *bus* is identical in English and French.
  prefs: []
  type: TYPE_NORMAL
- en: The KNN routine returned *bus* in English as the correct word to use when *broke
    down* and *stopped* were found, as shown in the KNN section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the rest of the source code in the `deeper_translate` function
    is to replace *coach*—the word increasing the polysemy feature to translate—with
    a better word (limited polysemy) to translate: `sememe`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sememe` variable is initialized by the KNN function in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The function replaces *coach* by *bus* found by the KNN algorithm in the English
    sentence and then asks Google Translate to try again. The correct answer is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of trying to translate a word with too many meanings (polysemy), the `deeper_translate`
    function first replaces the word with a better word (less polysemy). Better results
    will often be attained.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3.1 – adding a frequentist error probability function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A frequentist error probability function is added to measure performance, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`cnumber` is the number of false answers returned by Google Translate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tnumber` is the number of sentences translated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ff` gives a straightforward error (translation) probability, ETP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function is called when a translation is false, or `f>0`, as implemented
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`B1` is the error (translation) probability (ETP) before the `deeper_translate`
    function is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`B2` is the ETP after the `deeper_translate` function is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of the program, a summary is displayed, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A subjective acceptance of an approximate result has been added to increase
    the true probability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error rate should decrease as the quality of the KNN knowledge base increases.
    In frequent probability theory, this means that a stabilized prediction rate should
    be reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've come to the end of our attempts to improve Google Translate. Let's consider
    some of the conclusions following our experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions on the Google Translate customized experiment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final error (translation) probability produced is interesting, as shown
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Even with its NMT model, Google Translate is still struggling.
  prefs: []
  type: TYPE_NORMAL
- en: This provides great opportunities for AI linguists, as shown with some of the
    methods presented to improve Google Translate at a local level that could go even
    further.
  prefs: []
  type: TYPE_NORMAL
- en: This experiment with Google Translate shows that Google has just scratched the
    surface of real-life translations that sound right to the native speakers that
    receive these translations. It would take a real company project to get this on
    track with a financial analysis of its profitability before consuming resources.
  prefs: []
  type: TYPE_NORMAL
- en: The disruptive revolutionary loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can now see, Google Translate, like all AI solutions, has its limits.
    Once this limit has been reached, you are at the cutting edge.
  prefs: []
  type: TYPE_NORMAL
- en: Cross the border into AI Frontierland; innovate on your own or with a team.
  prefs: []
  type: TYPE_NORMAL
- en: If you work for a corporation, you can create a revolutionary customized solution
    for hundreds of users. It does not have to go public. It can remain a strong asset
    to your company.
  prefs: []
  type: TYPE_NORMAL
- en: At some point or other, the revolutionary add-on will reach beyond the company,
    and others will use it. It will become disruptive.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, others will reach the limit of your now-disruptive solution. They will
    then innovate and customize it in their corporation as a revolutionary solution.
    This is what I call the disruptive revolutionary loop. It is challenging and exciting
    because it means that AI developers will not all be replaced in the near future
    by AutoAI bots!
  prefs: []
  type: TYPE_NORMAL
- en: Designing a solution does not mean it will be an invention, an innovation, revolutionary,
    or disruptive. But that does not really matter. What a company earns with a solution
    represents more than the novelty of what it sells as long as it is profitable.
    That is rule number 1\. That said, without innovating in its market, that company
    will not survive through the years.
  prefs: []
  type: TYPE_NORMAL
- en: If a product requires quality for security reasons, it should remain in its
    invention state as long as necessary. If a product can produce sales at the low
    end of the market before its total completion, then the company should sell it.
    The company will acquire a reputation for innovation, get more money to invest,
    and take over the territory of its competitors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Translate is a good example of disruptive marketing. As shown, the theory,
    the model, and even the cloud architecture are over 10 years old. But each time
    one of the hundreds of millions of users stumbles across it, it creates more disruption
    by hooking the user onto Google solutions. The user will come back again and again
    to view more advertisements, and everyone is happy!
  prefs: []
  type: TYPE_NORMAL
- en: AI has only just begun. Google Translate has been around since 2006\. However,
    the results still leave room for developers, linguists, and mathematicians to
    improve upon. Google has added a neural network and offers other models to improve
    translations by analyzing whole sentences. How long will it take to be really
    reliable? In the meantime, the world community is moving AI forward beyond the
    cutting edge into Frontierland.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we first carefully explored the difference between inventing
    and innovation. An innovation has an impact on the rest of the market. An invention
    is just the starting point of an innovation. We saw that a revolutionary solution
    could be a technical breakthrough. But that revolutionary solution will only become disruptive
    when it spreads out to the rest of the market.
  prefs: []
  type: TYPE_NORMAL
- en: We then studied some basic linguistics principles that could help us understand
    Google Translate, its limits, and how to improve translation errors.
  prefs: []
  type: TYPE_NORMAL
- en: We finally implemented a customized translation tool using a KNN to work around
    Google Translate errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 7*, *Optimizing Blockchains with Naive Bayes*,
    we will go further in our investigation of the new frontier of AI by using blockchains
    to make predictions in corporate environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it better to wait until you have a top-quality product before putting it
    on the market? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Considering the investment made, a new product should always be priced high
    to reach the top segment of the market. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inventing a new solution will make it known in itself. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AI can solve most problems without using standard non-learning algorithms. (Yes
    | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google Translate can satisfactorily translate all languages. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not creative, it is no use trying to innovate. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not a linguist, it is no use bothering with trying to improve Google
    Translate. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Translating is too complicated to understand. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AI has already reached its limits. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Harvard Business Review on disruptive innovations can be found here: [https://hbr.org/2015/12/what-is-disruptive-innovation](https://hbr.org/2015/12/what-is-disruptive-innovation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Translate documentation can be found here: [https://cloud.google.com/translate/docs/](https://cloud.google.com/translate/docs/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google AlphaGo Zero: [https://deepmind.com/blog/article/alphago-zero-starting-scratch](https://deepmind.com/blog/article/alphago-zero-starting-scratch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KNN documentation: [http://scikit-learn.org/stable/modules/neighbors.html#neighbors](http://scikit-learn.org/stable/modules/neighbors.html#neighbors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insights on translation ANNs: [https://research.googleblog.com/2016/09/a-neural-network-for-machine.html](https://research.googleblog.com/2016/09/a-neural-network-for-machine.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insights on English-French translations: [http://www.oneskyapp.com/blog/french-translation-challenges/](http://www.oneskyapp.com/blog/french-translation-challenges/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More on how to work with text data to build datasets for your algorithms: [https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html](https://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
