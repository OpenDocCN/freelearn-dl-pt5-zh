- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Jina’s Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about neural search, and now we can start
    thinking about how to work with it and the steps we’ll need to take to implement
    our own search engine. However, as we saw in previous chapters, in order to implement
    an end-to-end search solution, time and effort will be needed to gather all of
    the resources required. This is where Jina can help as it will take care of many
    of the necessary tasks, letting you focus on the design of your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will understand the core concepts of Jina: **Documents**,
    **DocumentArrays**, **Executors**, and **Flow**. You will see each of them in
    detail and understand their overall design and how they connect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Jina
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DocumentArrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of idioms in
    Jina, what they are, and how to use them. You will use this knowledge later to
    build your own search engine for any type of modality.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A laptop with a minimum of 4 GB of RAM, ideally 8 GB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.7, 3.8, or 3.9 installed on a Unix-like operating system, such as macOS
    or Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Jina
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jina** is a framework that helps you build deep learning search systems on
    the cloud using state-of-the-art models. Jina is an infrastructure that allows
    you to focus only on the areas that you are interested in. In this way, you don’t
    need to be involved in every aspect of building a search engine. This involves
    everything from pre-processing your data to spinning up microservices if needed.
    Another good thing about neural search is that you can search for any kind of
    data regardless of type. Here are some examples of how you can search using different
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Image-to-image search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text-to-image search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Question answering search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own search engine can be very time-consuming, so one of the core
    goals of Jina is reducing the time you would need if you were going to build one
    from scratch. Jina is designed in a layered way that lets you focus only on the
    specific parts that you need, letting the rest of the infrastructure be handled
    in the background. So, for example, you could use pre-trained **Machine Learning**
    (**ML**) models directly instead of building them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Since we live in the era of cloud computing, it makes sense to leverage the
    power that decentralized work can offer, so it is useful to design your solution
    to be distributed on the cloud, and features such as **sharding**, **asynchronizing**,
    and **REST** are fully integrated and work out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already said, another way that Jina helps you reduce the time and
    effort needed while building a search engine is by using the latest state-of-the-art
    ML models. You take advantage of this in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using one of Jina’s plug-and-play models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing your own model from scratch for when you have a specialized use case
    or if there is still no model available on Jina Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these options, you can choose between having a pre-defined model or implementing
    your own if your needs are not covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, all of this means that there are a lot of components working
    in the background. The more you learn, the more power you will have over your
    application, but to start, you will need to understand the basic components of
    Jina, which we will discuss in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DocumentArrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Jina, **Documents** are the most basic data type you can work with. They
    are the data you want to use and can be used for indexing and/or querying. They
    can be made with whatever data type you require, such as text, gifs, PDF files,
    3D meshes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Documents to index and query, but since Documents can be of any
    type and size, it’s likely that we will need to divide them before use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an analogy, think of a Document as a chocolate bar. There are several types
    of chocolate: white, dark, milk, and so on. Likewise, a Document can be of several
    types, such as audio, text, video, a 3D mesh, and so on. Also, if we have a big
    chocolate bar, we will probably divide it into smaller pieces before eating it.
    Accordingly, if we have a big Document, we should divide it into smaller pieces
    before indexing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a Document looks in Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all you need to create a Document is to import it from Jina
    and create it as you would any other object in Python. This is a very basic example,
    but in real life, you will have more complex cases, so we will need to add some
    attributes, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Document attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Document can have different attributes that belong to four main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content**: This refers to the actual content of your Document. For example,
    the text or its embedded vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meta**: This is information about the Document itself. For example, its ID
    and whether it has any tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive**: This tells us how the Document is divided. For example, its
    matches or if it was divided into any chunks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relevance**: This refers to the relevance of the Document, such as its score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These categories consist of various attributes, which are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Attributes** |'
  prefs: []
  type: TYPE_TB
- en: '| Content attributes | `.buffer`, `.blob`, `.text`, `.uri`, `.content`, `.embedding`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Meta attributes | `.id`, `.parent_id`, `.weight`, .`mime_type`, `.content_type`,
    `.tags`, `.modality` |'
  prefs: []
  type: TYPE_TB
- en: '| Recursive attributes | `.chunks`, `.matches`, `.granularity`, `.adjacency`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Relevance attributes | `.score`, `.evaluations` |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Document categories and their attributes
  prefs: []
  type: TYPE_NORMAL
- en: We will see later in more detail what each of those attributes are, but first,
    let’s see how to set them.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and unsetting attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The attributes in *Table 4.1* are the possible attributes we can use with our
    Document. Let’s say we want our Document to have the text `hello world`. We can
    do this by setting its `text` attribute like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we want to unset it, we can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In plenty of real-world cases, we will need to work with multiple attributes,
    and it is also possible to unset several of these at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Accessing nested attributes from tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Jina, each Document contains tags that hold a map-like structure that can
    map arbitrary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to access the nested fields, you can do so by using the attribute
    name with the symbol `__` interlaced. For example, if you would like to access
    the `weight` tag, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Constructing a Document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To construct a Document, you need to fill it with attributes, so let’s take
    a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Content attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each Document needs to contain some information about itself, ranging from
    raw binary content to text info. We can see the details that a Document can have
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.buffer` | The raw binary content of the Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.blob` | The ndarray of the image/audio/video Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.text` | The text info of the Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.uri` | A Document URI could be a local file path, a remote URL that
    starts with http or https, or a data URI scheme |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.content` | This can be any of the previous attributes (buffer, blob,
    text, uri) |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.embedding` | The embedding ndarray of the Document |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 - Content attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways you can assign a *content* type to your Document. If you
    know exactly what type it is, you can assign it explicitly with the `text`, `blob`,
    `buffer`, or `uri` attributes. If you don’t know the type, you can use `.content`,
    which will automatically assign a type to your Document based on what it’s most
    likely to be. See this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`document1` will have a field of `text`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document2` will have a field of `buffer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document3` will have a field of `blob`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document4` will have a field of `uri`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content will be automatically assigned to any one of the `text`, `buffer`,
    `blob`, or `uri` fields. The `id` and `mime_type` attributes are auto-generated
    when not set explicitly. This means that you can specify explicitly the ID and
    type (`mime_type`) of your document, otherwise it will be autogenerated.
  prefs: []
  type: TYPE_NORMAL
- en: Exclusivity of doc.content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Jina, each Document can only contain one type of content: `text`, `buffer`,
    `blob`, or `uri`. Setting `text` first and then setting `uri` will clear the `text`
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, you can see the different types that content can have,
    as well as the fact that each Document can only have one type.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Possible content types in a Document ](img/Figure_4.1_B17488.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Possible content types in a Document
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we would set the `content` attribute of a Document in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see how you can set every type of attribute in a Document, but if you
    assign different values to a single Document, only the last attribute will be
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion of doc.content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve seen the different possible attributes in Jina, you might be
    thinking that sometimes it’d be useful to convert one type of `doc.content` to
    another. For example, if you had a Document and its path (`uri`), but you needed
    it in a text format, you could use one of these pre-made conversion functions
    to easily switch the content type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all of these methods will help you transform your data from
    one type to another, but all of these types will need to be transformed into vector
    embeddings . Let’s see what exactly an embedding is and why we use them in neural
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an embedding attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An embedding is a high-dimensional representation of a Document, and it’s a
    key element in neural search. Embeddings are representations of your data in a
    vector format. This is why neural search can be used for any kind of data regardless
    of its type (image, audio, text, and so on). The data will be transformed into
    vectors (embeddings), and those vectors are the ones that will be used in neural
    search. Therefore, the type doesn’t matter as neural search ends up working only
    with vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are working with vectors, it is useful to work with already-established
    libraries that have extensive support for embeddings, such as NumPy, so you can,
    for example, assign any NumPy `ndarray` as a Document’s embedding and then use
    the flexibility that those libraries provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Meta attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from content attributes, you can also have meta attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.tags` | Used to store the meta-information of the Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.id` | A hexdigest that represents a unique Document ID |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.parent_id` | A hexdigest that represents the Document’s parent ID |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.weight` | The weight of the Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.mime_type` | The mime type of the Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.content_type` | The content type of the Document |'
  prefs: []
  type: TYPE_TB
- en: '| `doc.modality` | An identifier of the modality of the Document such as an
    image, text, and so on |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – Meta attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your Document, you can assign multiple attributes in its constructor
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Constructing a Document from dictionary or a JSON string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s also the option to construct your Document directly from a Python dictionary
    or JSON string. If you have the information of your Document already stored in
    those formats, you can conveniently create the Document using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Parsing unrecognized fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the fields in dictionary/a JSON string are not recognized, they are automatically
    put into the `document.tags` field. As shown in the following example, `foo` is
    not a defined attribute (*Table 4.3*), so it will be automatically parsed into
    the `tags` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `field_resolver` to map external field names to Document attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Constructing a Document from other Documents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In case you want to duplicate a Document, the following are ways to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shallow copy**: Assigning a Document object to another Document object will
    make a shallow copy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`copy=True`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Partial copy**: You can partially update a Document according to another
    source Document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.2_B17488.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use any of the three preceding methods to copy a Document.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a Document from file types such as JSON, CSV, ndarray, and others
  prefs: []
  type: TYPE_NORMAL
- en: The `jina.types.document.generators` module lets you construct Documents from
    common file types such as `JSON`, `CSV`, `ndarray`, and text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions will create a generator of Documents, where each `Document`
    object corresponds to a line/row in the original format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Import Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `from_ndjson()` | This function yields a Document from a line-based JSON
    file. Each line is a Document object. |'
  prefs: []
  type: TYPE_TB
- en: '| `from_csv()` | This function yields a Document from a .csv file. Each line
    is a Document object. |'
  prefs: []
  type: TYPE_TB
- en: '| `from_files()` | This function yields a Document from a glob file. Each file
    is a Document object. |'
  prefs: []
  type: TYPE_TB
- en: '| `from_ndarray()` | This function yields a Document from an ndarray. Each
    row (depending on the axis) is a Document object. |'
  prefs: []
  type: TYPE_TB
- en: '| `from_lines()` | This function yields a Document from lines, of JSON, and
    CSV. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – Python methods for constructing Documents
  prefs: []
  type: TYPE_NORMAL
- en: Using a generator is sometimes less memory-intensive, as it does not load/build
    all Document objects in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned what a Document is and how to create one. You can create
    it either by filling it with individual bits of content, or by copying from a
    JSON file if you already have one.
  prefs: []
  type: TYPE_NORMAL
- en: DocumentArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another powerful concept in Jina is the `insert`, `delete`, `construct`, `traverse`,
    and `sort`. The DocumentArray is a first-class citizen to an Executor, serving
    as its input and output. We will talk about Executors in the next section, but
    for now, think of them as the way Jina processes Documents.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a DocumentArray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can construct, delete, insert, sort, and traverse a `DocumentArray` like
    a Python list. You can create these in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like a normal Document, the DocumentArray also supports different methods
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Attributes** |'
  prefs: []
  type: TYPE_TB
- en: '| Python list-like interface | `__getitem__`, `__setitem__`, `__delitem__`,
    `__len__`, `insert`, `append`, `reverse`, `extend`, `__iadd__`, `__add__`, `__iter__`,
    `clear`, `sort, shuffle`, `sample` |'
  prefs: []
  type: TYPE_TB
- en: '| Persistence   | `save`, `load` |'
  prefs: []
  type: TYPE_TB
- en: '| Neural search operations | `match`, `visualize` |'
  prefs: []
  type: TYPE_TB
- en: '| Advanced getters   | `get_attributes`, `get_attributes_with_docs`, `traverse_flat`,
    `traverse` |'
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – DocumentArray attributes
  prefs: []
  type: TYPE_NORMAL
- en: Persistence via save()/load()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, there will be cases where you want to save the elements of your
    DocumentArray for further processing, and you can save all elements in a DocumentArray
    in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In JSON line format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In binary format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To save it in JSON line format, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And to store it in binary format, which is much faster and yields smaller files,
    you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Basic operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like with any other object, you can perform basic operations on a DocumentArray.
    This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s learn about these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can access a Document in the DocumentArray via an index, ID, or slice indices,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to use to any variation of these options depending on your use case
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because `DocumentArray` is a subclass of `MutableSequence`, you can use the
    built-in Python function `sort` to sort elements in a DocumentArray. For example,
    if you want to sort elements in-place (without making copies), and use the `tags[id]`
    value in a descending manner, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Filtering elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use Python’s built-in `filter` function to filter elements in a `DocumentArray`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This would print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also build a `DocumentArray` object from the filtered results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This would print the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have learned how to create Documents and DocumentArrays that
    store multiple Documents as a list. But what can you actually do with these? How
    can you process them for use in neural search? This is where Executors come into
    the picture. Let’s talk about them in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Executor** represents the processing component in a Jina Flow. It performs
    a single task on a Document or DocumentArray. You can think of an Executor as
    the logical part of Jina. Executors are the ones that will perform tasks of all
    kinds on a Document. For example, you could have an Executor for extracting text
    from a PDF file, or for encoding audio for your Document. They handle all of the
    algorithmic tasks in Jina.
  prefs: []
  type: TYPE_NORMAL
- en: Since Executors are one of the main parts of Jina, and they are the ones that
    perform all the algorithmic tasks, it would be very useful for you to make them
    in a way that means they could be easily shared with other people, so that others
    can re-use your work. Similarly, you could use prebuilt Executors made by someone
    else in your own code. This is in fact possible because Executors are easily available
    in a marketplace, which in Jina is called Jina Hub ([https://hub.jina.ai/](https://hub.jina.ai/)). There
    you can browse between various Executors that solve different tasks, and you can
    just select the one that is useful to you and use it in your code. Of course,
    it’s possible that the Executor for the task you need to do has not already been
    built in Jina Hub, in which case you’ll need to create your own Executor. You
    can do this easily in Jina Hub. Let’s take a deep dive into how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Executor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an Executor, it’s best to use Jina Hub, which will generate a wizard
    to guide you through the process. To start this process, open a console and write
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will trigger a wizard that will guide you through the creation of the
    Executor and ask you for some details about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Creating an Executor via the CLI ](img/Figure_4.3_B17488.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Creating an Executor via the CLI
  prefs: []
  type: TYPE_NORMAL
- en: After going through the wizard, your Executor will be ready. Now, let’s learn
    about Executors in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executors process DocumentArrays in-place via functions decorated with `@requests`.
    We add this decorator to whatever functions we want in our Executors. When creating
    an Executor, three principles should be kept in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be a subclass of the `jina.Executor` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be a bag-of-functions with the state `shared`. It can contain an arbitrary
    number of functions with arbitrary names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions decorated by `@requests` will be invoked according to their `on= endpoint`.
    We will see different cases of what those endpoints could be in the following
    example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a very basic Executor in Python to help you understand this last concept
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The name of your Executor can be whatever you wish, but the important thing
    to remember is that every new Executor should be a subclass of `jina.Executor`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t need to implement the constructor (`__init__`) if your Executor does
    not contain initial states, but if your Executor has `__init__`, it needs to carry
    `**kwargs` in the signature and call `super().__init__(**kwargs)` into the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Method decorator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `@requests` decorator defines when a function will be invoked. It has the
    `on=` keyword, which defines the endpoint. We haven’t talked about Flow yet. We
    will do so in the next section, but for now, think of Flow as a manager. The `@requests`
    decorator sends information to Flow whenever our Executor needs to be called.
    This is to communicate to Flow when the function will be called and at which endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the decorator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have three endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on=''/index''`: This endpoint will trigger the `MyExecutor.foo` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on=''/random_work''`: This endpoint will trigger the `MyExecutor.bar` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on=''/blah'':` This endpoint will not trigger any methods, as no function
    is bound to `MyExecutor.blah`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executor binding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have seen how to create Executors and learned about the `@requests`
    decorator, you might be wondering what types of binding you can use with `@requests`.
  prefs: []
  type: TYPE_NORMAL
- en: Default binding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A class method decorated with plain `@requests` is the default handler for
    all endpoints. This means that it is the fallback handler for endpoints that are
    not found. Let’s see one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, two functions were defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here the `foo` function becomes the default method since it has no `on=` keyword.
    If we were now to use an unknown endpoint, such as `f.post(on='/blah', ...)`,
    it would invoke `MyExecutor.foo` since there is no `on='/blah'` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple bindings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To bind a method with multiple endpoints, you can use `@requests(on=['/foo',
    '/bar'])`. This allows either `f.post(on='/foo', ...)` or `f.post(on='/bar', ...)`
    to invoke the function.
  prefs: []
  type: TYPE_NORMAL
- en: No binding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A class with no `@requests` binding plays no part in the a Flow. The request
    will simply pass through without any processing.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know what an Executor is and why it is useful to share them with other
    developers. You have also learned where to find already-published Executors and
    how to publish your own. Let’s see now how to put together the concepts you’ve
    learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know what Documents and Executors are and how to work with them,
    we can start to talk about **Flow**, one of the most important concepts in Jina.
  prefs: []
  type: TYPE_NORMAL
- en: Think of Flow as a manager in Jina; it takes care of all the tasks that will
    run on your application and will use Documents as its input and output.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The creation of a Flow in Jina is very easy and works just like any other object
    in Python. For example, this is how you would create an empty Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use a Flow, it’s best to always open it as a context manager, just
    like you would open a file in Python, by using the `with` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Flow follows a lazy construction pattern: it won’t actually run unless you
    use the `with` function to open it.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Executors to a Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add elements to your Flow, all you need to do is use the `.add()` method.
    You can add as many elements as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.add()` method is used to add an Executor to a Flow object. Each `.add()`
    instance adds a new Executor, and these Executors can be run as a local thread,
    local process, remote process, inside a Docker container, or even inside a remote
    Docker container. You can add as many as you need like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Defining an Executor via uses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `uses` parameter to specify the Executor that you are using.
    The `uses` parameter accepts multiple value types including class names, Docker
    images, and (inline) YAML. Therefore, you can add an Executor via this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing a Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to visualize your Flow, you can do so with the`.plot()` function.
    This will create a `.svg` file with the visualized Flow. To do this, add the `.plot()`
    function at the end of your Flow and use the intended title of your `.svg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will produce the following figure with the corresponding
    Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Example of a Flow ](img/Figure_4.4_B17488.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Example of a Flow
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Jupyter Lab/Notebook, the Flow object is rendered automatically without needing
    to call `.plot()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use CRUD methods (index, search, update, delete), which are just
    sugary syntax forms of post with `on=''/index'', on=''/search''`. These are laid
    out in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index = partialmethod(post, ''/index'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search = partialmethod(post, ''/search'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update = partialmethod(post, ''/update'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete = partialmethod(post, ''/delete'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, taking the previous concepts together, a minimal working example requires
    the creation of an Executor that extends from the base Executor class and can
    be used together with your Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! You now have a minimal working example and have covered the basics
    of Jina. We’ll see more advanced uses in the next chapters, but if you’ve learned
    the Document, DocumentArray, Executor, and Flow concepts, you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced the main concepts in Jina: Document, DocumentArray,
    Flow, and Executor. You should now have an overview of what each of those concepts
    are, why they are important, and how they relate to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides understanding the theory of why Document, DocumentArray, Flow, and Executor
    are important while building your search engine, you should also be able to create
    a simple Document and assign its corresponding attributes.  As you are done with
    this chapter, you should also be able to create your own Executor and spin up
    a basic Flow.
  prefs: []
  type: TYPE_NORMAL
- en: You will use all of this knowledge in the next chapter, where you will learn
    how to integrate these concepts together.
  prefs: []
  type: TYPE_NORMAL
