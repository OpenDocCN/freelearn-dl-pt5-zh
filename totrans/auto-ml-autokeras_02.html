<html><head></head><body>
		<div id="_idContainer014">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Introduction to Automated Machine Learning</h1>
			<p>In this chapter, we cover the main concepts relating to <strong class="bold">Automated Machine Learning</strong> (<strong class="bold">AutoML</strong>) with an overview of the types of AutoML methods and its software systems.</p>
			<p>If you are a developer working with AutoML, you will be able to put your knowledge to work with this practical guide to develop and use state-of-the-art AI algorithms in your projects. By the end of this chapter, you will have a clear understanding of the anatomy of the <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) workflow, what AutoML is, and its different types.</p>
			<p>Through clear explanations of essential concepts and practical examples, you will see the differences between the standard ML and the AutoML approaches and the pros and cons of each.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>The anatomy of a standard ML workflow</li>
				<li>What is AutoML?</li>
				<li>Types of AutoML</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The anatomy of a standard ML workflow</h1>
			<p>In a traditional ML <a id="_idIndexMarker000"/>application, professionals have to train a model using a set of input data. If this data is not in the proper form, an expert may have to apply some data preprocessing techniques, such as feature extraction, feature engineering, or feature selection.</p>
			<p>Once the data is ready and the model can be trained, the next step is to select the right algorithm and optimize the hyperparameters to maximize the accuracy of the model's predictions. Each step involves time-consuming challenges, and typically also requires a data scientist with the experience and knowledge to be successful. In the following figure, we can see the main steps <a id="_idIndexMarker001"/>represented in a typical ML pipeline:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B16953_01_01.jpg" alt="Figure 1.1 – ML pipeline steps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – ML pipeline steps</p>
			<p>Each of these pipeline processes involves a series of steps. In the following sections, we describe each process and related concepts in more detail.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Data ingestion</h2>
			<p>Piping incoming <a id="_idIndexMarker002"/>data to a data store is the first step in any ML workflow. The <a id="_idIndexMarker003"/>target here is to store that raw data without doing any transformation, to allow us to have an immutable record of the original dataset. The data can be obtained from various data sources, such as databases, message buses, streams, and so on.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Data preprocessing</h2>
			<p>The <a id="_idIndexMarker004"/>second phase, data <a id="_idIndexMarker005"/>preprocessing, is one of the most time-consuming tasks in the pipeline and involves many sub-tasks, such as <strong class="bold">data cleaning</strong>, <strong class="bold">feature extraction</strong>, <strong class="bold">feature selection</strong>, <strong class="bold">feature engineering</strong>, and <strong class="bold">data segregation</strong>. Let's take a closer look at each one:</p>
			<ul>
				<li>The <strong class="bold">data cleaning</strong> process is <a id="_idIndexMarker006"/>responsible for detecting and fixing (or deleting) corrupt or wrong records from a dataset. Because the data is unprocessed and unstructured, it is rarely in the correct form to be processed; it implies filling in missing fields, removing duplicate rows, or normalizing and fixing other errors in the data.</li>
				<li><strong class="bold">Feature extraction</strong> is a procedure <a id="_idIndexMarker007"/>for reducing the number of resources required in a large dataset by creating new features from the combination of others (and eliminating the original ones). The main problem when analyzing large datasets is the number of variables to take into account. Processing a large number of variables generally requires a lot of hardware resources, such as memory and computing power, and can also cause overfitting, which means that the algorithm works very well for training samples and generalizes poorly for new samples. Feature extraction is based on the construction of new variables, combining existing ones to solve these problems without losing precision in the data.</li>
				<li><strong class="bold">Feature selection</strong> is the process of selecting a subset of variables to use in building the model. Performing <a id="_idIndexMarker008"/>feature selection simplifies the model (making it more interpretable for humans), reduces training times, and improves generalization by reducing overfitting. The main reason to apply feature selection methods is that the data contains some features that can be redundant or irrelevant, so removing them wouldn't incur much loss of information.</li>
				<li><strong class="bold">Feature engineering</strong> is the <a id="_idIndexMarker009"/>process by which, through data mining techniques, features are extracted from raw data using domain knowledge. This typically requires a knowledgeable expert and is used to improve the performance of ML algorithms.</li>
			</ul>
			<p><strong class="bold">Data segregation</strong> consists of <a id="_idIndexMarker010"/>dividing the dataset into two subsets: a <strong class="bold">train dataset</strong> for <a id="_idIndexMarker011"/>training the model and a <strong class="bold">test dataset</strong> for <a id="_idIndexMarker012"/>testing the prediction modeling.</p>
			<p>Modeling is divided into three parts: </p>
			<ol>
				<li>Choose candidate models to evaluate. </li>
				<li>Train the chosen model (improve it).</li>
				<li>Evaluate the model (compare it with others).</li>
			</ol>
			<p>This process is iterative and involves testing various models until one is obtained that solves the problem in an efficient way. The following figure shows a detailed schema of the modeling <a id="_idIndexMarker013"/>phases of the ML pipeline:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B16953_01_02.jpg" alt="Figure 1.2 – Modeling phases of the ML pipeline"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Modeling phases of the ML pipeline</p>
			<p>After taking an overview of the modeling phase, let's look at each modeling step in more detail.</p>
			<p>Let's dive deeper into the three parts of modeling to have a detailed understanding of them. </p>
			<h3>Model selection</h3>
			<p>In choosing a candidate <a id="_idIndexMarker014"/>model to use, in addition to performance, it is important to consider several factors, such as readability (by humans), ease <a id="_idIndexMarker015"/>of debugging, the amount of data available, as well as hardware limitations for training and prediction. </p>
			<p>The main points to take into account for selecting a model would be as follows:</p>
			<ul>
				<li><strong class="bold">Interpretability and ease of debugging</strong>: How to know why a model made a specific decision. How do we fix the errors?</li>
				<li><strong class="bold">Dataset type</strong>: There are algorithms that are more suitable for specific types of data.</li>
				<li><strong class="bold">Dataset size</strong>: How much data is available and will this change in the future?</li>
				<li><strong class="bold">Resources</strong>: How much time and resources do you have for training and prediction?</li>
			</ul>
			<h3>Model training</h3>
			<p>This process uses the training dataset to feed each chosen candidate model, allowing the models to learn <a id="_idIndexMarker016"/>from it by applying a backpropagation <a id="_idIndexMarker017"/>algorithm that extracts the patterns found in the training samples.</p>
			<p>The model is fed with the output data from the data preprocessing step. This dataset is sent to the chosen model and once trained, both the model configuration and the learned parameters will be used in the model evaluation.</p>
			<h3>Model evaluation</h3>
			<p>This step is responsible <a id="_idIndexMarker018"/>for evaluating model <a id="_idIndexMarker019"/>performance using test datasets to measure the accuracy of the prediction. This process involves tuning and improving the model, generating a new candidate model version to be trained again.</p>
			<h3>Model tuning </h3>
			<p>This model evaluation step involves modifying hyperparameters such as the learning rate, the optimization <a id="_idIndexMarker020"/>algorithm, or model-specific <a id="_idIndexMarker021"/>architecture parameters, such as the number of layers and types of operations for neural networks. In standard ML, these procedures need to be performed manually by an expert.</p>
			<p>Other times, the evaluated model is discarded, and another new model is chosen for training. Often, starting with a previously trained model through transfer learning leads to shortened training time as well as better precision on the final model predictions.</p>
			<p>Since the main bottleneck is the training time, the adjustment of the models should focus on efficiency and reproducibility so that the training is as fast as possible and someone can reproduce the steps that have been taken to improve performance.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Model deployment</h2>
			<p>Once the best model is <a id="_idIndexMarker022"/>chosen, it is usually <a id="_idIndexMarker023"/>put into production through an API service to be consumed by the end user or other internal services. </p>
			<p>Usually, the best model is selected to be deployed in one of two deployment modes:</p>
			<ul>
				<li><strong class="bold">Offline</strong> (<strong class="bold">asynchronous</strong>): In this case, the <a id="_idIndexMarker024"/>model predictions are calculated in a batch process periodically and stored in a data warehouse as a key-value database.  </li>
				<li><strong class="bold">Online</strong> (<strong class="bold">synchronous</strong>): In this mode, the <a id="_idIndexMarker025"/>predictions are calculated in real time.</li>
			</ul>
			<p>Deployment consists of exposing your model to a real-world application. This application can be <a id="_idIndexMarker026"/>anything, from recommending videos to users of a streaming platform to predicting the weather on a mobile application.</p>
			<p>Releasing an ML model into production is a complex process that generally involves multiple technologies (version control, containerization, caching, hot swapping, a/b testing, and so on) and is outside the scope of this book.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Model monitoring</h2>
			<p>Once in production, the <a id="_idIndexMarker027"/>model is monitored to <a id="_idIndexMarker028"/>see how it performs in the real world and calibrated accordingly. This schema represents the continuous model cycle, from data ingestion to deployment:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B16953_01_03.jpg" alt="Figure 1.3 – Model cycle phases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Model cycle phases</p>
			<p>In the following sections, we will explain the main reasons why it's really important to monitor your production model.</p>
			<h3>Why monitor your model?</h3>
			<p>Your model <a id="_idIndexMarker029"/>predictions will degrade over time. This phenomenon is called drift. Drift is a <a id="_idIndexMarker030"/>consequence of input data changes, so over time, the predictions get worse in a natural way.</p>
			<p>Let's look at the users of a search engine as an example. A predictive model can use user features such as your personal information, search types, and clicked results to predict which ads to show. But after a while, these searches may not represent current user behavior.</p>
			<p>A possible solution would be to retrain the model with the most recent data, but this is not always possible and sometimes may even be counterproductive. Imagine training the model with searches at the start of the COVID-19 pandemic. This would only show ads for products related to the pandemic, causing a sharp decline in the number of sales for the rest of the products.</p>
			<p>A smarter alternative to combat drift is to monitor our model, and by knowing what is happening, we can decide when and how to retrain it.</p>
			<h3>How can you monitor your model?</h3>
			<p>In cases where you <a id="_idIndexMarker031"/>have the actual values to compare to the prediction in no time—I mean you have the true labels right after making a prediction—you just need to monitor the performance measures such as accuracy, F1 score, and so on. But often, there is a delay between the prediction and the basic truth; for example, in predicting spam in emails, users can report that an email is spam up to several months after it was created. In this case, you must use other measurement methods based on statistical approaches. </p>
			<p>For other complex processes, sometimes it is easier to do traffic/case splitting and monitor pure business metrics, in a case where it is difficult to consider direct relationships between classical ML evaluation metrics and real-world-related instances.</p>
			<h3>What should you monitor in your model?</h3>
			<p>Any ML pipeline involves performance data monitoring. Some possible variables of the model to monitor <a id="_idIndexMarker032"/>are as follows:</p>
			<ul>
				<li><strong class="bold">Chosen model</strong>: What kind of model was chosen, and what are the architecture type, the optimizer algorithm, and the hyperparameter values?</li>
				<li><strong class="bold">Input data distribution</strong>: By comparing the distribution of the training data with the distribution of the input data, we can detect whether the data used for the training represents what is happening now in the real world.</li>
				<li><strong class="bold">Deployment date</strong>: Date of the release of the model.</li>
				<li><strong class="bold">Features used</strong>: Variables used as input for the model. Sometimes there are relevant features in production that we are not using in our model.</li>
				<li><strong class="bold">Expected versus observed</strong>: A scatter plot comparing expected and observed values is often the most widely used approach.</li>
				<li><strong class="bold">Times published</strong>: The number of times a model was published, represented usually using model version numbers.</li>
				<li><strong class="bold">Time running</strong>: How long has it been since the model was deployed?</li>
			</ul>
			<p>Now that we have seen the different components of the pipeline, we are ready to introduce the main AutoML concepts in the next section.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>What is AutoML?</h1>
			<p>The main task in the modeling <a id="_idIndexMarker033"/>phase is to select the different models to be evaluated and adjust the different hyperparameters of each one. This work that data scientists normally perform requires a lot of time as well as experienced professionals. From a computational point of view, hyperparameter tuning is a comprehensive search process, so it can be automated.</p>
			<p><strong class="bold">AutoML</strong> is a process that automates, using AI algorithms, every step of the ML pipeline described previously, from the data preprocessing to the deployment of the ML model, allowing non-data scientists (such as software developers) to use ML techniques without the need for experience in the field. In the following figure, we can see a simple representation of the inputs and outputs of an AutoML system:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16953_01_04.jpg" alt="Figure 1.4 – How AutoML works&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – How AutoML works</p>
			<p>AutoML is also capable of <a id="_idIndexMarker034"/>producing simpler solutions, more agile proof-of-concept creation, and unattended training of models that often outperform those created manually, dramatically improving the predictive performance of the model and allowing data scientists to perform more complex tasks that are more difficult to automate, such as data preprocessing and feature engineering, defined in the <em class="italic">Model monitoring</em> section. Before introducing the AutoML types, let's take a quick look at the main differences between AutoML and traditional ML.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Differences from the standard approach</h2>
			<p>In the <a id="_idIndexMarker035"/>standard ML approach, data scientists have an input <a id="_idIndexMarker036"/>dataset to train. Usually, this raw data is not ready for the training algorithms, so an expert must apply different methods, such as data preprocessing, feature engineering, and feature extraction methods, as well as model tuning through algorithm selection and hyperparameter optimization, to maximize the model's predictive performance.</p>
			<p>All of these steps are time-consuming and resource-intensive, being the main obstacle to putting ML into practice.</p>
			<p>With AutoML, we simplify these steps for non-experts, making it possible to apply ML to solve a problem in an easier and faster way.</p>
			<p>Now that the main concepts of AutoML have been explained, we can put them into practice. But first, we will see what the main types of AutoML are and some of the widely used tools to perform AutoML.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Types of AutoML</h1>
			<p>This chapter will explore the frameworks available today for each of the previously listed AutoML types, giving <a id="_idIndexMarker037"/>you an idea of what is possible now in terms of AutoML. But first, let's briefly discuss the end-to-end ML pipeline and see where each process occurs in that pipeline.</p>
			<p>As we saw in the previous workflow diagram, the ML pipeline involves more steps than the modeling ones, such as data steps and deployment steps. In this book, we will focus on the automation of modeling because it is one of the phases that require more investment of time and as we will see later, AutoKeras, the AutoML framework we will work on, uses neural architecture search and hyperparameter optimization methods, both applied in the modeling phase.</p>
			<p>AutoML tries to automate each of the steps in the pipeline but the main time-consuming steps to automate usually are the following:</p>
			<ul>
				<li>Automated feature engineering</li>
				<li>Automated model selection and hyperparameter tuning</li>
				<li>Automated neural network architecture selection</li>
			</ul>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Automated feature engineering</h2>
			<p>The features used by the <a id="_idIndexMarker038"/>model have a direct impact on the performance of an ML algorithm. Feature engineering requires a large investment of time and human resources (data scientists) and involves a lot of trial and error, as well as deep domain knowledge. </p>
			<p>Automated feature engineering is based on creating new sets of features iteratively until the ML model achieves good prediction performance.  </p>
			<p>In a standard feature engineering process, a dataset is collected, for example, a dataset from a job search website that collects data on the behavior of candidates. Usually, a data scientist will create new features if they are not already in the data, such as the following:  </p>
			<ul>
				<li>Search keywords  </li>
				<li>Titles of the job offers read by the candidates  </li>
				<li>Candidate application frequency</li>
				<li>Time since the last application</li>
				<li>Type of job offers to which the candidate applies  </li>
			</ul>
			<p>Feature engineering automation tries to create an algorithm that automatically generates or obtains these types of features from the data.</p>
			<p>There is also a specialized <a id="_idIndexMarker039"/>form of ML called deep learning, in <a id="_idIndexMarker040"/>which features are extracted from images, text, and videos automatically using matrix transformations on the model layers.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Automated model choosing and hyperparameter optimization</h2>
			<p>After the data <a id="_idIndexMarker041"/>preprocessing phase, an ML algorithm has to be searched to <a id="_idIndexMarker042"/>train with these features so that it is able to predict from new observations. In contrast to the previous step, the selection of models is full of options to choose from. There are classification and regression models, neural network-based models, clustering models, and many more. </p>
			<p>Each algorithm is suitable for a certain class of problems and with automated model selection, we can find the optimal model by executing all the appropriate models for a particular task and selecting the one that is most accurate. There is no ML algorithm that works well with all datasets and there are some algorithms that require more hyperp<a id="_idTextAnchor025"/>arameter tuning than others. In fact, during model selection, we tend to experiment with different hyperparameters.</p>
			<h3>What are hyperparameters?</h3>
			<p>In the <a id="_idIndexMarker043"/>training phase of the model, there are many variables to be set. Basically, we can group them into two types: <strong class="bold">parameters</strong> and <strong class="bold">hyperparameters</strong>. <strong class="bold">Parameters</strong> are <a id="_idIndexMarker044"/>those that are learned in the model training process, such as weight and bias in a neural network, while <strong class="bold">hyperparameters</strong> are those that are initialized just before the training process as a learning rate, dropout factor, and so on. </p>
			<h4>Types of search methods</h4>
			<p>There are many algorithms <a id="_idIndexMarker045"/>to find the optimal hyperparameters of a model. The following figure highlights the best-known ones that are also used by AutoKeras:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16953_01_05.jpg" alt="Figure 1.5 – Hyperparameter search method paths&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Hyperparameter search method paths</p>
			<p>Let's try to understand these methods in more detail:</p>
			<ul>
				<li><strong class="bold">Grid search</strong>: Given a set of variables (hyperparameters) and a set of values for each variable, grid search <a id="_idIndexMarker046"/>performs an exhaustive search, testing all possible combinations of these values in the variables to find the best possible model based on a defined evaluation metric, such as precision. In the case of a neural network with learning rate  and dropout as hyperparameters to tune, we can define a learning rate set of values as [0.1, 0,01] and a dropout set of values as [0.2, 0,5], so grid search will train the model with these combinations:<p>(a) <em class="italic">learning_rate</em>: 0.1, dropout=0.2 =&gt; Model version 1</p><p>(b) <em class="italic">learning_rate</em>: 0.01, dropout=0.2  =&gt; Model version 2</p><p>(c) <em class="italic">learning_rate</em>: 0.1, dropout=0.5  =&gt; Model version 3</p><p>(d) <em class="italic">learning_rate</em>: 0.01, dropout=0.5 =&gt; Model version 4</p></li>
				<li><strong class="bold">Random search</strong>: This is similar to <a id="_idIndexMarker047"/>grid search but runs the training of the model combinations in a random order. That random exploration feature makes random search usually cheaper than grid search.</li>
				<li><strong class="bold">Bayesian search</strong>: This method performs a hyperparameter fit based on the Bayesian theorem that explores <a id="_idIndexMarker048"/>only combinations that maximize the probability function.</li>
				<li><strong class="bold">Hyperband</strong>: This is a novel <a id="_idIndexMarker049"/>variation of random search that tries to resolve the exploration/exploitation dilemma using a bandit-based approach to hyperparameter optimization.</li>
			</ul>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Automated neural network architecture selection</h2>
			<p>The design of neural <a id="_idIndexMarker050"/>network architectures is one of the most complex and tedious tasks in the world of ML. Typically, in traditional ML, data scientists spend a lot of time iterating through different neural network architectures with different hyperparameters to optimize a model objective function. This is time-consuming, requires deep knowledge, and is prone to errors at times. </p>
			<p>In the middle of the 2010s, the idea of implementing neural network search by employing evolutionary algorithms and reinforcement learning to design and find an optimal neural <a id="_idIndexMarker051"/>network architecture was introduced. It was called <strong class="bold">Network Architecture Search</strong> (<strong class="bold">NAS</strong>). Basically, it trains a model to create layers, stacking them to create a deep neural network architecture.</p>
			<p>A NAS system involves these three main components: </p>
			<ul>
				<li><strong class="bold">Search space</strong>: Consists of a <a id="_idIndexMarker052"/>set of blocks of operations (full connected, convolution, and so on) and how these operations are connected to each other to form valid network architectures. Traditionally, the design of the search space is done by a data scientist.</li>
				<li><strong class="bold">Search algorithm</strong>: A NAS search <a id="_idIndexMarker053"/>algorithm tests a number of candidate network architecture models. From the metrics obtained, it selects the candidates with the highest performance.</li>
				<li><strong class="bold">Evaluation strategy</strong>: As a large <a id="_idIndexMarker054"/>number of models are required to be tested in order to obtain successful results, the process is computationally very expensive, so new methods appear every so often to save time or computing resources.</li>
			</ul>
			<p>In the next figure, you <a id="_idIndexMarker055"/>can see the relationships between the three described components:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16953_01_06.jpg" alt="Figure 1.6 – NAS component relationships&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – NAS component relationships</p>
			<p>Currently, NAS is a new area of research that is attracting a lot of attention and several research papers have been published: <a href="http://www.ml4aad.org/automl/literature-on-neural-architecture-search/">http://www.ml4aad.org/automl/literature-on-neural-architecture-search/</a>. Some of the most cited papers are as follows:</p>
			<ul>
				<li><strong class="bold">NASNet</strong> (<a href="https://arxiv.org/abs/1707.07012">https://arxiv.org/abs/1707.07012</a>) – <em class="italic">Learning Transferable Architecture for Scalable Image Recognition</em>: High-precision models for image classification <a id="_idIndexMarker056"/>are based on very complex neural networks with lots of layers. NASNet is a method of learning model architectures directly from the dataset of interest. Due to the high cost of doing so when the dataset is very large, it first looks for an architectural building block in a small dataset, and then transfers the block to a larger dataset. This approach is a successful example of what you can <a id="_idIndexMarker057"/>achieve with AutoML, because NASNet-generated models often outperform state-of-the-art, human-designed models. In the following figure, we can see how NASNet works:</li>
			</ul>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16953_01_07.jpg" alt="Figure 1.7 – Overview of NAS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Overview of NAS</p>
			<ul>
				<li><strong class="bold">AmoebaNet</strong> – <em class="italic">Regularized Evolution for Image Classifier Architecture Search</em>: This approach uses <a id="_idIndexMarker058"/>an evolutionary algorithm to efficiently discover high-quality architectures. To date, the evolutionary algorithms applied to image classification have not exceeded those created by humans. AmoebaNet-A surpasses them for the first time. The key has been to modify the selection algorithm by introducing an age property to favor the youngest genotypes. AmoebaNet-A has a similar precision to the latest generation ImageNet models discovered with more complex architecture search methods, showing that evolution can obtain results faster with the same hardware, especially in the early search stages, something that is especially important when there are few computational resources available. The following figure shows the correlation between precision and model size for some representative next-generation image classification models in history. The dotted circle <a id="_idIndexMarker059"/>shows 84.3% accuracy for an AmoebaNet model:</li>
			</ul>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16953_01_08.jpg" alt="Figure 1.8 – Correlation between the top-1 accuracy and model size for state-of-the-art image classification models using the ImageNet dataset "/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Correlation between the top-1 accuracy and model size for state-of-the-art image classification models using the ImageNet dataset </p>
			<ul>
				<li><strong class="bold">Efficient Neural Architecture Search</strong> (<strong class="bold">ENAS</strong>): This variant of NASNet improves its <a id="_idIndexMarker060"/>efficiency by allowing all child models to share their weights, so it is not necessary to train each child model from scratch. This optimization significantly improves classification performance.</li>
			</ul>
			<p>There are many ML tools available, all of them with similar goals, to automate the different steps of the ML pipeline. The following are some of the most used tools:</p>
			<ul>
				<li><strong class="bold">AutoKeras</strong>: An AutoML system <a id="_idIndexMarker061"/>based on the deep learning framework <a id="_idIndexMarker062"/>Keras and using hyperparameter searching and NAS.</li>
				<li><strong class="bold">auto-sklearn</strong>: An AutoML <a id="_idIndexMarker063"/>toolkit that allows you to use a special type of <a id="_idIndexMarker064"/>scikit-learn estimator, which automates algorithm selection and hyperparameter tuning, using Bayesian optimization, meta-learning, and model ensembling.</li>
				<li><strong class="bold">DataRobot</strong>: An AI platform <a id="_idIndexMarker065"/>that automates the end-to-end <a id="_idIndexMarker066"/>process for building, deploying, and maintaining AI at scale.</li>
				<li><strong class="bold">Darwin</strong>: An AI tool that <a id="_idIndexMarker067"/>automates the slowest steps in the model life <a id="_idIndexMarker068"/>cycle, ensuring long-term quality and the scalability of models.</li>
				<li><strong class="bold">H2O-DriverlessAI</strong>: An <a id="_idIndexMarker069"/>AI platform for <a id="_idIndexMarker070"/>AutoML.</li>
				<li><strong class="bold">Google's AutoML</strong>: A suite of ML <a id="_idIndexMarker071"/>products that enable <a id="_idIndexMarker072"/>developers with no ML experience to train and use high-performance models in their projects. To do this, this tool uses Google's powerful next-generation transfer learning and neural architecture search technology.</li>
				<li><strong class="bold">Microsoft Azure AutoML</strong>: This cloud <a id="_idIndexMarker073"/>service creates many pipelines <a id="_idIndexMarker074"/>in parallel that try different algorithms and parameters for you.</li>
				<li><strong class="bold">Tree-based Pipeline Optimization Tool</strong> (<strong class="bold">TPOT</strong>): A Python <a id="_idIndexMarker075"/>Automated Machine Learning tool that <a id="_idIndexMarker076"/>optimizes machine learning pipelines using genetic programming.</li>
			</ul>
			<p>We can see an <a id="_idIndexMarker077"/>exhaustive comparison of the main AutoML tools that currently exist in the paper <em class="italic">Evaluation and Comparison of AutoML Approaches and Tools</em>, and from it we can conclude that while the main commercial solutions, such as H2O-DriverlessAI, DataRobot, and Darwin, allow us to detect the data schema, execute the feature engineering, and analyze detailed results for interpretation purposes, open source tools are more focused on automating the modeling tasks, training, and model evaluation, leaving the data-oriented tasks to the data scientists. </p>
			<p>The study also concludes that in the various evaluations and benchmarks tested, AutoKeras is the most <a id="_idIndexMarker078"/>stable and efficient tool, which is very important in a production environment where both performance and stability are key factors. These good features, in addition to being a widely used tool, are the main reason why AutoKeras was the AutoML framework chosen when writing this book.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/>Summary</h1>
			<p>In this chapter, we defined the purpose and benefits of AutoML, from describing the different phases of an ML pipeline to detailing the types of algorithms for hyperparameter optimization and neural architecture searching. </p>
			<p>Now that we have learned the main concepts of AutoML, we are ready to move on to the next chapter, where you will learn how to install AutoKeras and how to use it to train a simple network and then train advanced models as you progress to more complicated techniques. </p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Further reading</h1>
			<ul>
				<li>Bayes' theorem: <a href="https://towardsdatascience.com/bayes-theorem-the-holy-grail-of-data-science-55d93315defb">https://towardsdatascience.com/bayes-theorem-the-holy-grail-of-data-science-55d93315defb</a></li>
				<li>The exploration versus exploitation dilemma: <a href="https://towardsdatascience.com/intuition-exploration-vs-exploitation-c645a1d37c7a">https://towardsdatascience.com/intuition-exploration-vs-exploitation-c645a1d37c7a</a></li>
				<li>Multiarmed bandit: <a href="https://homes.di.unimi.it/~cesabian/Pubblicazioni/ml-02.pdf">https://homes.di.unimi.it/~cesabian/Pubblicazioni/ml-02.pdf</a></li>
				<li>AmoebaNet: <a href="https://arxiv.org/abs/1802.01548">https://arxiv.org/abs/1802.01548</a></li>
				<li>ENAS: <a href="https://arxiv.org/abs/1802.03268">https://arxiv.org/abs/1802.03268</a></li>
				<li>Evaluation and comparison of AutoML approaches and tools: <a href="https://arxiv.org/pdf/1908.05557.pdf">https://arxiv.org/pdf/1908.05557.pdf</a></li>
			</ul>
		</div>
	</body></html>