- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Your Solutions with K-Means Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how much we know, the key point is the ability to deliver an **artificial
    intelligence** (**AI**) solution. Implementing a **machine learning** (**ML**)
    or **deep learning** (**DL**) program remains difficult and will become more complex
    as technology progresses at exponential rates.
  prefs: []
  type: TYPE_NORMAL
- en: There is no such thing as a simple or easy way to design AI systems. A system
    is either efficient or not, beyond being either easy or not. Either the designed
    AI solution provides real-life practical uses, or it builds up into a program
    that fails to work in various environments beyond the scope of its training sets.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter doesn't deal with how to build the most difficult system possible
    to show off our knowledge and experience. It faces the hard truth of real-life
    delivery and ways to overcome obstacles. For example, without the right datasets,
    your project will never take off. Even an unsupervised ML program requires reliable
    data in some form or other.
  prefs: []
  type: TYPE_NORMAL
- en: Transportation itineraries on the road, on trains, in the air, in warehouses,
    and increasingly in outer space require well-tuned ML algorithms. The staggering
    expansion of e-commerce generates huge warehouse transportation needs with automated
    guided vehicles (AGVs), then endless miles on the road, by train, or by air to
    deliver the products. Distance calculation and optimization is now a core goal
    in many fields. An AGV that optimizes its warehouse distance to load or unload
    trucks will make the storage and delivery processes faster for customers that expect their
    purchases to arrive immediately.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides the methodology and tools needed to overcome everyday
    AI project obstacles with k-means clustering, a key ML algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimensionality reduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the volume of a training set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: k-means clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsupervised learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data conditioning management for the training dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lloyd's algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Python k-means clustering program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperparameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test dataset and prediction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and using an ML model with Pickle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll begin by talking about how to optimize and manage datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset optimization and control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At one point, a manager or customer will inevitably ask an AI expert about the
    exact data required for an ML project, and in which format it's needed. Providing
    an answer will take some hard thinking and work.
  prefs: []
  type: TYPE_NORMAL
- en: One might wonder why the data is not open, like when we download ready-to-use
    datasets to learn AI algorithms. In corporate life, there are security rules and processes.
    Often the data required is on one or more servers. You will not be granted permission
    to do anything you want. You will have to specify your needs and requests. Obtaining
    data in the way required for AI comes at a cost for a corporation. You will have
    to justify your requests.
  prefs: []
  type: TYPE_NORMAL
- en: Start by properly designing the dataset and choosing the right ML model. The
    dataset and ML model will fit the fundamental requirement to optimize AGV distances.
    Each AGV in a given warehouse must reduce the distance it takes to go from a pier
    (where boats might drop off cargo) to a storage area, from one storage area to
    another area (packaging, for example), and from a storage area to a pier. This will
    bring the overall costs of a warehouse down and maximize profit.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a dataset and choosing an ML/DL model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On paper, finding a good model for an AGV comes down to minimizing the distance
    it takes to move something from point A to point B. Let''s consider a scenario
    where we want to move products from a warehouse over to a pier. The sum of the
    distances *D* could be a way to measure the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_04_001.png)'
  prefs: []
  type: TYPE_IMG
- en: '*f*(*p*) represents the action of going from a warehouse location to a pier
    and the distance it represents. It takes you from the location in a shop where
    you picked something up, (*p*), and the door of the shop on your way out. You
    can imagine that if you go straight from that location, pay, and go out, then
    that is the shortest way. But if you pick the product up, wander around the shop
    first, and then go out, the distance (and time) is longer. The sum of all of the
    distances of all the people wandering in this shop, for example, is *D*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of the problem to solve in any self-guided bot system can be summed
    up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**find the wanderers**'
  prefs: []
  type: TYPE_NORMAL
- en: How can a bot wander? It is automatic and is often guided by efficient ML programs.
    But a bot, like any other form of transportation, often encounters obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: When a bot encounters an obstacle, either it stops, waits, or takes another
    route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a paradigm to investigate and implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the wanderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize the choice of bots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We all know that the shortest point from location A to location B is a straight
    line. Right? Well, in a warehouse, as in life, it is not always true! Suppose
    you are in your car going in a straight line from A to B but there is a huge traffic
    jam. It could take a very long time to go a relatively short distance. If you
    took a right turn and drove around the jam, you might save a lot of time. You
    end up consuming more gas, and the cost of driving from A to B goes up. You are
    a wanderer.
  prefs: []
  type: TYPE_NORMAL
- en: In real-life traffic, there is not much you can do. You cannot decide that cars
    can only drive at certain hours on a road going from A to B. You cannot decide
    to send the cars to the locations that minimize traffic. In real life, this would
    mean telling the driver to go to another mall, another restaurant, or any other
    similar location to avoid building up traffic. That would not work!
  prefs: []
  type: TYPE_NORMAL
- en: But if you are a warehouse manager that can control all of the AGVs, there is
    a lot you can do about this. You can make sure that AGVs make it quickly to their
    locations over a very short distance and come back to make room for other AGVs
    and thus reduce costs. You can detect the wanderers and configure your schedule
    and AGVs so that they minimize cost and maximize profit. No profit, no warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: Approval of the design matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plan is to first obtain as much data as possible and then choose an ML/DL
    model. The dataset must contain all locations the bots (the AGVs) come from on
    their way to the piers on a given day. It''s a location-to-pier analysis. Their
    distances are recorded in their system to provide the basis of an excellent design
    matrix. A design matrix contains a different example on each row, and each column
    is a feature. The following format fits the need:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Bot #** **(AGV)** | **Start (from location)** **Timestamp:**
    **yyyy,mm,dd,hh,mm** | **End (at the pier)** **Timestamp:** **yyyy,mm,dd,hh,mm**
    | **Location** | **Pier number** | **Distance** **Meters** |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 1 | year-month-day-hour-minute | year-month-day-hour-minute | 80 |
    7 | 92 |'
  prefs: []
  type: TYPE_TB
- en: '| 002 | 2 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 003 | 3 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 004 | 4 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 005 | 5 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The design matrix is one of the best ways to design an ML solution. In this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**: The mission number of the bot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bot #**: Identifies the vehicle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start**: Timestamp when the bot left a location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End**: Timestamp when the bot reaches a pier where a truck is waiting to
    be loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**: The location in the warehouse where a product should be retrieved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distance**: The distance from the location to the pier in meters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance is expressed in meters in the metric system. The metric system is the
    world's most reliable measurement system because it works in base 10 without having
    to resort to conversions.
  prefs: []
  type: TYPE_NORMAL
- en: A yard has to be divided by 3 to obtain feet. A foot has to be divided into
    12 to obtain inches. To work in smaller units, a 1/16th of an inch may be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: A meter is 100 centimeters, and a centimeter is 10 millimeters, then we can
    use 1/100 of a millimeter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Run your calculations with the metric system even if you have to produce reports
    in other units of measurement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting approval on the format of the design matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Real-life implementations differ from experimenting with ready-to-use downloadable
    datasets. Information does not come easy in corporations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, in a real-life situation, let''s suppose:'
  prefs: []
  type: TYPE_NORMAL
- en: The bot number is not stored in the mainframe, but in the local system that
    manages the AGVs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the mainframe, there is a start time, which is when an AGV picks up its load
    at the location, and an end time when it reaches the pier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location can be obtained in the mainframe as well as the pier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No distance is recorded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be necessary to have access to the data in the AGV's local system to
    retrieve the AGV number and correlate it with the data in the mainframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, things are not so simple in a large organization. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from the AGV guiding system might not be possible this fiscal
    year. Those vehicles are expensive, and no additional budget can be allocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nobody knows the distance from a location to a pier. As long as the AGVs deliver
    the right products on time at the right piers, nobody so far has been interested
    in distances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AGV mission codes in the mainframe are not the same as in the local AGV
    guiding system, so they cannot be merged into a dataset without development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AI project, like any other project, can slip away in no time. If a project
    comes to a standstill, it might just be shelved. Designing datasets requires imagination
    and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping an AI project alive means moving quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If the project does not move quickly, it will lose momentum. The actors of the
    project will turn to other projects that are moving more quickly for their company
    and their careers.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose your project stops because nobody can provide the distances you need
    to build your model. If you have the start time, end time, and speed, then you
    can work around the problem and calculate the distances yourself. If your team
    does not find this solution quickly, then the project will be at a standstill.
    The top management will say that the team costs too much to be focused on a project
    that is not moving ahead, no matter what. The project can be shelved right then
    and there.
  prefs: []
  type: TYPE_NORMAL
- en: Dimensionality reduction will not only help the AI model; it will also make
    it easier to gather information.
  prefs: []
  type: TYPE_NORMAL
- en: Dimensionality reduction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dimensionality reduction can be applied to reduce the number of features in,
    for example, an image. Each pixel of a 3D image, for example, is linked to a neuron,
    which in turn brings the representation down to a 2D view with some form of function.
    For example, converting a color image into shades of a now-gray image can do the
    trick. Once that is done, simply reducing the values to, for example, 1 (light)
    or 0 (dark), makes it even easier for the network. Using an image converted to
    0 and 1 pixels makes some classification processes more efficient, just like when
    we avoid a car on the road. We just see the object and avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: We perform dimensionality reduction all day long. When you walk from one office
    to another on the same floor of a building requiring no stairs or an elevator,
    you are not thinking that the Earth is round and that you're walking over a slight
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: You have performed a **dimensionality reduction**. You are also performing a
    **manifold** operation. It means that locally, on that floor, you do not need
    to worry about the global roundness of the Earth. Your manifold view of the Earth
    in your dimensionality reduction representation is enough to get you from your
    office to another one on that floor.
  prefs: []
  type: TYPE_NORMAL
- en: When you pick up your cup of coffee, you focus on not missing it and aiming
    for the edges of it. You don't think about every single **feature** of that cup,
    such as its size, color, decoration, diameter, and the exact volume of coffee
    in it. You identify the edge of the cup and pick it up. That is dimensionality
    reduction. Without dimensionality reduction, nothing can be accomplished. It would
    take you 10 minutes to analyze the cup of coffee and pick it up in that case!
  prefs: []
  type: TYPE_NORMAL
- en: When you pick that cup of coffee up, you test to see whether it is too hot,
    too cold, or just fine. You don't put a thermometer in the cup to obtain the precise
    temperature. You have again performed a dimensionality reduction of the features
    of that cup of coffee. Furthermore, when you picked it up, you computed a manifold
    representation by just observing the little distance around the cup, reducing
    the dimension of information around you. You are not worrying about the shape
    of the table, whether it was dirty on the other side, and other features.
  prefs: []
  type: TYPE_NORMAL
- en: ML and DL techniques such as dimensionality reduction can be viewed as tools
    and can be used in any field to speed up calculation times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we often relate dimensionality reduction to ML and DL, dimensionality
    reduction is as old as mathematics and even humanity! Somebody, long ago, went
    to a beach and saw that the sun was beautiful. That person, for the first time
    in humanity, drew a circle in the sand. The circle was not in 3D like the sun,
    nor did it have color, but the humans around that person were astonished:'
  prefs: []
  type: TYPE_NORMAL
- en: A group of humans were watching the sun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A human took the color out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The human also took the 3D view out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They represented the sun with a circle in a much smaller dimensional space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first mathematician was born!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A k-means clustering algorithm provides an efficient way to represent the bot
    example we are dealing with in this chapter. Each location will form a cluster,
    as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workaround to the missing data problem would be to run the k-means clustering
    algorithm with the following data format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Location** | **Start from location: Timestamp: yyyy,mm,dd,hh,mm**
    | **End at location: Timestamp: yyyy,mm,dd,hh,mm** |'
  prefs: []
  type: TYPE_TB
- en: '| 001 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: The volume of a training dataset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this model, we will focus on six locations to analyze. Six locations are
    chosen in the main warehouse with a group of truck loading points. Taking around
    5,000 examples into account, that should represent the work of all the 25 AGVs
    purchased by **AGI-AI** running 24 hours a day.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've talked about optimizing and controlling a dataset, let's move
    on to coming up with actual solutions. In the next section, we'll talk about implementing
    k-means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a k-means clustering solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dataset requires preprocessing to be converted into a prototype to prove
    the financial value of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Never implement an ML solution in a corporate environment without knowing how
    much profit it represents and the cost of getting the job done. Without profit,
    a company will not survive. ML, like any other investment, must provide a return
    on investment (ROI). In our case, ML will reduce the cost of transportation in
    the warehouse by reducing AGV distances.
  prefs: []
  type: TYPE_NORMAL
- en: The vision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary goal of an ML project involving bots can be summed up in one sentence:
    finding profit by optimizing bot activity. Achieving that goal will lead to obtaining
    a budget for a full-scale project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data provided does not contain distances. However, an estimation can be
    made per location as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: distance = (end time – start time)/average speed of a bot
  prefs: []
  type: TYPE_NORMAL
- en: The start location is usually a loading point near a pier in this particular
    warehouse configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The data provided contains start times *s*[t], end times *end*[t], and delivery
    locations. To calculate distances, we can use the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*[i](*ll*) = (*end*[t] – *s*[t])/*v*'
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = velocity of the AGV per minute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*end*[t] – *s*[t] is expressed in minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*d*[i] = estimated distance an AGV has gone in a given time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A preprocessing program will read the initial file format and data and output
    a new file, `data.csv`, in the following reduced dimensionality format with two
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Distance** | **Location** |'
  prefs: []
  type: TYPE_TB
- en: '| 55 | 53 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 17 |'
  prefs: []
  type: TYPE_TB
- en: Conditioning management
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Data conditioning means preparing the data that will become the input of the
    system. **Poor conditioning** can have two outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Bad data containing noise that makes no difference (large volumes and minor errors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad data containing noise that makes a difference (regardless of volumes, the data
    influences the outcome)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this particular case, let's suppose that out of the 5,000 records provided
    for the dataset, 25 distances are not reliable. A 0.005% noise level should not
    be a problem. The amount of acceptable noise depends on each project. It cannot
    be an arbitrary figure.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, noise will have a profound effect, and sometimes it will not. Suppose
    2,500 records out of 5,000 records contained noise. Maybe the 2,500 remaining
    records provide a sufficient variety of samples to produce a reliable result.
    In another case, maybe, 10 missing samples out of 5,000 records will stop a project
    because those 10 samples were the only ones of a special kind that could critically
    change the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: You will have to experiment and determine the level of acceptable noise for
    a given project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get our hands dirty and analyze the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location numbers start at #1\. #1 is near the loading point of the products.
    The bot has to bring the products to this point. To be more precise, in this warehouse
    configuration, the bot goes and gets a box (or crate) of products and brings them
    back to location 1\. At location 1, humans check the products and package them.
    After that, humans carefully load the products in the delivery trucks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance from one location to the next is about 1 meter. For example, from
    location 1 to location 5, the distance is about 5 meters, or 5 m. Also, since
    all locations lead to location 1 for the AGVs in this model, the theoretical distances
    will be calculated from location 1\. To generalize the rule and define a distance
    *d*[i] for a location *lj* the calculation can be simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*[i](*lj*)=*lj*'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*[i] is expressed in meters. Since the locations start at number 1 through
    *n*, the location number is equal to the approximate distance from the first location
    from which the bots depart.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us suppose that, looking at the data, it quickly appears that many distances
    are superior to their location numbers. That is strange because the distance should
    be about equal to the location. Thus, by reducing the number of dimensions and
    focusing on approximations of the main features, key concepts can be represented.
  prefs: []
  type: TYPE_NORMAL
- en: The time has come to build a strategy and a program.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As in all ML projects, there are key standard corporate guidelines that should
    not be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: Quickly write a proof of concept (POC). A POC will prove that the ML solution
    will be efficient. In this case, bot activity will be visualized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the results in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the potential optimized profit with a solution that is yet to be found.
    Profit will justify the investment. The cost can be an indicator. But then cost
    reduction must be sufficient to increase profit by a significant rate for a given
    corporation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain approval with a solid case and obtain a green light for the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that our strategy is clear, we can choose a model. k-means clustering is
    a good algorithm to start with for this project. It will create clusters that
    almost literally represent the areas in which the AGVs should be located. By choosing
    simple dimensions, the visual representation is close enough to reality for a
    user to understand the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The k-means clustering program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: k-means clustering is a powerful unsupervised learning algorithm. We often perform
    k-means clustering in our lives. Take, for example, a lunch you want to organize
    for a team of about 50 people in an open space that can just fit those people.
  prefs: []
  type: TYPE_NORMAL
- en: Your friend and another friend first decide to set up a table in the middle.
    Your friend points out that the people in that room will form a big cluster *k*,
    and with only one table in the geometric center (or centroid) *c*, it will not
    be practical. The people near the wall will not have access to the main table,
    as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/1table.png](img/B15438_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A scenario where people try to cluster around a single table'
  prefs: []
  type: TYPE_NORMAL
- en: The people not close to the table (the rectangle in the middle) will not have
    easy access to the table.
  prefs: []
  type: TYPE_NORMAL
- en: You now try two tables (centroids) *c*[1] and *c*[2] in various places for two
    clusters of people *k*[1] and *k*[2].
  prefs: []
  type: TYPE_NORMAL
- en: The people *x*[1] to *x*[n] form a dataset *X*. When imagining *X*, it appears
    that the table is not in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing to do is to move a table *c*, and then estimate that the mean
    distance of the people (a subset of *X*) to the table will be about the same in
    their group or cluster *k*. The same is done for the other table. You draw a line
    with chalk on the floor to make sure that each group or cluster is at about the
    mean distance from its table.
  prefs: []
  type: TYPE_NORMAL
- en: 'This intuitive approach to k-means clustering can be summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: You have been drawing lines with chalk to decide which group (cluster
    *k*) each person *x* will be in, by looking at the mean distance from the table
    *c*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2**: You have been moving the tables around accordingly to optimize
    step 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Python program simulating a three-table model computed using k-means clustering
    would produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/3tables.png](img/B15438_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: A three-table model computed by k-means clustering'
  prefs: []
  type: TYPE_NORMAL
- en: Having provided an intuitive example, let's talk about the mathematical definition
    of k-means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical definition of k-means clustering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dataset *X* provides *N* points. These points or data points are formed by using
    distance as the *x*-axis in a Cartesian representation and the location as the
    *y*-axis in a Cartesian representation. This low-level representation is a white
    box approach, even if the data is processed and transformed by the algorithm.
    A white box approach is when the process is transparent, and we can actually see
    what the algorithm is doing. A black box is when an input goes into a system,
    and we will not be able to understand what the system did by just looking at the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: However, high-level representations are required to represent more features
    through clusters. In that case, it will not be possible to see a direct link between
    the actual meanings and their ML representation. We will explore these high-dimensional
    representations in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have one bot in location 1 as the first record of your file, it will
    be represented as *x* axis = 1 and *y* axis = 1 by the black dot, which is the
    data point, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_06_2.jpg](img/B15438_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Cartesian representation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, 5,000 records are loaded from `data.csv`, which is in the
    same directory as the program. The data is unlabeled with no linear separation.
    The goal is to allocate the *X* data points to *K* clusters. The number of clusters
    is an input value. Each cluster will have its geometric center or centroid. If
    you decide to have three clusters *K*, then the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Three clusters *K* in three colors in a visual representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three geometric centers or centroids representing the center of the mean of the
    sum of distances of *x* data points of that cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you decide on six clusters, then you will obtain six centroids, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Described in mathematical terms, the formula in respect of ![](img/B15438_04_002.png),
    ![](img/B15438_04_003.png) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_04_004.png)'
  prefs: []
  type: TYPE_IMG
- en: The sum of each *k* (cluster) from 1 to the number of clusters *K* of the sum
    of all distances of members *x*[i] to *x*[n] of each cluster *K* from their position
    to the geometric center (centroid) ![](img/B15438_04_005.png) must be minimized.
  prefs: []
  type: TYPE_NORMAL
- en: The smaller the distance from each member *x* to centroid ![](img/B15438_04_005.png),
    the more the system is optimized. Note that the distance is squared each time
    because this is a Euclidean distance in this version of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euclidean distance, in one dimension, is the distance between two points,
    *x* and *y*, for example, expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_04_007.png)'
  prefs: []
  type: TYPE_IMG
- en: The distance between *x* and *y* expressed in Euclidean distance is not the
    real distance that an AGV will actually travel inside a warehouse. The model in
    the chapter was built so that the distances would remain sufficiently realistic
    to make good clusters and improve the organization of the warehouse. It's sufficient
    because an AGV will often go in nearly straight lines from a pier to the closest
    aisle and then to a storage point, for example.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the actual distances, we often use Manhattan distances. Manhattan
    distances are taxi-cab distances. You calculate the distance up a block then to
    the left, for example, another block and so on, adding the distances along the
    way. This is because you can't drive through the buildings.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, it would be like saying that a taxi-cab can only, more or less,
    drive up and down a given avenue, like a bus, and avoid turning right or left.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Lloyd's algorithm with Euclidean distances to estimate the clusters
    that AGVs will have to stay in to avoid wandering.
  prefs: []
  type: TYPE_NORMAL
- en: Lloyd's algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several variations of Lloyd's algorithm. But all of them follow a
    common philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: For a given *x*[n] (data point), the distance from the centroid ![](img/B15438_04_005.png)
    in its cluster must be less than going to another center, just like how a person
    in the lunch example wants to be closer to one table rather than having to go
    far to get a sandwich because of the crowd.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best centroid ![](img/B15438_04_005.png) for a given *x*[n] is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_04_010.png)'
  prefs: []
  type: TYPE_IMG
- en: This calculation is done for all ![](img/B15438_04_005.png) (centroids) in all
    the clusters from *k*[1] to *K*.
  prefs: []
  type: TYPE_NORMAL
- en: Once each *x*[i] has been allocated to a *K*[k], the algorithm recomputes ![](img/B15438_04_005.png)
    by calculating the means of all the points that belong to each cluster and readjusts
    the centroid ![](img/B15438_04_013.png).
  prefs: []
  type: TYPE_NORMAL
- en: We've now covered all of the concepts that we need to begin coding. Let's get
    into the Python program!
  prefs: []
  type: TYPE_NORMAL
- en: The Python program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`k-means_clustering_1.py`, the Python program, uses the `sklearn` library,
    `pandas` for data analysis (only used to import the data in this program), and
    `matplotlib` to plot the results as data points (the coordinates of the data)
    and clusters (data points classified in each cluster with a color). First, the
    following models are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll go through the stages of implementing k-means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: 1 – The training dataset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The training dataset consists of 5,000 lines. The first line contains a header
    for maintenance purposes (data checking), which is *not* used. k-means clustering
    is an **unsupervised learning** algorithm, meaning that it classifies unlabeled
    data into cluster-labeled data to make future predictions. The following code
    displays the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print(dataset)` line can be useful (though not necessary) to check the
    training data during a prototype phase or for maintenance purposes. The following
    output confirms that the data was correctly imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 2 – Hyperparameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Hyperparameters** determine the behavior of the computation method. In this
    case, two hyperparameters are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: The `k` number of clusters that will be computed. This number can and will be
    changed during the case study meetings to find out the best organization process,
    as explained in the next section. After a few runs, we will intuitively set `k`
    to `6`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *f*-number of features that will be taken into account. In this case, there
    are two features: distance and location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program implements a k-means function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `Features` hyperparameter is commented. In this case, the number
    of features is implicit and determined by the format of the training dataset,
    which contains two columns.
  prefs: []
  type: TYPE_NORMAL
- en: 3 – The k-means clustering algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`sklearn` now does the job using the training dataset and hyperparameters in
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gcenters` array contains the geometric centers or centroids and can be
    printed for verification purposes, as shown in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These geometric centers need to be visualized with labels for decision-making
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 4 – Defining the result labels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The initial unlabeled data can now be classified into cluster labels, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Colors can be used for semantic purposes beyond nice display labels. A color
    for each top customer or leading product can be assigned, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 5 – Displaying the results – data points and clusters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make sense to a team or management, the program now prepares to display
    the results as **data points** and **clusters**. The data will be represented
    as coordinates and the clusters as colors with a **geometric center** or **centroid**,
    as implemented in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset is now ready to be analyzed. The data has been transformed into
    data points (Cartesian points) and clusters (the colors). The *x* points represent
    the geometric centers or centroids, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/KMeansClusters.jpg](img/B15438_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Output (data points and clusters)'
  prefs: []
  type: TYPE_NORMAL
- en: Test dataset and prediction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this case, the test dataset has two main functions. First, some test data
    confirms the **prediction** level of the trained and now-labeled dataset. The
    input contains random distances and locations. The following code implements the
    output that predicts which cluster the data points will be in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second purpose, in the future, will be to enter data for **decision-making**
    purposes, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, `k-means_clustering_1.py` will save the model using Pickle.
    Pickle, a Python library, saves the model in a serialized file, as shown at the
    end of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python Pickle module is imported in the header of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the model, `kmeans`, is saved in a file named `kmc_model.sav`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this model, we will now open `k-means_clustering_2.py` to load the
    model without any training involved and make predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`kmc_model.save` is loaded and plugged into a classifier called `kmeans`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`x_test` same test data as in `k-means_clustering_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now run and display the predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The predictions are the same as in `k-means_clustering_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each prediction is an output cluster number from 0 to 5 of the corresponding
    coordinates used as input. For example, [40.0,67] is a part of cluster #0.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to analyze the results.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following image shows the gain zone. The gain zone is the zone in which
    the distances exceed the value 80.
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/KMeansClusters_2.jpg](img/B15438_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Gain zone area'
  prefs: []
  type: TYPE_NORMAL
- en: The gain zone area provides useful information.
  prefs: []
  type: TYPE_NORMAL
- en: From the computations made, that gain zone shows the losses made on the locations
    displayed. It takes a sample of the possible locations into account. 10% of the
    total distance could be saved.
  prefs: []
  type: TYPE_NORMAL
- en: The cause is that the bots are not going directly to the right locations, but
    are *wandering* around unplanned obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The average distance from one location to another is 1 meter. The AGVs all start
    from location 0 or 1\. So the distance is strictly proportional to the locations
    in this particular example.
  prefs: []
  type: TYPE_NORMAL
- en: To find the gain zone of a location, you draw a red horizontal line from location
    80, for example, and a vertical line from a distance 80 (add a couple of meters
    to take small variances into account).
  prefs: []
  type: TYPE_NORMAL
- en: Data analysis is made easier by data visualization. Visualizing the clusters
    makes it easier for management to understand the outputs and make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: None of the data points on the 80-location line should be beyond the maximum
    limit. The limit is 80 meters + a small variance of a few meters. Beyond that
    line, on the right-hand side of the figure, is where the company is losing money,
    and something must be done to optimize the distances. This loss zone is the gain
    zone for a project. The gain zone on the k-means cluster results shows that some
    of the locations of 40 to 60 exceed a distance of 80 meters.
  prefs: []
  type: TYPE_NORMAL
- en: Bot virtual clusters as a solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Planners anticipate bot tasks. They send them to probable locations from which
    they will have to pick up products and bring them back to the truck-loading points.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will take the example of AGVs that are assigned
    to a cluster area for locations 40 to 60\. If an AGV goes further, up to location
    70, for example, a penalty of 10 virtual (estimated) meters is added to its performance.
    It is easy to check. If an AGV is detected at location 70, it is out of its area.
  prefs: []
  type: TYPE_NORMAL
- en: The business rule for the AGV assigned to locations 40 to 60 is that it must
    never exceed location 60\. If the software planning the events works well, it
    will never assign the AGV to an area exceeding location 60\. Business rules must
    thus be provided to the planners.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the solutions is to provide AGV virtual clusters as a business rule,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/02/KMeansClusters3.jpg](img/B15438_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: AGV virtual clusters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**: The line in the middle represents a new business rule. In phase
    1 of the project, an AGV used for locations 40 to 60 cannot go beyond 60 meters
    plus a small variance line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2**: A cluster will represent the pick-up zone for an AGV. The centroid
    will now be its parking zone. Distances will be optimized until all the clusters
    respect rule 1\. If rule 1 is not followed, the AGVs will travel unnecessary distances,
    increasing the overall cost of transporting goods in the warehouse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The limits of the implementation of the k-means clustering algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, an example was explored. When the volumes increase, the features
    reach high-level abstract representations, and noise pollutes the data, humans
    face several problems:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we analyze a result that surpasses human analytical capacity?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the algorithm reliable for larger datasets that may contain features that
    were overlooked?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 5*, *How to Use Decision Trees to Enhance k-Means Clustering*, we
    will explore these problems and find solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have explored Python with the NumPy, TensorFlow, scikit-learn,
    pandas, and Matplotlib libraries. More platforms and libraries will be used in
    this book. In the months and years to come, even more languages, libraries, frameworks,
    and platforms will appear on the market.
  prefs: []
  type: TYPE_NORMAL
- en: '*However, AI is not only about development techniques*. Building a k-means
    clustering program from scratch requires careful planning. The program relies
    on data that is rarely available as we expect it. That''s where our imagination
    comes in handy to find the right features for our datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the dataset has been defined, poor conditioning can compromise the project.
    Some small changes in the data will lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the training dataset from scratch takes much more time than we would
    initially expect. AI was designed to make life easier, but that's after a project
    has been successfully implemented. The problem is that building a solution requires
    major dataset work and constant surveillance.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the hard work of programming a k-means clustering solution that must
    be explained to a team. Lloyd's algorithm comes in very handy to that effect by
    reducing development time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *When and How to Use Artificial Intelligence*, we will
    seek solutions to the limits of k-means clustering problems through dataset techniques.
    We will also explore random forests and enter the world of ensemble meta-algorithms,
    which will provide assisted AI to humans to analyze machine thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can a prototype be built with random data in corporate environments? (Yes |
    No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do design matrices contain one example per matrix? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AGVs can never be widespread. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can k-means clustering be applied to drone traffic? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can k-means clustering be applied to forecasting? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lloyd's algorithm is a two-step approach. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do hyperparameters control the behavior of the algorithm? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a program works, the way it is presented does not matter. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: k-means clustering is only a classification algorithm. It's not a prediction
    algorithm. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scikit-learn website contains additional information on k-means clustering:
    [http://scikitlearn.org/stable/modules/generated/sklearn.cluster.KMeans.html](http://scikitlearn.org/stable/modules/generated/sklearn.cluster.KMeans.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find Python''s data analysis library here: [https://pandas.pydata.org/](https://pandas.pydata.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
