- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Genetic Algorithms in Hybrid Neural Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the following two chapters, we will explore the world inside
    us. First, in this chapter, we will use the model of our genes as an optimizing
    tool. In *Chapter 18*, *Neuromorphic Computing*, we will enter our biological
    brain activity and create neuromorphic networks. Finally, in *Chapter 19*, *Quantum
    Computing*, we will go even deeper and use the quantum material in us to build
    quantum mechanic models for quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: A slight change in any of these tiny entities (genes, neurons, qubits) within
    us can modify our whole existence.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discover how to enter our chromosome, find our genes,
    and understand how our reproduction process works. From there, we will begin to implement
    an evolutionary algorithm in Python, a **genetic algorithm** (**GA**).
  prefs: []
  type: TYPE_NORMAL
- en: Charles Darwin offered "survival of the fittest" as a model to represent evolution.
    In some ways, the model is controversial. In 21st century societies, we tend to
    provide support to those who are not the fittest, as best as possible. However,
    in mathematics, we do not have this ethical problem.
  prefs: []
  type: TYPE_NORMAL
- en: In AI, we need to provide an accurate solution. If we generate several solutions,
    we can apply the "survival of the fittest" to abstract numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, GAs dramatically reduce the number of combinations required to
    find the optimal solution to a problem. By generating mathematical offspring,
    choosing the fittest, and producing new stronger abstract generations, the system
    often reaches a more optimal solution than propagating permutations.
  prefs: []
  type: TYPE_NORMAL
- en: A well-designed GA can optimize the architecture of a neural network, thereby
    producing a hybrid neural network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary algorithms; genetic algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the genes of genetic algorithms to optimizing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid neural networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a genetic algorithm to optimize an LSTM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by first working to understand what evolutionary algorithms are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding evolutionary algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will drill down from our heredity down to our genes to understand
    the process that we will then represent while building our Python program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Successive generations of humans activate some genes and not others, producing
    the wonderful diversity of humanity. A human lifetime is an episode in a long
    line of thousands of generations of humans. We all have two parents, four grandparents,
    and eight great-grandparents, which amounts to 2³ ascendants. Suppose that we
    extend this line of reasoning to four generations per century and then over about
    12,000 years when the last glacial period ended and the planet started warming
    up. We obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 * 1 century * 10 centuries = 1,000 years and 40 generations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 40 generations * 12= 480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding up to 2^(480) mathematical ascendants to anybody living today on the
    planet!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if we limit ourselves to 1,000 years, 2^(40), that adds up to 1,099,511,627,776
    ascendants a thousand years ago. But there is a problem. This figure is impossible!
    Today, we have reached the height of the human population, which is only 7,500,000,000\.
    So, this means that our ascendants had many children who married their cousins
    of all degrees, making humanity one large extended family, no matter what our
    skin color or hair color is!
  prefs: []
  type: TYPE_NORMAL
- en: Heredity in humans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, men fertilize women when a male cell unites with a female cell. The fertilized
    egg grows and, after quite an adventure, is born and becomes one of us writing
    or reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: To grow and live from being a fertilized egg to human adults, we must gather
    much of the outside world, absorb, and transform it.
  prefs: []
  type: TYPE_NORMAL
- en: This transformation of food and materials by us until we grow into something
    that is more or less like our ancestors is called heredity.
  prefs: []
  type: TYPE_NORMAL
- en: If life were calm and quiet, nothing noticeable would occur. However, our environment
    has exerted relentless pressure on us for millions of years, back to when we were
    just some kind of bacteria floating around in an ocean somewhere. That pressure
    brought about continuous natural selection; what worked would live on, whilst
    what didn't work would die out.
  prefs: []
  type: TYPE_NORMAL
- en: That pressure continues up to present day, forcing us, humans, to adapt genetically
    or disappear. Those humans who failed to adapt to face the pressure of their environment
    died out. We who live today have survived.
  prefs: []
  type: TYPE_NORMAL
- en: Evolution can be defined as a state of constant conflict. On one hand we have
    our relentless, often hostile environment. On the other, our equally relentless
    genes; many of which die out, but others morph, adapt, and continue on through
    heredity—indeed, they're doing that even now, and who knows what is going to happen
    next?
  prefs: []
  type: TYPE_NORMAL
- en: Our cells
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our cells, the nucleus contains personal biological data in the form of chromosomes.
    Our cells contain 46 chromosomes per cell, which, in turn, are formed by 23 pairs
    of chromosomes. One of these pairs is a sex cell to determine our sex.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the chromosomes, we have genes, especially the mitochondrial genome,
    which is the DNA in tiny cells that take our food and transform it into fuel for
    our cells. Each cell is a microscopic busy factory containing thousands of genes!
  prefs: []
  type: TYPE_NORMAL
- en: The human genome describes an incredible set of sequences for our building blocks contained
    in the 23 chromosomes of our cells.
  prefs: []
  type: TYPE_NORMAL
- en: How heredity works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Except for the sex cells, we inherit twenty-three of our mother's forty-six
    chromosomes and twenty-three of our father's chromosomes. In turn, our parents'
    cells contain the chromosomes of their parents—our grandparents—and so on in various
    proportions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example to view the complexity of what we are facing. We will
    take one of our parents, either our mother or father. *P* represents the set of
    chromosomes of that parent.
  prefs: []
  type: TYPE_NORMAL
- en: Letters with primes will represent their fathers'—our grandfathers'—chromosomes,
    and letters with double primes will represent their mothers'—our grandmothers'—chromosomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent this as follows for your father in his sex cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For your mother, the last chromosome of the first set would be an *X* in her
    sex cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Women are *X*-*X* and men *X*-*Y*.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the possibilities!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only take *A*, *B*, and *C* in only one of our parent''s cells, we already
    obtain the following set, *C*, of the eight combinations we would inherit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_003.png)'
  prefs: []
  type: TYPE_IMG
- en: If we extend this to the twenty-three chromosomes, the distribution climbs up
    to 2^(23), or 8,388,608 possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Our evolutionary process contains the right potential for evolutionary algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will drill down further into evolutionary algorithms, getting
    closer to our Python programs. Evolutionary algorithms can be used in any field
    in which combinations are useful: scheduling, medical research on DNA, weather
    forecasting, neural network architecture optimizing and a limitless number of domains.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Evolutionary computation* is a set of algorithms that apply trial-and-error
    techniques to reproduce an abstract mathematical version of biological evolution.
    This mathematical model does not contend with having solved the difficult task
    of explaining evolution, which naturally cannot be reduced to a few equations.'
  prefs: []
  type: TYPE_NORMAL
- en: However, our biological environment produces frameworks that, though the fruits
    of our imagination, enable us to create efficient abstract algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary algorithms enter the category of *evolutionary computation*. An
    evolutionary algorithm contains processes such as mutation, crossover, and selection.
    Many models can achieve the goals set for an evolutionary process.
  prefs: []
  type: TYPE_NORMAL
- en: A GA introduces the category of an evolutionary algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We will first define the concepts involved in a GA, which are the building blocks
    of a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Going from a biological model to an algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways of creating a GA model. You can reproduce the exact description
    of the human model described in the preceding section, you can simplify it, or
    you can create another view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our model will contain a set of genes in a chromosome and a population to interact with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: Chromosomes in genes'
  prefs: []
  type: TYPE_NORMAL
- en: Our model is an abstract model for algorithms, not the actual representation
    of human chromosomes that come in pairs, for example. A gene in an individual's
    chromosome will interact with the gene set of the population. This process will
    be defined in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s first describe the concepts of the building blocks of our Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**: Target defines the length and properties of the child we wish to
    obtain after *n* generations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our model, the target can be specified or unspecified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A specified target contains a length and its value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, our environment requires an exact gene set to remain fit in that environment.
    See the following fitness function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An unspecified target contains a length, but not its actual value, which must be
    found by the GA after *n* generations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, our environment does not require an exact gene, but rather a gene
    with the features required to remain fit in that environment. See the following
    fitness function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Population**: Population first defines the selection of an individual at
    random we will call **parent** that will contain a certain length of its string
    of genes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Population also defines the potential individuals the parent can interact with to
    produce a child. In our genetic simulation, the size of the population is represented
    by the gene set of the population (see the following point).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Gene set of the parent**: The gene set of the parent will first be a random
    set of genes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gene set of the population**: This parent will then randomly encounter another
    person in the population with random gene choices. This population is represented
    by a gene set that we will draw genes from randomly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since a given population can possess any or several of these genes, our population
    is very large from the start.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Selection**: We will select genes randomly from our gene set to simulate
    the meeting of our parent with another parent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Crossover**: We will then form a child from the parent and the random gene
    taken from our population represented by the gene set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our model, once the random selection of the gene has been made, the gene will
    be replaced by a random gene taken from the population represented by the gene
    set of the population:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the new gene must be different from the old gene during the crossover
    in our algorithm. Our algorithm thus avoids getting stuck in some local combination
    during the reproduction phase. Child after child, we will produce new generations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mutation**: We will not accept the same gene from a parent to form a child.
    If we detect this, we will randomly change a gene to make sure each generation
    is different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As described in the *Crossover* paragraph, we will not accept a child with the same
    genes as a parent. As seen in the heredity section of this chapter, it is unlikely
    that a child would inherit exactly all of the genes of a given parent. *Diversity*
    is the key to producing generation after generation of children that will adapt
    to their environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our model, a diversity rule forcing mutation has been introduced:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We thus introduce an alternate gene, as we will see while building the Python
    program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Child**: Child defines a set of genes that contains the same number of genes
    as the parent but with new genes. Generations of children of child gene strings
    will be produced and then complete the selection process with a fitness function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fitness**: Fitness defines the value of the child as defined in a given model.
    The fittest will then be selected to be the parent for the next generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our model, we have two fitness functions that we define in a scenario variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If `scenario=1`, then a specified target scenario will be activated. The target
    will be specified to fit the surrounding environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Polar bears became white, for example, to blend in with the surrounding snow
    and ice of their environment. In other areas, bears are often brown, for example,
    to blend in with the surrounding vegetation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The fitness function thus has a target to reach. For example, in one instance
    in the program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This target could mean many things, as we will see. In the case of the bears,
    maybe these genes in one of their chromosomes trigger off their color: white or
    brown.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If our program simulating nature does not produce the right gene in a given generation,
    this means that the bear is not mutating correctly and will not survive. The fitness
    function of the Python program simulates nature by only keeping the strings of
    genes that make the child evolve in the right direction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The specified target, in this case, is an identified string of genes that will
    make a life-and-death difference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we will see later, `scenario==1` will make sure that the exact gene set required
    to survive is reached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If `scenario=0`, then an unspecified target will be activated. The length of
    the target is not specified. However, a feature set will define the value of the gene
    set of the population. This feature contains numerical values that open the door
    to any optimization you wish to solve, as we will see in the Python program example.
    This numerical set is called the KPI set because the values are key performance
    indicators of the system we will explore in this model:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `KPIset` feature set matches the size of the gene set of the population.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Building a genetic algorithm in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now build a GA from scratch using `GA.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `.py` version. The code is the same, although the line numbers
    in this chapter refer to the Jupyter notebook cells of the `.ipynb` version.
  prefs: []
  type: TYPE_NORMAL
- en: At all times, you can go back to the previous section, *Basic concepts*, to
    consult the definitions used to describe the Python program in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This program is built from scratch with no higher-level library to get the
    feel of a GA. Three lines are enough to get everything working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Calling the algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this program, we will be exploring three scenarios. Two scenarios generate
    specified targets, and one generates an unspecified target.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with a specified target and then move to the more advanced unspecified
    target that will prepare us for hybrid networks using a GA.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first go to the *Calling the Algorithm* cell of the program. The first
    task is to define which scenario and type of fitness function we will use on line
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `scenario=1`, the program generates the correct exact genes for a child from
    several generations, starting with a random seed parent.
  prefs: []
  type: TYPE_NORMAL
- en: If `scenario=0`, the program generates the best features of a type of genes
    of a child from several generations, starting with a random seed parent.
  prefs: []
  type: TYPE_NORMAL
- en: In line 4, `GA=2` defines which target we are dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `GA=1`, the gene set of the population and the target are defined. The main function
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the gene set of the population is printed along with the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last line calls `ga_main()`, the main function.
  prefs: []
  type: TYPE_NORMAL
- en: The main function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code is in the `ga_main()` cell of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ga_main()` function is divided into three parts: parent generation, child
    generation, and a summary.'
  prefs: []
  type: TYPE_NORMAL
- en: The parent generation process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parent generation runs from line 2 to line 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`startTime` indicates the start time, which is printed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`alphaParent` is the first parent who will be created by the `gen_parent` function,
    which will be described in the following Jupyter notebook cell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bestFitness` is the fitness estimated by the `get_fitness` function, which
    will be described in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`display` is the function that describes the result of this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have a process that creates a parent: `gen_parent`, `get_fitness`, and
    `display`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now explore the parent generation function before resuming the main
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a parent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parent generation function cell starts with zero genes and the length of
    the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`length` = the length of the target. The target is `"Algorithm"`, so `length=9`.'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the process, the parent has no genes since the goal of this
    function is to produce a parent at random that contains a string of genes that
    is equal to the length of the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string of genes to produce a parent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a `while` loop starts on line 3 of the cell to fill `genes[]` until it
    reaches the target''s length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`sampleSize` is the sample of genes required from the gene set, `geneSet`,
    from which to choose a random gene for the parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`genes.extend` adds a random gene to the `genes` array from `geneSet`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the parent''s gene set, `genes[]`, has reached the target''s length, the
    `return` function sends the parent back to the main function, `ga_main()`, where
    it is displayed with the `display` function. The output of the parent in this
    random run was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, the parent will be different at each run since this is a random process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string of genes is now returned to the `ga_main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's explore the fitness function and the `display` function.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point in the `ga_main()` function, the start time was printed out,
    and the parent created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to evaluate the fitness of the parent before creating generations of
    children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this paragraph, we will only describe the specified target case, which is
    part of `scenario=1`. We will create a fitness function with the target of a given
    choice. In this case, only the sum of correct genes is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`this_choice` is the parent string of genes produced by the `gen_parent` function
    described in the preceding code snippet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scenario` indicates whether the function calculates the sum of fit genes or
    evaluates the features of the genes. In this case, the sum of the correct genes
    is calculated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fitness is the number of correct genes found when comparing the target, the expected
    value, to actual, the `this_choice` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `expected==actual`, the sum is incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip`, in Python, is an efficient feature that iterates over two lists at the
    same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once fitness, the sum of fit genes, is calculated, the function returns the
    value to the `ga_main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The parent generation will now be displayed by a function called in `main_ga()`.
  prefs: []
  type: TYPE_NORMAL
- en: Display parent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, `ga_main()` has printed the start time, created a parent, and
    evaluated its fitness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will now display the basic information concerning the first generation:
    the parent generation called the `display` function from `main_ga()`, line 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`alphaParent` is the gene string of the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bestFitness` is its fitness'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is no child yet, `bestFitness` is sent as the default value of a
    child's fitness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the display parent cell, line 2, the `display` function receives the data
    sent by `main_ga()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display` function calculates the time it has taken and prints the information
    in a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`selection` is the string of genes of this generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bestFitness` is the value of the best string of genes created up to now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`childFitness` is this generation''s fitness value. The first generation is
    the value of the parent who has, for the moment, the fittest genes. The parent
    is the child of another parent, although this parent is the first generation we are
    taking into consideration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeDiff` is an important value when dealing with larger gene sets. It will
    help detect whether the algorithm is running well or reaching its limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be displayed for the parent generation and each generation
    that gets closer to the fittest generation defined by the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This output will vary during each run of the program since this is a stochastic
    algorithm simulating the random events that occur in our natural and artificial
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring the loop that creates an unlimited number of generations, let's
    build the crossover function.
  prefs: []
  type: TYPE_NORMAL
- en: Crossover and mutation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our model contains a `crossover` function with a mutation rule to ensure diversity.
  prefs: []
  type: TYPE_NORMAL
- en: The `crossover` function starts with the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each child of each generation will become the parent of another child.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in nature, a random gene in a parent''s gene will be selected to be replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index` designates the exact location of the gene that will be replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Chromosomes in genes'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that gene **D** in the chromosome will be replaced by the gene **z**
    of an individual of the population.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we simulate the reproduction phase. The child inherits the genes of its
    parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The parent's string of genes is converted into a list with the `list` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm stores the parent''s gene to replace in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`oldGene` will be compared to the new gene generated to make sure that diversity
    is respected so as to avoid getting stuck in a local loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new gene is chosen at random in the gene set of the population to simulate
    the interaction of the child with a given person among an indefinite number of
    persons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that at the same time, the new gene, `newGene`, is selected at random,
    while an alternate gene, `alternate`, is chosen as well. `alternate` is chosen
    to replace `newGene` to avoid making the wrong choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the new gene, `newGene`, is not equal to the old gene, `oldGene`, that the
    child can inherit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The new gene becomes part of the string of genes of the child.
  prefs: []
  type: TYPE_NORMAL
- en: However, if `newGene` is the same as `oldGene`, this could compromise the whole
    genetic process, with generations of children that do not evolve. Also, the algorithm
    might get stuck or waste quite some time making the right selections.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the alternate gene comes in and becomes part of the string of
    genes of the child. This crossover rule and this alternate rule simulates the
    mutation process of this model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Diversity has been verified!
  prefs: []
  type: TYPE_NORMAL
- en: 'The function now returns the new string of genes of the child so that its fitness
    value can be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Producing generations of children
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we have generated the parent and explored the basic concepts
    and functions.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready for the generation loop. First, we will view the code, then represent
    it in a flowchart, and then describe the lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the parent has been created, we enter the loop that simulates the evolutionary
    process for many generations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop is best represented in a flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Genetic algorithm flow chart'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of the flowchart is based on Python''s `continue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that precedes the condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Increments the generation counter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calls the `crossover` function to produce a child:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calls the fitness function to obtain the fitness value:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The condition to see if the `childFitness` is higher than the `bestFitness`
    obtained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the condition is `True`, then the evolution must continue until a child is
    fitter than its parent. This sends the process back to the top of the `while`
    loop.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the condition is `False`, this means that the child is fitter than the parent,
    and then the code will go beyond the condition.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code beyond the condition and `continue` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code displays the child, the `bestFitness` becomes the `childFitness`,
    and the `bestParent` is now the child:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The goal of the two scenarios of our model is defined. The goal of `scenario==1`
    is to reach the length of the target with the right genes. The goal of `scenario==0`
    will be to reach a threshold we will define in the next section:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `break` condition of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The evolutionary process will stop when the fittest child has been created
    after several generations containing the genes that meet the target:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the *n* generations will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can see the display of all of the generations as described in the `display`
    function in the *Display parent* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the evolutionary process is over, a summary code takes over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the example displayed for the evolutionary loop is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on, it is important to note that using permutations for 9 out
    of 55 elements, it would take 10 ** 15.36 calculations to reach the goal instead
    of the 782 generations in this example. GAs are thus a productive way of generating
    permutations.
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored the core of the evolutionary process and the Python code.
    We will now build the unspecified target and optimizing code that will lead us
    to hybrid neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: Unspecified target to optimize the architecture of a neural network with a genetic
    algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are laying the grounds and motivation to optimize the architecture of
    neural networks through a hybrid neural network. The architecture of a physical
    neural network will be optimized by a GA.
  prefs: []
  type: TYPE_NORMAL
- en: We will study a physical neural network and then see how to optimize its architecture
    with our GA.
  prefs: []
  type: TYPE_NORMAL
- en: A physical neural network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will begin with a physical network named S-FNN, a **feedforward neural network**
    (**FNN**). Please look very closely at the following figure and take as much time
    as necessary to understand its architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15438_17_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Architecture of a neural network'
  prefs: []
  type: TYPE_NORMAL
- en: 'This physical network has some important specific features:'
  prefs: []
  type: TYPE_NORMAL
- en: This is an FNN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are three layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The neurons in each layer are not fully connected to the neurons of the next layer.
    The connections between the neurons of the three layers are not based on all of
    the possibilities. The connections between the layers are based upon statistics
    of the best connections in the past when running this network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The connections are the result of many runs of this network to determine which
    ones are the best.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The connections represented are the most productive ones, leading to an output
    of `1` and not `0`. An output of `1` is a success, while an output of `0` is a
    failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input is a random value of the dataset that must be classified as `1` if
    it is a success and `0` if it is a failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a careful study of past runs of this network, it has been found that the productivity
    of the network fully relies, in this example, on the number and quality of the
    neurons in layer 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's use what we have learned and apply it to the architecture of a soccer
    team.
  prefs: []
  type: TYPE_NORMAL
- en: What is the nature of this mysterious S-FNN?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: S-FNN is a soccer team's architecture! It is the representation of a 3-4-3 disposition
    of a soccer team before a given game.
  prefs: []
  type: TYPE_NORMAL
- en: Like abstract neural networks, the number and quality of neurons we choose per
    layer are critical. In our abstract world of **artificial neural networks** (**ANNs**),
    we have many problems to solve. How many should we keep? How many should we eliminate
    through pooling layers? How many should we abandon through dropout layers? How
    do we really know? How long will trial and error take with large datasets and
    networks?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the figure, read the following explanation, and start
    finding a method to solve the architectural complexity of a neural network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input** represents the goal of best possible choices to input the ball in
    the game based on past game statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 1** is the defense layer of three players represented by three neurons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 2** is the middle field, the result of the transformation of layer
    1''s activity, the statistics of past games showing the fittest, the connections.
    The initial ball of the input has now been flowing through these layers game after
    game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3** is the attack layer, the one that will lead to the output classification;
    1 for a success meaning a goal has been scored, or 0 for failure. The connections
    between layer 2 and layer 3 show the fittest results found game after game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The problem to solve**: Layer 2, in our example, has been identified as the
    critical layer in this team. For years now, it has been a weak point. Let''s see
    how our GA will help find the fittest players for this layer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could run `scenario==1` (specified target) with target `ga==3` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `geneSet` is the population of available players on the soccer market and
    `target` is the string of genes we need for layer 2 of our physical network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The target is found after 851 generations in this run.
  prefs: []
  type: TYPE_NORMAL
- en: However, we would like the GA to find the players by itself based on the features
    with an unspecified target. Let's explore this step by step, cell by cell.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the algorithm cell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From lines 7 to 12, we defined the parameters of the target architecture we
    want for layer 2 of our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '`geneSet` is the set of all the available players for layer 2 of our network,
    whether they are in the team or on the market:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`KPIset`, or the key performance indicator set, is a performance score per
    player on the market for middle field. Each integer of the set contains a score
    between 0 and 9 based on the statistics of a player when playing as a midfielder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The KPI set matches each member of the gene set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`threshold` is the sum of the midfielders'' performance we need to attain in
    order to have a strong midfield in the team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our goal is to find a string of genes based on their features, their KPI properties.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to reach the threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call our evolutionary function on line 23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `target` is set to a meaningless value that will rapidly evolve.
    The GA will have to find a fit sequence.
  prefs: []
  type: TYPE_NORMAL
- en: We can skip the intermediate fitness functions we have described in the previous
    section and focus on the scenarios within the fitness cell.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness cell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already described the fitness function of the fitness cell in the previous
    sections. We will focus on the code of the unspecified target, `scenario==0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the scenario calculates the sum of the performance of each
    gene (potential midfielder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The collective fitness of the sequence of genes (midfielders) is contained in
    the `fitness` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we cannot accept the same gene twice, which would mean we have a clone of
    the midfielder on the field! So, we add some safety code to set `fitness` to `0`
    in that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can go back to `ga_main()` and complete our process.
  prefs: []
  type: TYPE_NORMAL
- en: ga_main() cell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already described the fitness cell in the previous sections. Now, we
    will focus on the code of the unspecified target, `scenario==0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ga_main()` cell, we simply need to examine lines 22 to 24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If the `scenario==0`, `childFitness` must be `>=goal` (sum of KPIs).
  prefs: []
  type: TYPE_NORMAL
- en: We have found our midfielders!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now display the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the GA chose midfielders C, B, F, and D.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all of the ingredients, concepts, and knowledge required to understand an
    artificial hybrid neural network.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial hybrid neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used a GA to optimize a physical neural network.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will extend the concept of *hybrid* we have just explored
    to ANNs. The principle is the same, so it will be relatively easy, with the concepts
    you now have in mind, to intuitively grasp the RNN we will optimize in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The future of AI in society lies in the collective intelligence of humans (diversity),
    machines (AI and IoT), and nature (sustainable projects for our survival).
  prefs: []
  type: TYPE_NORMAL
- en: In AI, this diversity lies in ensemble algorithms, meta-algorithms and hybrid
    systems. Deep learning has proven its point. We can create a neural network with
    TensorFlow 2.x in a few lines. However, more often than not, it takes days, weeks,
    and often months to fine-tune ANN models that rely on large amounts of data to
    provide a reliable model. And that's where hybrid neural networks are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'A deep learning network can use any form of another type of algorithm to become
    a more efficient system. In our case, we have chosen evolutionary algorithms that
    could be used in deep learning:'
  prefs: []
  type: TYPE_NORMAL
- en: To improve the input by extracting sequences of data that fit the patterns we are
    looking for using features of the data to find the fittest data points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To optimize the weights of the layers of a network to boost the speed and power
    of traditional optimizers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve the classification phase of the output of a network by selecting
    the fittest solutions processed as a sequence of genes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve the tedious task of defining the architecture of a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will focus on an example of optimizing the architecture
    of a network with a GA by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RNN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a GA that will optimize the architecture of the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**: For information on genetic algorithm representations, please go back
    to the previous sections at all times to refresh the process of an evolutionary
    algorithm. Please also refer back to the previous chapters to consult the structure
    of a neural network, in particular, *Chapter 16*, *Improving the Emotional Intelligence
    Deficiencies of Chatbots*, which describes an RNN.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the LSTM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open `Genetic_Algorithm_LSTM.ipynb` in Google Colaboratory or Jupyter on your machine
    or `genetic_algorithm_lstm.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The model of this education example is an LSTM.
  prefs: []
  type: TYPE_NORMAL
- en: The goal will be to use the window size generated by the GA and run the LSTM
    with this window size. **Root-mean-square error** (**RMSE**) will be used to measure
    the fitness of the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In short, RMSE first calculates the square of the difference between the training
    data and the testing data, like many similar formulas. Then, the root of the result
    is calculated. Just keep in mind that the RMSE will compare what we expect to
    get with what we actually get and produce a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explore the main cells of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing required packages cell**: `Genetic_Algorithm_LSTM.ipynb` starts by
    installing DEAP, an evolutionary computation framework:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We built a GA from scratch in the previous sections. We won't need to begin from
    nothing this time, since this program uses a framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, the program installs `bitstring`, which helps to process binary data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Loading the data cell**: The data wind power forecast data in `train.csv`
    comes from [https://www.kaggle.com/c/GEF2012-wind-forecasting/data](https://www.kaggle.com/c/GEF2012-wind-forecasting/data).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `wp1` to `wp7` columns provide normalized data collected from measurements
    of the wind power of seven wind farms. The goal of the LSTM will be to take the
    sequence of data and make wind power forecasts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Defining the basic functions cell**: This cell prepares the dataset and trains
    the model in a standard process. We will focus on line 14:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Evolutionary model cell**: The model uses the DEAP framework function, but we
    easily recognize the concepts we explored in the previous sections and that are
    initialized as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is all set with a ready-to-use GA to optimize the window size for our
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in our previous section, the goal is to find the best window size for this
    network, just as we were looking for the best layer 2 in an earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model has done the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Installed the packages, loaded the data, and found the window size of the LSTM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it ran the GA model to test the possible window size of the LSTM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An RMSE measurement is provided with each generation and production of epochs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program takes some time to run, but the results I ran are saved in the
    notebook so that you can view them. Here is one result to view how the system
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous section, a GA optimized a section of an ANN. You can use
    a GA for other components of an ANN. The sky is the limit! In fact, there is no
    limit. The potential of hybrid neural networks using GA or other algorithms to
    optimize their architecture or process takes your projects to another level!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evolutionary algorithms bring new light to AI's optimizing potential. In this
    chapter, we studied how heredity deeply affects population distribution. The impact
    of our environment can be measured through genetic mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down further, we focused on a class of GAs implementing a simulation
    of genetic transformations through many generations. We explored how a parent
    will transmit some genes, but how the selection of diverse genes from the generation
    population of genes will produce variations. A chromosome will inherit some genes
    but not others.
  prefs: []
  type: TYPE_NORMAL
- en: The pressure of nature and our environment will take over. A fitness function
    evaluates a string of genes. Only the fittest will survive. The fittest genetic
    material will produce a crossover and mutation of the child, making it fitter
    for its environment.
  prefs: []
  type: TYPE_NORMAL
- en: GAs can be used to represent strings of any type of data and also features of
    that data. The optimizing process can be applied to warehouses, transportation,
    and neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid networks will no doubt expand in the years to come, taking DL to the
    next level. Using a genetic algorithm to optimize the architecture of an RNN paves
    the way to optimize the architecture of any DL, ML or AutoML architecture. For
    example, a hybrid neural network can use a genetic algorithm to optimize inputs
    with feature reduction or as the weight optimizing function of the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nature has provided us with invaluable tools to apply to our artificial network
    models. This chapter dealt with the invisible building blocks inside us. In the
    next chapter, *Neuromorphic Computing*, we will explore other components that
    enable us to adapt to our environment: neurons. We will explore how neural networks
    using biological models can solve complex problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cell contains 42 chromosomes. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A genetic algorithm is deterministic, not random. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An evolutionary algorithm means that the program code evolves. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is best for a child to have the same genes as one of the parents even after
    many generations. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Diversity makes the gene sets weaker. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building a neural network only takes a few lines, and the architecture always
    works. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building a neural network with a genetic algorithm can help optimize the architecture
    of the layers. (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hybrid neural networks are useless since deep learning will constantly progress.
    (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would you trust a genetic algorithm to make decisions for you? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would you trust a hybrid neural network to optimize the architecture of your
    network? (Yes | No)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://github.com/DEAP/deap](https://github.com/DEAP/deap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pypi.org/project/bitstring/](https://pypi.org/project/bitstring/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
