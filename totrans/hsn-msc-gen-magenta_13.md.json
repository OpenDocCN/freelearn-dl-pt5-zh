["```py\nimport mido\nprint(f\"Input ports: {mido.get_input_names()}\")\nprint(f\"Output ports: {mido.get_output_names()}\")\n```", "```py\nInput ports: ['Midi Through:Midi Through Port-0 14:0']\nOutput ports: ['Midi Through:Midi Through Port-0 14:0']\n```", "```py\nfrom magenta.interfaces.midi.midi_hub import MidiHub\n\n# Doesn't work on Windows if the ports do not exist\nmidi_hub = MidiHub(input_midi_ports=\"magenta_in\",\n                   output_midi_ports=\"magenta_out\",\n                   texture_type=None)\n```", "```py\nimport mido\n\n# Doesn't work on Windows if the ports do not exist\ninport = mido.open_input(\"magenta_in\")\noutport = mido.open_output(\"magenta_out\")\n```", "```py\nInput ports: ['Midi Through:Midi Through Port-0 14:0', 'RtMidiOut Client:magenta_out 128:0']\nOutput ports: ['Midi Through:Midi Through Port-0 14:0', 'RtMidiIn Client:magenta_in 128:0']\n```", "```py\nINFO:tensorflow:Opening '['magenta_out 2']' as a virtual MIDI port for output.\nI1218 15:05:52.208604  6012 midi_hub.py:932] Opening '['magenta_out 2']' as a virtual MIDI port for output.\nTraceback (most recent call last):\n  ...\nNotImplementedError: Virtual ports are not supported by the Windows MultiMedia API.\n```", "```py\nInput ports: ['Midi Through:Midi Through Port-0 14:0', 'RtMidiOut Client:magenta_out 128:0']\nOutput ports: ['FLUID Synth (7171):Synth input port (7171:0) 129:0', 'Midi Through:Midi Through Port-0 14:0', 'RtMidiIn Client:magenta_in 128:0']\n```", "```py\nInput ports: ['magenta_in 0', 'magenta_out 1']\nOutput ports: ['Microsoft GS Wavetable Synth 1', 'magenta_in 2', 'magenta_out 3']\n```", "```py\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--midi_port\", type=str, default=\"FLUID Synth\")\nargs = parser.parse_args()\n\ndef generate(unused_argv):\n # The previous example is here\n ...\n\n  # Write the resulting plot file to the output directory\n  plot_file = os.path.join(\"output\", \"out.html\")\n  pretty_midi = mm.midi_io.note_sequence_to_pretty_midi(sequence)\n  plotter = Plotter()\n  plotter.show(pretty_midi, plot_file)\n  print(f\"Generated plot file: {os.path.abspath(plot_file)}\")\n\n # Write the code to send the generated \"sequence\" to FluidSynth\n  pass\n\n  return 0\n\nif __name__ == \"__main__\":\n  tf.app.run(generate)\n```", "```py\nimport mido\nfrom magenta.interfaces.midi.midi_hub import MidiHub\n\n# We find the proper input port for the software synth\n# (which is the output port for Magenta)\noutput_ports = [name for name in mido.get_output_names()\n if args.midi_port in name]\n\n# Start a new MIDI hub on that port (output only)\nmidi_hub = MidiHub(input_midi_ports=[], \n output_midi_ports=output_ports, \n texture_type=None)\n```", "```py\nimport music_pb2\n\nempty_sequence = music_pb2.NoteSequence()\nplayer = midi_hub.start_playback(empty_sequence, allow_updates=True)\nplayer._channel = 9\n```", "```py\nimport time\nfrom magenta.interfaces.midi.midi_interaction import adjust_sequence_times\n\nwall_start_time = time.time()\nsequence_adjusted = music_pb2.NoteSequence()\nsequence_adjusted.CopyFrom(sequence)\nsequence_adjusted = adjust_sequence_times(sequence_adjusted, \n wall_start_time)\n```", "```py\nplayer.update_sequence(sequence_adjusted, start_time=wall_start_time)\ntry:\n  player.join(generation_end_time)\nexcept KeyboardInterrupt:\n  return 0\nfinally:\n  return 0\n```", "```py\n> python chapter_09_example_02.py\n```", "```py\n> python chapter_09_example_02.py --midi_port=magenta_out\n```", "```py\nWARNING:tensorflow:No input port specified. Capture disabled.\n```", "```py\n> python chapter_09_example_02.py --midi_port=\"magenta_out\"\n```", "```py\nfrom decimal import Decimal\nfrom magenta.common import concurrency\n\nperiod = Decimal(240) / qpm\nperiod = period * (num_bars + 1)\nsleeper = concurrency.Sleeper()\n```", "```py\nwhile True:\n  try:\n    # We get the next tick time by using the period\n    # to find the absolute tick number (since epoch)\n    now = Decimal(time.time())\n tick_number = int(now // period)\n    tick_number_next = tick_number + 1\n tick_time = tick_number * period\n    tick_time_next = tick_number_next * period\n\n    # Update the player time to the current tick time\n    sequence_adjusted = music_pb2.NoteSequence()\n    sequence_adjusted.CopyFrom(sequence)\n sequence_adjusted = adjust_sequence_times(sequence_adjusted,\n float(tick_time))\n player.update_sequence(sequence_adjusted,\n start_time=float(tick_time))\n\n    # Sleep until the next tick time\n sleeper.sleep_until(float(tick_time_next))\n  except KeyboardInterrupt:\n    print(f\"Stopping\")\n    return 0\n```", "```py\n> python chapter_09_example_03.py --midi_port=\"magenta_out\"\n```", "```py\nimport mido\nfrom decimal import Decimal\nfrom threading import Thread\n\nclass Metronome(Thread):\n\n  def __init__(self, outport, qpm):\n    super(Metronome, self).__init__()\n self._message_clock = mido.Message(type='clock')\n self._message_start = mido.Message(type='start')\n self._message_stop = mido.Message(type='stop')\n self._message_reset = mido.Message(type='reset')\n    self._outport = outport\n self._period = Decimal(2.5) / qpm\n    self._stop_signal = False\n\n  def stop(self):\n    self._stop_signal = True\n\n  def run(self):\n # Run code\n pass\n\n```", "```py\nimport time\nfrom magenta.common.concurrency import Sleeper\n\ndef run(self):\n  sleeper = Sleeper()\n\n  # Sends reset and the start, we could also\n  # use the \"continue\" message\n self._outport.send(self._message_reset)\n self._outport.send(self._message_start)\n\n  # Loops until the stop signal is True\n  while not self._stop_signal:\n    # Calculates the next tick for current time\n    now = Decimal(time.time())\n    tick_number = max(0, int(now // self._period) + 1)\n tick_time = tick_number * self._period\n sleeper.sleep_until(float(tick_time))\n\n    # Sends the clock message as soon it wakeup\n self._outport.send(self._message_clock)\n\n  # Sends a stop message when finished\n self._outport.send(self._message_stop)\n```", "```py\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--midi_port\", type=str, default=\"magenta_out\")\nargs = parser.parse_args()\n\ndef send_clock():\n  output_ports = [name for name in mido.get_output_names()\n                  if args.midi_port in name]\n  midi_hub = MidiHub(input_midi_ports=[],\n                     output_midi_ports=output_ports,\n                     texture_type=None)\n outport = midi_hub._outport\n\n  # Starts the metronome at 120 QPM\n metronome = Metronome(outport, 120)\n metronome.start()\n\n  # Waits for 16 seconds and send the stop command\n metronome.join(timeout=16)\n metronome.stop()\n\n  return 0\n\nif __name__ == \"__main__\":\n  send_clock()\n```", "```py\n> python chapter_09_example_04.py --midi_port=\"magenta_out\"\n```", "```py\n> python chapter_09_example_03.py --midi_port=\"MIDIIN2 (Arturia BeatStep Pro) 1\"\n```"]