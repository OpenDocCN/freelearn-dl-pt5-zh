- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Bayesian Deep Learning
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will guide you through a variety of applications of Bayesian deep
    learning (BDL). These will include the use of BDL in standard classification tasks,
    as well as demonstrating how it can be used in more sophisticated ways for out-of-distribution
    detection, data selection, and reinforcement learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover these topics in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting out-of-distribution data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being robust against dataset drift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data selection via uncertainty to keep models fresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uncertainty estimates for smarter reinforcement learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Susceptibility to adversarial input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the code for this book can be found on the GitHub repository for the
    book: [https://github.com/PacktPublishing/Enhancing-Deep-Learning-with-Bayesian-Inference](https://github.com/PacktPublishing/Enhancing-Deep-Learning-with-Bayesian-Inference).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Detecting out-of-distribution data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typical neural networks do not handle out-of-distribution data well. We saw
    in [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals of Deep Learning*](CH3.xhtml#x1-350003)
    that a cat-dog classifier classified an image of a parachute as a dog with more
    than 99% confidence. In this section, we will look into what we can do about this
    vulnerability of neural networks. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the problem visually by perturbing a digit of the `MNIST` dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the typical way out-of-distribution detection performance is reported
    in the literature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the out-of-distribution detection performance of some of the standard
    practical BDL methods we look at in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore even more practical methods that are specifically tailored to detect
    out-of-distribution detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2.1 Exploring the problem of out-of-distribution detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To give you a better understanding of what out-of-distribution performance
    is like, we will start with a visual example. Here is what we will do:'
  prefs: []
  type: TYPE_NORMAL
- en: We will train a standard network on the `MNIST` digit dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then perturb a digit and gradually make it more out-of-distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will report the confidence score of a standard model and MC dropout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this visual example, we can see how simple Bayesian methods can improve
    the out-of-distribution detection performance over a standard deep learning model.
    We start by training a simple model on the `MNIST` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file160.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The classes of the MNIST dataset: 28x28 pixel images of the digits
    zero to nine'
  prefs: []
  type: TYPE_NORMAL
- en: We use `TensorFlow` to train our model, `numpy` to make our images more out-of-distribution,
    and `Matplotlib` to visualize our data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MNIST` dataset is available in TensorFlow, so we can just load it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`MNIST` is a simple dataset, so a simple model allows us to achieve a test
    accuracy of more than 99%. We use a standard CNN with three convolutional layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can then compile and train our model. We obtain a validation accuracy of
    over 99% after just 5 epochs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how this model handles out-of-distribution data. Imagine we
    deploy this model to recognize digits, but users sometimes fail to write down
    the entire digit. What happens when users do not write down the entire digit?
    We can get an answer to this question by gradually removing more and more information
    from a digit, and seeing how our model handles the perturbed inputs. We can define
    our function to remove `signal` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we perturb our images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We only add perturbed images to our list of images if setting a row to 0 actually
    changes the original image ( `if np.array_equal(img, img_perturbed))` and stop
    once the image is completely black, meaning it just contains pixels with a value
    of 0\. We run inference on these images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then plot all images with their predicted labels and confidence scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file161.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Predicted label and corresponding softmax score of a standard neural
    network for an image that is more and more out-of-distribution'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Figure* [*8.2*](#x1-135222r2) that, initially, our model confidently
    classifies the image as a **2**. Remarkably, this confidence persists even when
    it seems unreasonable to do so. For example, the model still classifies image
    14 as a **2** with 97.83% confidence. Moreover, the model predicts with 92.32%
    confidence that a completely horizontal line is a **1**, as we can see in image
    17\. It looks like our model is overconfident in its predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what a slightly different model would predict on these images. We’ll
    now use MC dropout as our model. By sampling, we should be able to increase the
    models’ uncertainty compared to a standard NN. Let’s first define our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let’s instantiate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our model with dropout will achieve a similar accuracy as our vanilla model.
    Let’s now run inference with dropout and plot the mean confidence score of MC
    dropout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This again produces a figure showing the predicted labels and their associated
    confidence scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file162.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Predicted label and corresponding softmax score of an MC dropout
    network for an image that is more and more out-of-distribution'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in *Figure* [*8.3*](#x1-135306r3) that the model is less certain
    on average. The model’s confidence decreases a lot when we remove rows from our
    image. That is desired behaviour: our model does not know the input, so it should
    be uncertain. However, we can also see that the model is not perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: It maintains a pretty high confidence for images that do not really look like
    a **2**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model’s confidence can change a lot when we delete one more row from our
    images. For example, the model’s confidence jumps from 61.72% to 37.20% between
    image 14 and 15.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model seems to be more confident that image 20, without any white pixels,
    is a **1**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MC dropout is, in this case, a step in the right direction, but is not handling
    the out-of-distribution data perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Systematically evaluating OOD detection performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding example suggests that MC dropout gives out-of-distribution images
    a lower confidence score on average. But we only evaluated 20 images with a limited
    variety – we simply removed a single row. This change moved the image more out-of-distribution,
    but all images shown in the previous section are relatively similar to the training
    distribution of `MNIST` if you compare it to, let’s say, natural images of objects.
    Images of airplanes, cars, or birds will definitely be much more out-of-distribution
    than an image of `MNIST` with a few black rows. So it seems to be reasonable that,
    if we want to evaluate the OOD detection performance of our model, we should also
    test it on images that are even more OOD, that is, from a completely different
    dataset. This is the approach that is typically taken in the literature to evaluate
    out-of-distribution detection performance. The procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We train a model on in-distribution (ID) images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We take one or more completely different OOD datasets and feed these to our
    model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now treat the predictions of the model on the ID and OOD test datasets as
    a binary problem and compute a single score for every image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of evaluation of the softmax score, this means that we take the
    model’s maximum softmax score for every ID and OOD image.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With these scores, we can compute binary metrics, such as the area under the
    receiver operating characteristic (AUROC).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The better the model performs on these binary metrics, the better the model’s
    OOD detection performance.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3 Simple out-of-distribution detection without retraining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although MC dropout can be an effective method to detect out-of-distribution
    data, it comes with a major disadvantage at inference time: we need to run inference
    five, or maybe even a hundred, times instead of just once. Something similar can
    be said for certain other Bayesian deep learning methods: although they are principled,
    they are not always the most practical way to obtain a good OOD detection performance.
    The main downside is that they often require retraining of your network, which
    can be expensive to do if you have a lot of data. This is why there is an entire
    field of OOD detection methods that are not explicitly grounded on Bayesian theory,
    but can provide a good, simple, or even excellent baseline. These methods often
    do not require any retraining and can be applied out of the box on a standard
    neural network. Two methods that are often used in the OOD detection literature
    are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ODIN**: OOD detection with preprocessing and scaling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mahalanobis**: OOD detection with intermediate features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ODIN: OOD detection with preprocessing and scaling'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*O*ut-of-*DI*stribution detector for *N*eural networks (ODIN) is one of the
    standard methods in practical out-of-distribution detection because of its simplicity
    and effectiveness. Although the method was introduced in 2017, it is still frequently
    used as a comparison method in papers that propose out-of-distribution detection
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ODIN consists of two key ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Temperature scaling** of the logit scores before applying the softmax operation
    to improve the ability of the softmax score to distinguish between in- and out-of-distribution
    images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input preprocessing** to make in-distribution images more in-distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at both ideas in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Temperature scaling ODIN works for classification models. Given our softmax
    score computed as
  prefs: []
  type: TYPE_NORMAL
- en: '![pi(x) = ∑--exp(fi(x))--- Nj=1 exp(fj(x)) ](img/file163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *f*[*i*](*x*) is a single logit output and *f*[*j*](*x*) are the logits
    for all classes for a single example, temperature scaling means that we divide
    these logit outputs by a constant *T*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ exp(f (x)∕T) pi(x; T) = ∑N------i---------- j=1 exp (fj(x)∕T) ](img/file164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For large values of *T*, temperature scaling causes the softmax scores to be
    closer to a uniform distribution, which helps to reduce overconfident predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply temperature scaling in Python, given a simple model that outputs
    the logits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Input preprocessing We saw in [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals
    of Deep Learning*](CH3.xhtml#x1-350003) that the **Fast-Gradient** **Sign Method**
    (**FGSM**) allowed us to fool a neural network. By slightly changing an image
    of a cat, we could make the model predict ”dog” with 99.41% confidence. The idea
    here was that we could take the sign of the gradient of the loss with respect
    to the input, multiply it by a small value and add that noise to our image – this
    moved our image away from our in-distribution class. By doing the opposite, that
    is, subtracting the noise from our image, we make the image more in-distribution.
    The authors of the ODIN paper show that this causes in-distribution images to
    have an even higher softmax score compared to out-of-distribution images. This
    means that we increase the difference between OOD and ID softmax scores, leading
    to a better OOD detection performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![˜x = x − 𝜀sign(− ∇x log Sˆy(x;T)) ](img/file165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where *x* is an input image of which we subtract the perturbation magnitude
    *𝜖* times the sign of the gradient of the cross-entropy loss with respect to the
    input. See [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals of Deep Learning*](CH3.xhtml#x1-350003)
    for the TensorFlow implementation of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although input preprocessing and temperature scaling are simple to implement,
    ODIN now requires two more hyperparameters to be tuned: the temperature for scaling
    the logits and *𝜖* of the inverse of the fast gradient sign method. ODIN uses
    a separate out-of-distribution dataset to tune these hyperparameters (the validation
    set of the iSUN dataset: 8925 images).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mahalanobis: OOD Detection with intermediate features'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In *A Simple Unified Framework for Detecting Out-of-Distribution Samples and*
    *Adversarial Attacks*, Kimin Lee et al. propose a different method to detect OOD
    input. The core of their method is the idea that each class of a classifier follows
    a multivariate Gaussian distribution in the feature space of a network. Given
    this idea, we can define *C* class-conditional Gaussian distributions with a tied
    covariance *σ*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![P(f(x) | y = c) = 𝒩 (f(x) | μc,σ ) ](img/file166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Where *μ*[*c*] is the mean of the multivariate Gaussian distribution for each
    class *c*. This allows us to compute the empirical mean and covariance of each
    of these distributions for a given output of an intermediate layer, one for each
    class of our network. Based on the mean and covariance, we can compute the Mahalanobis
    distance of a single test image compared to our in-distribution data. We compute
    this for the class that is closest to the input image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![M (x) = max − (f(x)− ^μc)⊤ ^σ− 1(f(x)− ^μc) c ](img/file167.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This distance should be small for in-distribution images and large for out-of-distribution
    images.
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy` has convenient functions to compute the mean and covariance of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these, we can compute the Mahalanobis distance as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Mahalanobis distance computation does not require any retraining and is
    a relatively cheap operation to perform once you have stored the mean and (inverse
    of the) covariance of the classes for the features of a layer of your network.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of the method, the authors show that we can also
    apply the input preprocessing as mentioned in the ODIN paper, or compute and then
    average the Mahalanobis distances extracted from multiple layers of the network.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Being robust against dataset shift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already encountered dataset shift in [*Chapter 3*](CH3.xhtml#x1-350003),
    [*Fundamentals of Deep* *Learning*](CH3.xhtml#x1-350003). As a reminder, dataset
    shift is a common problem in machine learning that happens when the joint distribution
    *P*(*X,Y* ) of inputs *X* and outputs *Y* differs between the model training stage
    and model inference stage (for example, when testing the model or when running
    it in a production environment). Covariate shift is a specific case of dataset
    shift where only the distribution of the inputs changes but the conditional distribution
    *P*(*Y* |*X*) stays constant.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset shift is present in most production environments because of the difficulty
    of including all possible inference conditions during training and because most
    data is not static but changes over time. The input data can shift along many
    different dimensions in a production environment. Geographic and temporal dataset
    shift are two common forms of shift. Imagine, for example, you have trained your
    model on data taken from one geographical region (for example, Europe) and then
    apply the model in a different geographical region (for example, Latin America).
    Similarly, a model could be trained on data from the years between 2010 and 2020
    and then applied on production data taken from today.
  prefs: []
  type: TYPE_NORMAL
- en: We will see that in such data shift scenarios, models often perform worse on
    the new shifted data than on their original training distribution. We will also
    see how vanilla neural networks usually do not indicate when the input data deviates
    from the training distribution. Finally, we will explore how various methods introduced
    in this book can be used to indicate dataset shift via uncertainty estimates and
    how these methods can make the models more robust. The following code example
    will be focused on an image classification problem. It should be noted, however,
    that the insights tend to generalize to other domains (such as natural language
    processing) and tasks (such as regression).
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Measuring a model’s response to dataset shift
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assuming that we have a training dataset and a separate test set, how can we
    measure a model’s ability to signal to us when the data has shifted? In order
    to do so, it would be necessary to have an additional test set where the data
    has been shifted to check how the model reacts to the dataset shift. One commonly
    applied way to create such a data shift test set for images was originally suggested
    by Dan Hendrycks and Thomas Dietterich in 2019 and others. The idea is straightforward:
    take the images from your initial test set, then apply different image quality
    corruptions at different severity levels to them. Hendrycks and Dietterich proposed
    a set of 15 different types of image quality corruptions, ranging from image noise,
    blur, weather corruptions (such as fog and snow), and digital corruption. Each
    corruption type has five levels of severity, ranging from 1 (mild corruption)
    to 5 (severe corruption). *Figure* [*8.4*](#x1-143002r4) shows what the image
    of a kitty looks like initially (left) and after applying shot noise corruption
    to the image, either at severity level 1 (middle) or severity level 5 (right).'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file168.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Generating artificial dataset shift by applying image quality corruptions
    at different levels of corruption severity'
  prefs: []
  type: TYPE_NORMAL
- en: All these image quality corruptions can be generated conveniently using the
    `imgaug` Python package. The following code assumes that we have an image called
    ”kitty.png” on disk. We load the image using the PIL package. We then specify
    the corruption type (for example, `ShotNoise`) via the name of the corruption
    function, and then apply the corruption function to the image, using either severity
    level 1 or 5 by passing the corresponding integer to the key-worded `severity`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of generating data shift this way is that it can be applied to
    a wide range of computer vision problems and datasets. Some of the few prerequisites
    for applying this method are that the data consists of images and that these image
    quality corruptions have not been used during training, for example, for data
    augmentation. Furthermore, by setting the severity of the image quality corruption,
    we gain control over the degree of the dataset shift. This allows us to measure
    how the model reacts to different degrees of dataset shift. We can measure both
    how performance changes in response to dataset shift and how calibration (introduced
    in [*Chapter 2*](CH2.xhtml#x1-250002), [*Fundamentals of Bayesian Inference*](CH2.xhtml#x1-250002))
    changes. We would expect that models trained with Bayesian methods or extensions
    should be better calibrated, which means that they are able to indicate to us
    that the data has shifted in comparison to training and they are thus less certain
    in their output.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Revealing dataset shift with Bayesian methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following code example, we will look at two of the BDL methods (Bayes
    by backprop and deep ensembles) that we have encountered in the book so far and
    see how they perform during the kind of artificial dataset shift described previously.
    We will compare their performance against a vanilla neural network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Preparing the environment'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We start the example by importing a list of packages. This includes TensorFlow
    and TensorFlow Probability, which we will use for building and training the neural
    networks; `numpy` for manipulating numerical arrays (such as calculating the mean);
    `Seaborn`, `Matplotlib`, and `pandas` for plotting; `cv2` and `imgaug` for loading
    and manipulating images; as well as `scikit-learn` for calculating the accuracy
    of our models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In preparation for the training, we will load the `CIFAR10` dataset, which is
    an image classification dataset, and specify the names of the different classes.
    The dataset consists of 10 different classes, the names of which we specify in
    the following code, and provides 50,000 training images as well as 10,000 test
    images. We’ll also save the number of training images, which will be needed to
    train the model with the reparameterization trick later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Defining and training the models'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After this prep work, we can define and train our models. We start by creating
    two functions to define and build the CNN. We will use these functions both for
    the vanilla neural network and the deep ensemble. The first function simply combines
    a convolutional layer with a max-pooling layer – a common approach that we introduced
    in [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals of Deep* *Learning*](CH3.xhtml#x1-350003).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function then uses several convolutional/max-pooling blocks in sequence
    and follows this sequence with a final dense layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create two analogous functions to define and build the network using
    Bayes By Backprop (BBB) based on the reparameterization trick. The strategy is
    the same as for the vanilla neural network, just that we’ll now use the convolutional
    and dense layers from the TensorFlow Probability package instead of the TensorFlow
    package. The convolutional/max-pooling blocks are then defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And the final network is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then train the vanilla neural network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also train the ensemble, with five ensemble members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we train the BBB model. Note that we train the BBB model for 15
    instead of 10 epochs, given that it takes a little longer to converge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Obtaining predictions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have three trained models, we can use them for predictions on the
    hold-out test set. To keep computations at a manageable degree, in this example,
    we will focus on the first 1,000 images in the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to measure the response to dataset shift, we first need to apply
    the artificial image corruptions to the dataset. To do that, we first specify
    a set of functions from the `imgaug` package. From their names, one can infer
    what type of corruption each of these functions implements: for example, the function
    `icl.GaussianNoise` corrupts an image by applying Gaussian noise to it. We also
    infer the number of corruption types from the number of functions and save it
    in the `NUM_TYPES` variable. Finally, we set the number of corruption levels to
    5.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Equipped with these functions, let us now corrupt images. In the next code block,
    we loop over the different corruption levels and types. We collect all corrupted
    images in the aptly named `corrupted_images` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the three models trained and the corrupted images at hand, we can now
    see how our models react to dataset shift of different levels. We will first obtain
    predictions on the corrupted images from the three models. To run inference, we
    need to reshape the corrupted images to an input shape that is accepted by the
    models for inferences. At the moment, the images are still stored on different
    axes for the corruption types and levels. We change this by reshaping the `corrupted_images`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can perform inference with the vanilla CNN model, both on the original
    images and the corrupted images. After we have inferred the model predictions,
    we reshape the predictions in order to separate predictions for the corruption
    types and levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To run inference with the ensemble model, we first define a prediction function
    to avoid code duplication. This function handles the looping over the different
    member models of the ensemble and combines the different predictions in the end
    via averaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Equipped with this function, we can perform inference with the ensemble model
    on both the original and corrupted images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as for the ensemble model, we write an inference function for the BBB
    model, which handles the iteration over different sampling loops and collects
    and combines the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then put this function to use to obtain the BBB model predictions on the
    original and corrupted images. We sample from the BBB model 20 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert the predictions of the three models to predicted classes and
    associated confidence scores by returning the index of the class with the maximum
    softmax score and the maximum softmax score, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can then be applied to get the predicted classes and confidence
    scores for our three models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us visualize what these predicted classes and confidence scores look like
    for the three models on a selected image showing an automobile. For plotting,
    we first reshape the array that contains the corrupted images to a more convenient
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We then plot the selected automobile image with the first three corruption types
    in the list across all five corruption levels. For each combination, we display
    in the image title the predicted score of each model and in squared parentheses
    the predicted class. The plot is shown in *Figure *[*8.5*](#x1-147361r5).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file169.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: An automobile image has been corrupted with different corruption
    types (rows) and levels (columns, severity increases from left to right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code continues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure *[*8.5*](#x1-147361r5) only shows results for a single image, so we
    should not read too much into these results. However, we can already observe that
    the prediction scores for the two Bayesian methods (and especially the ensemble
    method) tend to be less extreme than for the vanilla neural network, which has
    predicted scores as high as 0.95\. Furthermore, we see that, for all three models,
    prediction scores usually decrease as the corruption level increases. This is
    expected: given that the car in the image becomes less discernible with more corruption,
    we would want the model to become less confident as well. In particular, the ensemble
    method shows a nice and consistent decrease in predicted scores with increased
    corruption levels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Measuring accuracy'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Are some models more robust to dataset shift than other models? We can answer
    this question by looking at the accuracy of the three models at different corruptions
    levels. It is expected that all models will show lower accuracy as the input image
    becomes more and more corrupted. However, more robust models should lose less
    in accuracy as the corruptions become more severe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can calculate the accuracy of the three models on the original test
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can store these accuracies in a list of dictionaries, which will make it
    easier to plot them systematically. We pass the respective name of the models.
    For corruption `type` and `level`, we pass `0` because these are the accuracies
    on the original images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we calculate the accuracy of the three models on the different corruption
    type by corruption level combinations. We also append the results to the list
    of accuracies that we started previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can then plot the distributions of accuracies for the original images and
    the increasingly corrupted images. We first convert the list of dictionaries to
    a pandas dataframe. This has the advantage that the dataframe can be directly
    passed to the plotting package `seaborn`. This allows us to specify that we want
    to plot the different models’ results in different hues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file170.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Accuracy for the three different models (different hues) for the
    original test images (level 0) as well as for increasing levels of corruption
    (level 1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting plot is shown in *Figure *[*8.6*](#x1-148194r6). We can see that,
    on the original test images, the vanilla and BBB model have comparable accuracy,
    while the ensemble model has slightly higher accuracy. As corruption is introduced,
    we see that the performance of the vanilla neural network is worse (often significantly)
    than the performance of the ensemble or BBB. This relative improvement in performance
    of the BDL models demonstrates the regularization effect of Bayesian methods:
    these methods are able to capture the distribution of the data more effectively,
    making them more robust to perturbations. BBB exhibits particular resilience to
    increasing amounts of data corruption, demonstrating a key benefit of variational
    learning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Measuring calibration'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Looking at accuracy is a good way to determine how robust a model is against
    dataset shift. But it does not really tell us whether the models are capable of
    signalling to us (via lower confidence scores) when the dataset has shifted and
    the models have become less confident in their output. This question can be answered
    by looking at how well models remain calibrated under dataset shift. We introduced
    calibration and expected calibration errors on a conceptual level back in [*Chapter 3*](CH3.xhtml#x1-350003),
    [*Fundamentals of Deep Learning*](CH3.xhtml#x1-350003). We are now going to put
    these concepts into practice to understand whether models adjust their confidence
    appropriately as the images become increasingly corrupted and hard to predict.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will implement the Expected Calibration Error (ECE) introduced in
    [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals of Deep Learning*](CH3.xhtml#x1-350003)
    as a scalar measure of calibration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then calculate ECE for the three models on the original test images.
    We set the number of bins to `10`, which is a common choice for calculating ECE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did for the accuracies earlier, we will store the calibration results
    in a list of dictionaries, which will make it easier to plot them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we calculate the expected calibration error of the three models on the
    different corruption types by corruption level combinations. We also append the
    results to the list of calibration results that we started previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we plot the calibration results in a boxplot, again using `pandas`
    and `seaborn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The calibration results are shown in *Figure *[*8.7*](#x1-149394r7). We can
    see that, on the original test images, all three models have relatively low calibration
    error, with the ensemble model performing slightly worse than the two other models.
    As we apply increasing levels of dataset shift, we can see that calibration error
    increases by a lot for the vanilla model. For the two Bayesian methods, calibration
    error also increases but by much less than for the vanilla model. This means that
    the Bayesian methods are better at indicating (via lower confidence scores) when
    the dataset has shifted and that the Bayesian models become relatively less confident
    in their output with increased corruption (as they should).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file171.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Expected calibration error for the three different models for the
    original test images (level 0) as well as for increasing levels of corruption
    (level 1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look into data selection.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Using data selection via uncertainty to keep models fresh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw at the beginning of the chapter that we can use uncertainties to figure
    out whether data is part of the training data or not. We can expand on this idea
    in the context of an area of machine learning called **active learning**. The
    promise of active learning is that a model can learn more effectively on less
    data if we have a way to control the type of data it is trained on. Conceptually,
    this makes sense: if we train a model on data that is not of sufficient quality,
    it will also not perform well. Active learning is a way to guide the learning
    process and data a model is trained on by providing functions that can acquire
    data from a pool of data that is not part of the training data. By iteratively
    selecting the right data from the pool, we can train a model that performs better
    than if we had chosen the data from the pool at random.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Active learning can be used in many modern-day systems where there is a ton
    of unlabeled data available and we need to carefully select the amount of data
    we want to label. An example is an autonomous driving system: the camera on the
    car records a lot of data, but there is typically no budget to label all of it.
    By carefully choosing the most informative data points, we can improve the model
    performance at a lower cost than when we would have randomly selected the data
    to label. In the context of active learning, estimating uncertainties plays an
    important role. A model will typically learn more from areas of the data distribution
    that were predicted with low confidence. Let’s look at a case study to see how
    we can use uncertainty in the context of active learning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case study, we will reproduce the results from a fundamental active
    learning paper: *Deep Bayesian Active Learning with Image Data* (2017). We will
    use the `MNIST` dataset and train a model on more and more data, where we select
    the data points to add to our training set via an uncertainty method. In this
    case, we will use epistemic uncertainty to select the most informative data points.
    Images with high epistemic uncertainty should be images that the model did not
    see before; the uncertainty can be reduced by adding more of them. As a comparison,
    we will also select data points at random.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Preparing our dataset'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will start by creating our functions to load the dataset. The dataset functions
    need the following library imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As our total dataset will have quite a few components, we will create a small
    dataclass to easily access all the different parts of our dataset. We will also
    modify the `__repr__` function of the dataclass. This allows us to print the content
    of the dataset in a more readable format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We can then define our function to load our standard dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we will start training on just 20 samples from the *MNIST* dataset.
    We will then acquire 10 data points at a time, and retrain our model again. To
    help our model a little bit in the beginning, we will make sure that the 20 data
    points are balanced across the different classes of the dataset. The following
    function gives us the indices that we can use to create the initial 20 samples,
    2 samples of each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define a small function to actually get our initial dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Setting up our configuration'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start to build our model and create the active learning loop, we define
    a small configuration `dataclass` to store some main variables we might want to
    play around with when running our active learning script. Creating configuration
    classes such as these allows you to play around with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Defining the model'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can now define our model. We will use a small, simple CNN with dropout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4: Defining the uncertainty functions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As indicated, we will use epistemic uncertainty (also knowledge uncertainty)
    as our main uncertainty function to acquire new samples. Let’s define the function
    to compute epistemic uncertainty over our predictions. We assume that the input
    predictions (`divds`) are of shape `n_images`, `n_predictions`, `n_classes`. We
    first define a function to compute total uncertainty. Given an ensemble of model
    predictions, this can be defined as the entropy of the averaged predictions of
    the ensemble.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We then define data uncertainty (or aleatoric uncertainty), which for an ensemble
    is the average of the entropy of each ensemble member.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have our knowledge (or epistemic) uncertainty, which is simply subtracting
    data uncertainty from the total uncertainty of the predictions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'With these uncertainty functions defined, we can define the actual acquisition
    functions that take as main input our training data and our model. To acquire
    samples via knowledge uncertainty, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain our ensemble of predictions via MC dropout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the knowledge uncertainty values over this ensemble.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the uncertainty values, get their index and return the indices of our training
    data with the highest epistemic uncertainty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then, later on, reuse these indices to index into our training data and
    actually acquire the training samples we want to add.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain our MC dropout predictions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To avoid running out of memory, we iterate over our training data in batches
    of six, where for every batch we compute our predictions `n_iter` times. To make
    sure that our predictions are varied, we set the model’s `training` parameter
    to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our comparison, we define an acquisition function that returns a random
    number of indices as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define a small function according to the *factory method pattern*
    to make sure that we can use the same function in our loop to use either the random
    acquisition function or knowledge uncertainty. Small factory functions such as
    these help to keep your code modular when you want to run the same code with different
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our acquisition functions, we are ready to actually
    define the loop that runs our active learning iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Defining the loop'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by defining our configuration. In this case, we are using knowledge
    uncertainty as our uncertainty function. In a different loop, we will use a random
    acquisition function to compare the results of the loop we are about to define.
    We will start our dataset with 20 samples until we reach a total of 1,000 samples.
    Each model will be trained for 50 epochs and per iteration, we acquire 10 samples.
    To obtain our MC dropout predictions, we will run over our full training set (minus
    the already acquired samples) 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can then get our data and define an empty dictionary to keep track of the
    test accuracy per iteration. We also create an empty list to keep track of the
    full list of indices we added to our training data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We also assign a **universally unique identifier** (**UUID**) to our run to
    make sure we can discover it easily and do not overwrite the outcomes we save
    as part of our loop. We create the directory where we will save our data and save
    our configuration in that directory to ensure that we always know with what kind
    of configuration the data in our `model_dir` was created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now actually run our active learning loop. We will break this loop into
    three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the loop and fit a model on the acquired samples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then load the model with the best validation accuracy and update our dataset
    based on the acquisition function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We finally save the added images, compute the test accuracy, and save the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this loop, we defined a few small helper functions. First of all, we defined
    a callback for our model to save the model with the highest validation accuracy
    to our model directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We also defined a function to compute the accuracy of our test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And we defined two small functions to save the results per iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that running the active learning loop takes quite a long time: for every
    iteration, we train and evaluate our model for 50 epochs, and then run through
    our pool set (the full training dataset minus the acquired samples) 100 times.
    When using a random acquisition function, we avoid the last step but still run
    our validation data through our model 50 times per iteration, just to make sure
    that we use the model with the best validation accuracy. This takes time, but
    picking the model with just the best *training* accuracy would be risky: our model
    sees the same few images many times during training and is therefore likely to
    overfit to the training data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Inspecting the results'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have our loop, we can inspect the results of this process. We will
    use `seaborn` and `matplotlib` to visualize our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The main result we are interested in is the test accuracy over time for both
    the models trained with a random acquisition function and the models trained with
    data acquired via knowledge uncertainty. To visualize this, we define a function
    that loads the results and then returns a plot that shows the accuracy per active
    learning iteration cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this function to plot the results for both acquisition functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file172.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Active learning results'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure* [*8.8*](#x1-156074r8) shows that acquiring samples via knowledge uncertainty
    starts to improve the model’s accuracy significantly after around 300 acquired
    samples. The final accuracy of this model is about two percentage points higher
    than the accuracy of the model trained on random samples. This might not look
    like a lot, but we can also look at the data in another way: how many samples
    were needed to achieve a particular accuracy? If we inspect the plot, we can see
    that the knowledge uncertainty line achieves an accuracy of 96% with 400 training
    samples. The model trained on random samples required at least 750 samples to
    achieve the same accuracy. That’s almost double the amount of data for the same
    accuracy. This shows that active learning with the right acquisition function
    can be very useful, specifically in cases where compute resources are available,
    but labeling is expensive: with the right samples, we might be able to decrease
    our labeling cost by a factor of two to achieve the same accuracy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we saved the acquired samples for every iteration, we can also inspect
    the type of images selected by both models. To make our visualization easier to
    interpret, we will visualize the last five acquired images for every method for
    every label. To do this, we first define a function that returns the images per
    label for a set of model directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a function that creates a `PIL Image` where we concatenate the
    images per label for a particular acquisition function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call these functions, in our case with the following setup and
    *UUID*s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Let’s compare the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file173.png)![PIC](img/file174.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Images randomly selected (left) and images selected via knowledge
    uncertainty with MC dropout (right). Every row shows the last five images selected
    for the label'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Figure* [*8.9*](#x1-156175r9) that the images selected by the
    knowledge uncertainty acquisition function are probably more difficult to classify
    compared to the randomly selected images. The uncertainty acquisition function
    selects quite a few unusual representations of the digits in the dataset. Because
    our acquisition function was able to select these images, the model was better
    able to understand the full distribution of the dataset, which resulted in better
    accuracy over time.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Using uncertainty estimates for smarter reinforcement learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reinforcement learning** aims to develop machine learning techniques capable
    of learning from their environment. There’s a clue to the fundamental principle
    behind reinforcement learning in its name: the aim is to reinforce successful
    behaviour. Generally speaking, in reinforcement learning, we have an agent capable
    of executing a number of actions in an environment. Following these actions, the
    agent receives feedback from the environment, and this feedback is used to allow
    the agent to build a better understanding of which actions are more likely to
    lead to a positive outcome given the current state of the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Formally, we can describe this using a set of states, *S*, a set of actions
    *A*, which map from a current state *s* to a new state *s*^′, and a reward function,
    *R*(*s,s*^′), describing the reward for the transition between the current state,
    *s*, and the new state, *s*^′. The set of states comprises a set of environment
    states, *S*[*e*], and a set of agent states, *S*[*a*], which together describe
    the state of the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of this in terms of a game of Marco Polo, wherein call and response
    is used by one player in order to find another player. When the seeking player
    calls ”Marco,” the other player replies ”Polo,” giving the seeking player an estimate
    of their location based on the direction and amplitude of the sound. If we simplify
    this to consider it in terms of distance, a closer state would be one for which
    the distance reduces, such as *δ* = *d* − *d*^′ *>* 0, where *d* is the distance
    at state *s* and *d*^′ is the distance for state *s*^′. Conversely, a further
    state would be one for which *δ* = *d* − *d*^′ *<* 0\. Thus, for this example,
    we can use our *δ* values as feedback for our model, making our reward function
    *δ* = *R*(*s,s*^′) = *d* − *d*^′.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file175.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Illustration of a Marco Polo reinforcement learning scenario'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider our agent as the seeking player and its target as the hiding
    player. At each step, our agent collects more information about its environment,
    enabling it to better model the relationship between its actions *A*(*s*) and
    the reward function *R*(*s,s*^′) (in other words, it’s learning which general
    direction it needs to move in to get closer to the target). At each step, we need
    to predict the reward function given the set of possible actions at the current
    state, *A*[*s*], so that we can choose the action that is most likely to maximize
    this reward function. In this case, the set of actions could be a set of directions
    we can move in, for example: forward, back, left, and right.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional reinforcement learning uses a method called **Q Learning** to learn
    the relationship between the state, action, and reward. Q Learning doesn’t involve
    neural network models, and instead accumulates state, action, and reward information
    in a table – the Q table – which is then used to determine the action most likely
    to produce the highest reward given the current state. While Q Learning is powerful,
    it becomes computationally prohibitive for large numbers of states and actions.
    To address this, researchers introduced the concept of **Deep Q Learning**, wherein
    the Q table is replaced by a neural network. Over a (usually large) number of
    iterations, the neural network learns which actions are likely to produce a higher
    reward given the current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To predict which action is likely to yield the highest reward value, we use
    a model trained on all historical actions, *A*[*h*], states *S*[*h*], and rewards,
    *R*[*h*]. Our training input *X* comprises the actions *A*[*h*] and states *S*[*h*],
    while our target output *y* comprises the reward values *R*[*h*]. We can then
    use the model as part of a **Model predictive Controller**, or **MPC**, which
    will select the action depending on which action is associated with the highest
    predicted reward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![anext = argmax yi∀ai ∈ As ](img/file176.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *y*[*i*] is the reward prediction produced by our model, *f*(*a*[*i*]*,s*),
    which maps the current state *s* and possible actions *a*[*i*] ∈ *A*[*s*] to reward
    values. However, before our model is of any use, we’ll need to gather data to
    train on. We’ll accrue data over a number of episodes, wherein each episode comprises
    a set of actions taken by the agent until some termination criteria are met. The
    ideal termination criterion would be the agent finding the target, but we can
    set other criteria, such as the agent encountering an obstacle, or the agent exhausting
    a maximum number of actions. Because the model has no information to start off
    with, we use a greedy policy commonly used in reinforcement learning, called an
    *𝜖greedy* policy, to allow the agent to start by randomly sampling from its environment.
    The idea here is that our agent will perform a random action with probability
    *𝜖*, and will otherwise use model predictions to select the action. After each
    episode, we will decrease *𝜖*, such that the agent will eventually be selecting
    actions based solely on the model. Let’s put together a simple reinforcement learning
    example to see all of this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Initializing our environment'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our reinforcement learning example will be centred around our environment:
    this defines the space in which everything happens. We’ll handle this with the
    `Environment` class. First, we set up our environment parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, notice our environment size, denoted by `env_size`, which defines the
    number of rows and columns in our environment – in this case, we’ll have an environment
    of size 8 × 8, resulting in 64 locations (for simplicity, we’ll stick with a square
    environment). We’ll also set a `max_steps` limit so that episodes don’t go on
    too long while our agent is randomly selecting actions.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the `agent_location` and `target_location` variables – the agent
    always starts at point [0, 0], while the target location is randomly allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a dictionary to map an integer value to an action. Going from
    0 to 3, these actions are: forward, backward, right, left. We also set the `delta`
    variable – this is the initial distance between the agent and the target (we’ll
    see how `compute_distance()` is implemented in a moment).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we initialize a few variables for tracking whether the termination
    criteria have been met (`is_done`), the total number of steps (`total_steps`),
    and the ideal number of steps (`ideal_steps`). The latter of these variables is
    the minimum number of steps required for the agent to get to the target from its
    starting position. We’ll use this to calculate the regret, which is a useful indicator
    of performance for reinforcement learning and optimization algorithms. To calculate
    this, we’ll add the following two functions to our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Here, `calculate_ideal_steps()` will run until the distance (`delta`) between
    the agent and the target is zero. At each iteration, it uses `calculate_ideal_action()`
    to select the action that will move the agent closest to the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Updating the state of our environment'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve initialized our environment, we need to add one of the most
    crucial pieces of our class: the `update` method. This controls what happens to
    our environment when the agent takes a new action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The method receives an action integer, and uses this to access the corresponding
    action in the `action_space` dictionary we defined earlier. It then updates the
    agent location. Because both the agent location and action are vectors, we can
    simply use vector addition to do this. Next, we check whether the agent has moved
    out of bounds of our environment – if it has, we simply adjust its location so
    that it remains within our environment boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line is another crucial piece of code: computing the reward with `compute_reward()`
    – we’ll take a look at this in just a moment. Once we’ve computed the reward,
    we increment the `total_steps` counter, check our termination criteria, and return
    the reward value for the action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We determine the reward using the following function. This will return a low
    reward (`1`) if the distance between the agent and the target increases, and a
    high reward (`10`) if the distance between the agent and target decreases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `compute_distance()` function, which calculates the Euclidean
    distance between the agent and the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need a function to allow us to fetch the state of the environment,
    so that we can associate this with the reward values. We define this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Defining our model'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve set up our environment, we’ll create a model class. This class
    will handle model training and inference, as well as selecting the best action
    according to the model’s predictions. As always, we start with the `__init__()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass a few variables related to our environment, such as the state
    size and number of actions. The code relating to the model definition should be
    familiar – we’re simply instantiating a neural network using Keras. One point
    to note is that we’re using the Huber loss here, instead of something more common
    such as the mean squared error. This is a common choice in robust regression tasks
    and in reinforcement learning. The reason for this is that the Huber loss dynamically
    switches between mean squared error and mean absolute error. The former is very
    good at penalizing small errors, while the latter is more robust to outliers.
    Through the Huber loss, we arrive at a loss function that is both robust to outliers
    and penalizes small errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is particularly important in reinforcement learning because of the exploratory
    nature of the algorithms: we will often encounter some examples that are very
    exploratory, deviating significantly from the rest of the data, and thus causing
    large errors during training.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our class initialization out of the way, we move on to our `fit()` and
    `predict()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `fit()` function should look very familiar – we’re just scaling our inputs
    before fitting our Keras model. The `predict()` function has a little more going
    on. Because we need predictions for each of our possible actions (forward, backward,
    right, left), we need to generate inputs for these. We do so by concatenating
    the integer value associated with the action to the state, producing our complete
    state-action vector as we see on line 11\. Doing this for all actions results
    in our input matrix, *X*, for which each row is associated with a specific action.
    We then scale *X* and run inference on this to obtain our predicted reward values.
    To select an action, we simply use `np.argmax()` to obtain the index associated
    with the highest predicted reward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Running our reinforcement learning'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve defined our `Environment` and `RLModel` classes, we’re ready
    to do some reinforcement learning! Let’s first set up some important variables
    and instantiate our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of these should be familiar by now, but we’ll go over a few that we’ve
    not yet covered. The `history` dictionary is where we’ll store our state and reward
    information as we progress through each step in each episode. We’ll then use this
    information to train our model. Another unfamiliar variable here is `n_samples`
    – we’re setting this because, rather than using all available data each time we
    train our model, we’ll sample 1,000 data points from our data. This helps to avoid
    our training time exploding as we accrue more and more data. The last new variable
    here is `regrets`. This list will store our regret values for each episode. In
    our case, regret is defined simply as the difference between the number of steps
    taken by the model and the minimum number of steps required for the agent to reach
    the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![regret = steps − steps model ideal ](img/file177.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As such, regret is zero *⇔* *steps*[*model*] == *steps*[*ideal*]. Regret is
    useful for measuring performance as our model learns, as we’ll see in a moment.
    All that’s left is the main loop of our reinforcement learning process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our reinforcement learning process run from 100 episodes, reinitializing
    the environment each time. As we can see from the internal `while` loop, we will
    continue iterating – updating our agent and measuring our reward – until one of
    the termination criteria is met (either the agent reaches the target, or we run
    for the maximum allowed number of iterations).
  prefs: []
  type: TYPE_NORMAL
- en: After each episode, a `print` statement lets us know that the episode completed
    without error, and tells us how our agent did compared to the ideal number of
    steps. We then calculate the regret and append this to our `regrets` list, sample
    from our data in `history` and fit our model on the sampled data. Lastly, we finish
    each iteration of the outer loop by reducing epsilon.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this, we can additionally plot our regret values to see how we
    did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following plot, showing how our model did over the 100 episodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file178.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Plot of regret values following 100 episodes of reinforcement
    learning'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see here, it did poorly to begin with, but the model quickly learned
    to predict reward values, allowing it to predict optimal actions, and reducing
    regret to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, things are pretty simple. In fact, you may be wondering why we need
    a model at all – why not just calculate the distance between the target and the
    proposed positions, and select an action accordingly? Well, firstly, the aim of
    reinforcement learning is for an agent to discover how to interact in a given
    setting without any prior knowledge – so while our agent can execute actions,
    it has no concept of distance. This is something that is learned through interacting
    with the environment. Secondly, it may not be that simple: what if there are obstacles
    in the environment? In this case, our agent needs to be more intelligent than
    simply moving toward the sound.'
  prefs: []
  type: TYPE_NORMAL
- en: While this is just an illustrative example, real-world applications of reinforcement
    learning involve scenarios for which we have very limited knowledge, and thus
    designing an agent that can explore its environment and learn how to interact
    optimally allows us to develop models for applications for which supervised methods
    aren’t an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another factor to consider in real-world scenarios is risk: we want our agent
    to make *sensible* decisions, not just decisions that maximize the reward: we
    need it to build some understanding of the risk/reward trade-off. This is where
    uncertainty estimates come in.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Navigating obstacles with uncertainty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With uncertainty estimates, we can balance the reward against the model’s confidence
    in its prediction. If its confidence is low (meaning that uncertainty is high),
    then we may want to be cautious about how we incorporate our model’s predictions.
    For example, let’s take the reinforcement learning scenario we’ve just explored.
    For each episode, our model is predicting which action will yield the highest
    reward, and our agent then chooses this action. In the real world, things aren’t
    so predictable – our environment can change, leading to unexpected consequences.
    What if an obstacle appears in our environment, and colliding with that obstacle
    prevents our agent from completing its task? Well, clearly if our agent hasn’t
    yet encountered the obstacle, it’s doomed to fail. Fortunately, in the case of
    Bayesian Deep Learning, this isn’t the case. As long as we have some way of sensing
    the obstacle, our agent can detect the obstacle and take a different route – even
    if the obstacle wasn’t encountered in previous episodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file179.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Illustration of how uncertainty affects the actions of a reinforcement
    learning agent'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible thanks to our uncertainty estimates. When the model encounters
    something unusual, its uncertainty estimate for that prediction will be high.
    Thus, if we incorporate this into our MPC equation, we can balance reward with
    uncertainty, ensuring that we prioritize lower risk over higher reward. To do
    so, we modify our MPC equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![anext = argmax (yi − λσi)∀ai ∈ As ](img/file180.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we see that we’re now subtracting a value, *λσ*[*i*], from our reward
    prediction *y*[*i*]. This is because *σ*[*i*] is our uncertainty associated with
    the *i*th prediction. We use *λ* to scale the uncertainty so that it appropriately
    penalizes uncertain actions; this is a parameter we can tune depending on the
    application. With a sufficiently well calibrated method, we’ll see larger values
    for *σ*[*i*] in cases where the model is uncertain about its predictions. Let’s
    build on our earlier code example to see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Introducing obstacles'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a challenge for our agent, we’re going to introduce obstacles to
    our environment. To test how our agent responds to unfamiliar input, we’re going
    to change the policy that our obstacle follows - it will either follow a static
    policy or a dynamic policy depending on our environment settings. We’ll change
    the `__init__()` function for our `Environment` class to incorporate these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: There’s quite a lot going on here, so we’ll go through each of the changes.
    First, to determine whether the obstacle is static or dynamic, we set the `dynamic_obstacle`
    variable. If this is `True`, then we’ll randomly set the obstacle location. If
    it’s `False`, then our object will sit in the middle of our environment. We’re
    also setting our `lambda` (*λ*) parameter here, which defaults to 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve also introduced a `while` loop here when setting `target_location`: we’ve
    done this to ensure that there’s some distance between the agent and the target.
    We need to do this to ensure there’s space between our agent and our target to
    drop in our dynamic obstacle – otherwise our agent may never encounter the obstacle
    (which would somewhat defeat the point of this example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we compute the obstacle location on line 17: you’ll note that this
    just sets it to the middle of the environment. This is because we use the `dynamic_obstacle`
    flag later on to place the obstacle between the agent and the target – we do this
    during the `calculate_ideal_steps()` function, as this way we know the obstacle
    will lie along the agent’s ideal path (and is thus more likely to be encountered).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Placing our dynamic obstacle'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When `dynamic_obstacle` is `True`, we want to place our obstacle somewhere
    different each episode, thus posing more of a challenge for our agent. To do so,
    we add a modification to the `calculate_ideal_steps()` function, as mentioned
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that we call `np.random.randint(0, 2)` on each iteration of the
    `while` loop. This is to randomize in which position the obstacle is placed along
    the ideal path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Adding sensing'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our agent will have no hope of avoiding the object introduced into our environment
    if it can’t sense the object. As such, we’ll add a function to simulate a sensor:
    `get_obstacle_proximity()`. This sensor will give our agent information on how
    close it would get to an object were it to take a certain action. We’ll have this
    return progressively higher values depending on how close to the object a given
    action would place our agent. If the action places our agent sufficiently far
    from the object (in this case, at least 4.5 spaces), then our sensor will return
    zero. This sensing function allows our agent to effectively see one step ahead,
    so we can think of the sensor as having a range of one step.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first compute the future proximity for the agent given each action,
    after which we compute integer ”proximity” values. These are computed by first
    constructing Boolean arrays for each proximity condition, in this case being *δ*[*o*]
    *<* 2*.*5, *δ*[*o*] *<* 3*.*5, and *δ*[*o*] *<* 4*.*5, where *δ*[*o*] is the distance
    to the obstacle. We then sum these such that the proximity score has integer values
    of 3, 2, or 1 depending on how many of the criteria are met. This gives us a sensor
    that returns some basic information about the obstacle’s future proximity for
    each of the proposed actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Modifying our reward function'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do to prepare our environment is to update our reward
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve added a statement to check whether the agent and obstacle have collided
    (checking whether the distance between the two is zero). If so, we’ll return a
    reward of 0, and set both the `collision` and `is_done` variables to `True`. This
    introduces a new termination criteria, **collision**, and will allow our agent
    to learn that collisions are bad, as these receive the lowest reward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Initializing our uncertainty-aware model'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that our environment is ready, we need a new model – one capable of producing
    uncertainty estimates. For this model, we’ll use an MC dropout network with a
    single hidden layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This should look pretty familiar, but you’ll notice a few key differences. First,
    we’re again using the Huber loss. Secondly, we’ve introduced a dictionary, `proximity_dict`,
    which will record the proximity values received from the sensor and the associated
    model uncertainties. This will allow us to evaluate our model’s sensitivity to
    anomalous proximity values later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Fitting our MC dropout network'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we need the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This should again look very familiar – we’re simply preparing our data by first
    scaling our inputs before fitting our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 7: Making predictions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, we see that we’ve slightly modified our `predict()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: More specifically, we’ve added the `obstacle_proximity` and `dynamic_obstacle`
    variables. The former allows us to receive the sensor information and incorporate
    this in the inputs we pass to our model. The latter is a flag telling us whether
    we’re in the dynamic obstacle phase – if so, we want to record information about
    the sensor values and uncertainties in our `proximity_dict` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next block of prediction code should again look very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This function simply implements the MC dropout inference, obtaining predictions
    for `nb_inference` forward passes, and returns the means and standard deviations
    associated with our predictive distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 8: Adapting our standard model'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To understand the difference that our Bayesian model makes, we’ll need to compare
    it with a non-Bayesian model. As such, we’ll update our `RLModel` class from earlier,
    adding the ability to incorporate proximity information from our proximity sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Crucially, we see here that our decision function has not changed: because
    we don’t have model uncertainties, our model’s `predict()` function is choosing
    actions based only on the predicted reward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 9: Preparing to run our new reinforcement learning experiment'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to set up our new experiment. We’ll initialize the variables
    we used previously, and will introduce a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that we’ve introduced a `collisions` variable and a `failed` variable.
    These will keep track of the number of collisions and the number of failed episodes
    so that we can compare the performance of our Bayesian model with that of our
    non-Bayesian model. We’re now ready to run our experiment!
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 10: Running our BDL reinforcement experiment'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As before, we’re going to run our experiment for 100 episodes. However, this
    time, we’re only going to run training on our model for the first 50 episodes.
    After that, we’ll stop training, and evaluate how well our model is able to find
    a safe path to the target. During these last 50 episodes, we’ll set `dynamic_obstacle`
    to `True`, meaning our environment will now randomly choose a different position
    for our obstacle for each episode. Importantly, these random positions will be
    *along the* *ideal path* between the agent and its target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the episode is within the first 50 episodes. If so,
    we instantiate our environment with `dynamic_obstacle=False`, and also set our
    global `dynamic_obstacle` variable to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: If the episode is one of the last 50 episodes, we create an environment with
    a randomly placed obstacle, and also set `epsilon` to 0, to ensure we’re always
    using our model predictions when selecting actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we enter our `while` loop, setting our agent in motion. This is very
    similar to the loop we saw in the last example, except this time we’re calling
    `env.get_obstacle_proximity()`, using the returned obstacle proximity information
    in our predictions, and also storing this information in our episode history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we’ll record some information about completed episodes and print the
    outcome of the most recent episode to our terminal. We update our `failed` and
    `collisions` variables and print whether the episode was complete successfully,
    the agent failed to find the target, or the agent collided with the obstacle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The last statement here also checks whether we’re in the dynamic obstacle phase,
    and if not, runs a round of training and decrements our epsilon value (as with
    the last example).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how did we do? Repeating the above 100 episodes for both the `RLModel`
    and `RLModelDropout` models, we obtain the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Model** | **Failed episodes** | **Collisions** | **Successful episodes**
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RLModelDropout** | 19 | 3 | 31 |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RLModel** | 16 | 10 | 34 |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Figure 8.13: A table showing collision predictions'
  prefs: []
  type: TYPE_NORMAL
- en: As we see here, there are advantages and disadvantages to consider when choosing
    whether to use a standard neural network or a Bayesian neural network – the standard
    neural network achieves a greater number of successfully completed episodes. However,
    crucially, the agent using the Bayesian neural network only collided with the
    obstacle three times, compared to the standard method’s 10 times – that’s a 70%
    reduction in collisions!
  prefs: []
  type: TYPE_NORMAL
- en: Note that as the experiment is stochastic, your results may differ, but on the
    GitHub repository we have included the experiment complete with the seed used
    to produce these results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a better idea of why this is by looking at the data we recorded
    in `RLModelDropout`’s `proximity_dict` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file181.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Distribution of uncertainty estimates associated with increasing
    proximity sensor values'
  prefs: []
  type: TYPE_NORMAL
- en: As we see here, the model uncertainty estimates increase as the sensor values
    increase. This is because, during the first 50 episodes, our agent learns to avoid
    the centre of the environment (as this is where the obstacle is) – thus it gets
    used to low (or zero) proximity sensor values. This means that higher sensor values
    are anomalous, and are thus able to be picked up by the model’s uncertainty estimates.
    Our agent then successfully accounts for this uncertainty using the uncertainty-aware
    MPC equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we saw how BDL can be applied to reinforcement learning to
    facilitate more cautious behaviour on the part of our reinforcement learning agents.
    While the example here was fairly basic, the implications are pretty significant:
    imagine this being applied to safety-critical applications. In these settings,
    we’re often happy to accept poorer overall model performance if it meets better
    safety requirements. Thus, BDL has an important place within the field of safe
    reinforcement learning, allowing the development of reinforcement learning methods
    suitable for safety-critical scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we’ll see how BDL can be used to create models that are
    robust to another key consideration for real-world applications: adversarial inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Susceptibility to adversarial input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals of Deep Learning*](CH3.xhtml#x1-350003),
    we saw that we could fool a CNN by slightly perturbing the input pixels of an
    image. A picture that clearly looked like a cat was predicted as a dog with high
    confidence. The adversarial attack that we created (*FSGM*) is one of the many
    adversarial attacks that exist, and BDL might offer some protection against these
    attacks. Let’s see how that works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Model training'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of using a pre-trained model, as in [*Chapter 3*](CH3.xhtml#x1-350003),
    [*Fundamentals of Deep* *Learning*](CH3.xhtml#x1-350003), we train a model from
    scratch. We use the same train and test data from [*Chapter 3*](CH3.xhtml#x1-350003),
    [*Fundamentals of Deep Learning*](CH3.xhtml#x1-350003) – see that chapter for
    instructions on how to load the dataset. As a reminder, the dataset is a relatively
    small dataset of cats and dogs. We first define our model. We use a VGG-like architecture
    but add dropout after every `MaxPooling2D` layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We then normalize our data, and compile and train our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This will give us a model accuracy of about 85%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Running inference and evaluating our standard model'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have trained our model, let’s see how much protection it offers
    against an adversarial attack. In [*Chapter 3*](CH3.xhtml#x1-350003), [*Fundamentals
    of Deep Learning*](CH3.xhtml#x1-350003), we created an adversarial attack from
    scratch. In this chapter, we’ll use the `cleverhans` library to create the same
    attack in one line for multiple images at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s first measure the accuracy of our deterministic model on the original
    images and the adversarial images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our predictions, we can print the accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our standard model offers little protection against this adversarial
    attack. Although it performs pretty well on standard images, it has an accuracy
    of 30.70% on adversarial images! Let’s see if a Bayesian model can do better.
    Because we trained our model with dropout, we can easily make it an MC dropout
    model. We create an inference function where we keep dropout at inference, as
    indicated by the `training=True` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'With this function in place, we can replace the standard loop with MC dropout
    inference. We keep track of all our predictions again and run inference on our
    standard images and the adversarial images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can again print our accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our simple modification made the model setup much more robust
    to adversarial examples. Instead of an accuracy of around 30%, we now obtain accuracy
    of more than 80%, pretty close to the accuracy of 83% of the deterministic model
    on the non-perturbed images. Moreover, we can see that MC dropout also improves
    the accuracy on our standard images by a few percentage points, from 83% to 86%.
    Almost no method offers perfect robustness to adversarial examples, so the fact
    that we can get so close to our model’s standard accuracy is a great achievement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our model has not seen the adversarial images before, a model with
    good uncertainty values should also have a lower confidence on average on the
    adversarial images compared to a standard model. Let’s see if this is the case.
    We create a function to compute the average softmax value of the predictions of
    our deterministic model and create a similar function for our MC dropout predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then print the mean softmax score for both models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our standard model is actually slightly more confident on adversarial
    images compared to standard images, although its accuracy dropped significantly.
    However, our MC dropout model shows a lower confidence on the adversarial images
    compared to the standard images. Although the drop in confidence is not very large,
    it is good to see that the model is dropping its mean confidence on adversarial
    images, while keeping a reasonable accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have illustrated the various applications of modern BDL
    in five different case studies. Each case study used code examples to highlight
    a particular strength of BDL in response to various, common problems in applied
    machine learning practice. First, we saw how BDL can be used to detect out-of-distribution
    images in a classification task. We then looked at how BDL methods can be used
    to make models more robust to dataset shift, which is a very common problem in
    production environments. Next, we learned how BDL can help us to select the most
    informative data points for training and updating our machine learning models.
    We then turned to reinforcement learning and saw how BDL can be used to facilitate
    more cautious behaviour in reinforcement learning agents. Finally, we saw how
    BDL can help us in the face of adversarial attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at the future of BDL by reviewing current
    trends and the latest methods.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following reading list will offer a greater understanding of some of the
    topics we touched on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Benchmarking neural network robustness to common corruptions and* *perturbations*,
    Dan Hendrycks and Thomas Dietterich, 2019: this is the paper that introduced the
    image quality perturbations to benchmark model robustness, which we saw in the
    robustness case study.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Can You Trust Your Model’s Uncertainty? Evaluating predictive* *Uncertainty
    Under Dataset Shift*, Yaniv Ovadia, Emily Fertig *et* *al.*, 2019: this comparison
    paper uses image quality perturbations to introduce artificial dataset shift at
    different severity levels and measures how different deep neural networks respond
    to dataset shift in terms of accuracy and calibration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Baseline for Detecting Misclassified and Out-of-Distribution* *Examples
    in Neural Networks*, Dan Hendrycks and Kevin Gimpel, 2016: this fundamental out-of-distribution
    detection paper introduces the concept and shows that softmax values are not perfect
    when it comes to OOD detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enhancing The Reliability of Out-of-distribution Image Detection in* *Neural
    Networks*, Shiyu Liang, Yixuan Li and R. Srikant, 2017: shows that input perturbation
    and temperature scaling can improve the softmax baseline for out-of-distribution
    detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Simple Unified Framework for Detecting Out-of-Distribution* *Samples and
    Adversarial Attacks*, Kimin Lee, Kibok Lee, Honglak Lee and Jinwoo Shin, 2018:
    shows that using the Mahalanobis distance can be effective for out-of-distribution
    detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
